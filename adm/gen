#!/bin/bash

#----------------------------------------------------------
# PARAM FOR GEN
#----------------------------------------------------------
# -databox # generate data box
# -addcol  # add column to data box 
# -delcol  # delete column of data box 
# -app     # generate app
# -job     # generate automate shell
#----------------------------------------------------------

param=$1
WHOAMI=`whoami`
if [ ! "$WHOAMI" = "root" ];then
  echo "error: user must be root"
  exit 1
fi

# user check
cat /etc/passwd | grep small-shell > /dev/null 2>&1
if [ ! $? -eq 0 ];then
  mac_chk=`dscl . list /Users 2>/dev/null | grep small-shell 2>/dev/null`
  if [ ! "$mac_chk" ];then
    echo "error: small-shell is not existing, please add user beforehand"
    exit 1
  fi
fi

# update global.conf
SCRIPT_DIR=`dirname $0`
line_chk=`cat ${SCRIPT_DIR}/../global.conf | wc -l | tr -d " "`

if [ $line_chk -eq 1 ];then

  chmod 755 ${SCRIPT_DIR}/../util/scripts/*
  sudo -u small-shell chmod 755 ${SCRIPT_DIR}/../util/e-cron/bin/*
  sudo -u small-shell chmod 755 ${SCRIPT_DIR}/../util/pyshell/pygraph.sh
  sudo -u small-shell chmod 755 ${SCRIPT_DIR}/../util/pyshell/env
  sudo -u small-shell chmod 755 ${SCRIPT_DIR}/../bin/*
  sudo -u small-shell chmod 755 ${SCRIPT_DIR}/../adm/*
  sudo -u small-shell chmod 755 ${SCRIPT_DIR}/../sbin/*

  if [ ! "$mac_chk" ];then

    which sha256sum > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install sha256sum command first"
      exit 1
    fi

    which base64 > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install base64 command first"
      exit 1
    fi

    which flock > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install flock command first"
      exit 1
    fi

    which php > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install php command first"
      exit 1
    fi

    which curl > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install curl command first"
      exit 1
    fi

    which bc > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install bc command first"
      exit 1
    fi

    which jq >/dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install jq command first"
      exit 1
    fi 

    echo "SHASUM=\"`which sha256sum`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "BASE64_ENC=\"`which base64` -w 0\"" >> ${SCRIPT_DIR}/../global.conf
    echo "BASE64_DEC=\"`which base64` -d\"" >> ${SCRIPT_DIR}/../global.conf
    echo "SED=\"`which sed`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "AWK=\"`which awk`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "FLOCK=\"`which flock`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "PHP=\"`which php`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "CURL=\"`which curl`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "BC=\"`which bc`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "JQ=\"`which jq`\"" >> ${SCRIPT_DIR}/../global.conf

  else

    which shasum > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install shasum command first"
      exit 1
    fi

    which base64 > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install base64 command first"
      exit 1
    fi

    which gsed > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install gsed first"
      exit 1
    fi

    which gawk > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install gawk first"
      exit 1
    fi

    which flock > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install flock first"
      exit 1
    fi

    which php > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install php command first"
      exit 1
    fi

    which curl > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install curl command first"
      exit 1
    fi

    echo "SHASUM=\"`which shasum` -a 256\"" >> ${SCRIPT_DIR}/../global.conf
    echo "BASE64_ENC=\"`which base64`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "BASE64_DEC=\"`which base64` -D\"" >> ${SCRIPT_DIR}/../global.conf
    echo "SED=\"`which gsed`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "AWK=\"`which gawk`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "FLOCK=\"`which flock`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "PHP=\"`which php`\"" >> ${SCRIPT_DIR}/../global.conf
    echo "CURL=\"`which curl`\"" >> ${SCRIPT_DIR}/../global.conf

    which jq >/dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "warn: please install jq command, if you want to use WEB API "
    else
      echo "JQ=\"`which jq`\"" >> ${SCRIPT_DIR}/../global.conf
    fi

  fi
fi

# load global conf
if [ ! -x ${SCRIPT_DIR}/../global.conf ];then
  chmod 755 ${SCRIPT_DIR}/../global.conf
fi
 . ${SCRIPT_DIR}/../global.conf

# owner check
shell_owner=`ls -ld $ROOT | $AWK '{print $3}'`
if [ ! "$shell_owner" = "small-shell" ];then
  echo "error: $ROOT is not owned by small-shell. please change owner by following command"
  echo "sudo chown -R small-shell:small-shell $ROOT"
  exit 1
fi

# gen tmpdir
random=$RANDOM
while [ -d $ROOT/tmp/gen/$random ]
do
 sleep 0.01
 count=`expr $count + 1`
 if [ $count -eq 100 ];then
   echo "error: something is wrong"
   exit 1
 fi
 random=$RANDOM
done
mkdir $ROOT/tmp/gen/$random
tmp_dir="$ROOT/tmp/gen/$random"

# handle kill signal
trap 'clear_dialog' SIGINT
function clear_dialog(){
  if [ -d "$tmp_dir" ];then
    echo ""
    echo "tmp file will be deleted, please try again from beginning"
    rm -rf $tmp_dir
    exit 1
  else
    echo ""
    echo "dialog will be ended, please try again from beginning"
    exit 1
  fi
}

# ascii check
function ascii_check(){
  input=$1  
  check=`echo "$input" | file -i - | grep -i ascii`
  if [ "$check" ]; then
    echo "NP"
    return 0
  else
    echo "ERROR"
    return 1
  fi
}

function charset_check(){
  input=$1
  check=`echo "$input" | file -i - | grep -i -e ascii -e utf`
  if [ "$check" ]; then
    echo "NP"
    return 0
  else
    echo "ERROR"
    return 1
  fi
}


# create AUTHKEY for SYS
user_name=sys
user_id=`echo "$user_name" | $SHASUM | $AWK '{print $1}'`

if [ ! -d $ROOT/users/$user_id ];then
  mkdir $ROOT/users/$user_id
  echo "$user_name" > $ROOT/users/$user_id/user_name
  echo "permission=ro" > $ROOT/users/$user_id/.attr.tmp
  cat $ROOT/users/$user_id/.attr.tmp > $ROOT/users/$user_id/attr
  chown small-shell:small-shell $ROOT/users/$user_id/attr

  which openssl  >/dev/null 2>&1
  if [ $? -eq 0 ];then
    hash_gen_key=`openssl rand -hex 20`
  else
    hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
  fi

  hash=`echo "${user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}'`
  echo "$hash" > $ROOT/users/${user_id}/hash
  chown -R small-shell:small-shell $ROOT/users/$user_id
  chmod 700 $ROOT/users/${user_id}/hash
  user_key=`echo "${user_name}:${hash_gen_key}" | $BASE64_ENC`
  echo "authkey=\"$user_key\"" > $ROOT/util/scripts/.authkey
  chown small-shell:small-shell $ROOT/util/scripts/.authkey
  chmod 700 $ROOT/util/scripts/.authkey
fi

# GENERATE DATA BOX 
if [ "$param" = "-databox" ];then

  if [ $2 ];then
    bat_chk=$2
    if [ "$bat_chk" = "-bat" ];then
      bat_flag=yes
    fi
  fi

  # command check for databox 
  sudo -u small-shell echo "\n" | $SED -z "s/\n//g" >/dev/null 2>&1
  if [ ! $? -eq 0 ];then
    echo "error: please install $SED command which can use -z option #above version 4.2.2"
    rm -rf $tmp_dir
    exit 1
  fi

  sudo -u small-shell echo "Create" | $AWK 'IGNORECASE = 1;/^create/;' >/dev/null 2>&1
  if [ ! $? -eq 0 ];then
    echo "error: please install $AWK command which can use INNORECASE option"
    rm -rf $tmp_dir
    exit 1
  fi

  # start dialog 
  echo -n "Databox Name: "
  read databox
  ascii_chk_result=`ascii_check $databox`
  meta_chk_result=$(echo $databox | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
  -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

  ls $ROOT/databox/$databox >/dev/null 2>&1
  if [ $? -eq 0 ];then
    existing_chk_result=existing
  else
    existing_chk_result=""
  fi

  while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" -o "$existing_chk_result" = "existing" -o ! "$databox" ]
  do

    if [ ! "$existing_chk_result" = "existing" ];then
      echo "error: databox name must be ascii text and you can't use meta charactor including space, please try again"
    else
      echo "error: databox ${databox} is existing, please try again"
    fi

    if [ "$bat_flag" = "yes" ];then
      echo "#databox check error -> failed"
      rm -rf $tmp_dir
      exit 1
    fi

    echo -n "Databox Name: "
    read databox
    ascii_chk_result=`ascii_check $databox`
    meta_chk_result=$(echo $databox | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

    ls $ROOT/databox/$databox >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    else
      existing_chk_result=""
    fi

  done
  echo "$databox" > $tmp_dir/databox

  # define primary key 
  echo -n "primary_key(col1): "
  read primary_key
  reserved_chk_result=`echo $primary_key | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data"`
  eval $primary_key=test >/dev/null 2>&1
  load_chk=$?
  meta_chk_result=$(echo $primary_key | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
  -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

  while [ "$reserved_chk_result" -o "$meta_chk_result" -o ! "$load_chk" -eq 0 ]
  do
    if [ "$reserved_chk_result" ];then
      echo "error: you can't use {input temp binary_file params} as key, because these are reserved"
    else
      echo "error: key load is failed, it must be  ascii text and you can't use meta charactor or number space, please try again"
    fi

    if [ "$bat_flag" = "yes" ];then
      echo "#primary_key check error -> failed"
      rm -rf $tmp_dir
      exit 1
    fi

    echo -n "primary_key: "
    read primary_key
    reserved_chk_result=`echo $primary_key | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data"`
    eval $primary_key=test >/dev/null 2>&1
    load_chk=$?
    meta_chk_result=$(echo $primary_key | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \|)
  done

  if [ ! "$primary_key" = "hashid" ];then
    
    echo -n "primary_key label: "
    read primary_key_label
    char_chk_result=`charset_check "$primary_key_label"`

    while [ "$char_chk_result" = "ERROR" ]
    do
      echo "error: key label charset seems wrong, please use UTF-8 as charset"

      if [ "$bat_flag" = "yes" ];then
        echo "#primary_key_label check error -> failed"
        rm -rf $tmp_dir
        exit 1
      fi

      echo -n "primary_key_label: "
      read primary_key_label
      char_chk_result=`charset_check "$primary_key_label"`
    done
  else
    primary_key_label="#ID"
  fi

  # escape meta character
  primary_key_label=`echo "$primary_key_label" | $SED "s/\"//g"`
  
  # dump primary_key
  echo "name=\"$primary_key\"" > $tmp_dir/col1
  echo "label=\"$primary_key_label\"" >> $tmp_dir/col1
  echo "type=\"text\"" >> $tmp_dir/col1
  echo "option=\"required\"" >> $tmp_dir/col1

  if [ ! "$primary_key" = "hashid" ];then
    echo -n "Do you want to add column to dataset? (yes | no): "
    read add_col_answer 
  else
    add_col_answer=yes
  fi

  while [ ! "$add_col_answer" = "yes" -a ! "$add_col_answer" = "no" ]
  do
    echo "please input yes or no" 

    if [ "$bat_flag" = "yes" ];then
      echo "#add col answer check error -> failed"
      rm -rf $tmp_dir
      exit 1
    fi

    echo -n "Do you want to add column to dataset? (yes | no): "

    read add_col_answer 
  done

  count=2

  while [ "$add_col_answer" = "yes" ]
  do
  echo -n "key(col${count}) name: "
  read add_key 
  reserved_chk_result=`echo $add_key | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data"`
  eval $add_key=test >/dev/null 2>&1
  load_chk=$?
  meta_chk_result=$(echo $add_key | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
  -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")


  grep "name=\"$add_key\"" $tmp_dir/col* >/dev/null 2>&1
  if [ $? -eq 0 ];then
    existing_chk_result=existing
  else
    existing_chk_result=""
  fi

    while [ "$existing_chk_result" = "existing" -o "$reserved_chk_result" -o "$meta_chk_result" -o ! "$load_chk" -eq 0 ]
    do

      if [ "$reserved_chk_result" ];then
        echo "error: you can't use {input temp binary_file params} as key, because these are reserved"
      fi

      if [ "$existing_chk_result" = "existing" ];then
        echo "error: key_name is already defined, please try again"
      fi

      if [ ! "$load_chk" -eq  0 ];then
        echo "error: key load is failed, it must be  ascii text and you can't use meta charactor or number space, please try again"
      fi

      if [ "$bat_flag" = "yes" ];then
        echo "# col${count} key check error -> failed"
        rm -rf $tmp_dir
        exit 1
      fi

      echo -n "key(col${count}) name: "
      read add_key
      reserved_chk_result=`echo $add_key | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data"`
      eval $add_key=test >/dev/null 2>&1
      load_chk=$?
      meta_chk_result=$(echo $add_key | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
      -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \|)

      grep "name=\"$add_key\"" $tmp_dir/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        existing_chk_result=existing
      else
        existing_chk_result=""
      fi

    done

    echo -n "key(col${count}) label: "
    read add_key_label
    char_chk_result=`charset_check "$add_key_label"`

    while [ "$char_chk_result" = "ERROR" ]
    do
      echo "error: key label charset seems wrong, please use UTF-8 as charset"

      if [ "$bat_flag" = "yes" ];then
        echo "# col${count} key label check error -> failed"
        rm -rf $tmp_dir
        exit 1
      fi

      echo -n "add_key_label: "
      read add_key_label
      char_chk_result=`charset_check "$add_key_label"`
    done

    # escape meta character
    add_key_label=`echo "$add_key_label" | $SED "s/\"//g"`

    echo -n "Data Type (text | select | radio | checkbox | email | num | tel | date | date-time | url | textarea | file | pdls | mls): "
    read type
    data_chk_result=$(echo $type | grep -e "text" -e "select" -e "radio" -e "checkbox" \
    -e "email" -e "date"  -e "date-time" -e "num" -e "tel"  -e "url" -e "textarea" -e "file" -e "pdls" -e "mls")

    if [ "$type" = "file" ];then
      grep "type=\"file\"" $tmp_dir/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        data_chk_result=""
        data_chk_flg="file"
      fi
    fi

    while [ ! "$data_chk_result" ]
    do
      echo "Data type is wrong, please try again"

      if [ "$data_chk_flg" = "file" ];then
        echo "1 dataset could have only 1 file, please do not add file again"
      fi

      if [ "$bat_flag" = "yes" ];then
        echo "# col${count} data type check error -> failed"
        rm -rf $tmp_dir
        exit 1
      fi

      echo -n "Data Type (text | select | radio | checkbox | email | num | tel | date | date-time | url | textarea | file | pdls | mls): "
      read type
      data_chk_result=$(echo $type | grep -e "text" -e "select" -e "radio" -e "checkbox" \
      -e "email" -e "date"  -e "date-time" -e "num" -e "tel"  -e "url" -e "textarea" -e "file" -e "pdls" -e "mls")

      data_chk_flg=""
      if [ "$type" = "file" ];then
        grep "type=\"file\"" $tmp_dir/col* >/dev/null 2>&1
        if [ $? -eq 0 ];then
          data_chk_result=""
          data_chk_flg="file"
        fi
      fi

    done   

    if [ "$type" = "select" -o "$type" = "radio" -o "$type" = "checkbox" ];then
      echo -n "please define parameters using comma as separator: "
      read params
      char_chk_result=`charset_check "$params"`
      while [ "$char_chk_result" = "ERROR" ]
      do
        echo "It seems invalid charactor is included, please try again. try not to use backspace as much as possible"
        echo -n "parameters: "
        read params
        char_chk_result=`charset_check "$params"`
      done
    fi

    if [ "$type" = "select" -o "$type" = "radio" ];then
      separator_chk=`echo "$params" | grep ,`
      while [ ! "$separator_chk" ]
      do
        echo "There is no separator(comma), please set parameters using comma \",\""
        echo -n "parameters: "
        read params
        separator_chk=`echo "$params" | grep ,`
      done
    fi

    if [ "$type" = "num" ];then
      type=number
    fi

    if [ "$type" = "date-time" ];then
      type="datetime-local"
    fi

    if [ "$type" = "pdls" ];then
      echo -n "please input databox name for making pdls(primary value data list): "
      read pdlsbox
      while [ "$pdlsbox" -a ! -d $ROOT/databox/$pdlsbox ]
      do
        echo -n "databox seems wrong, please try again: "
        read pdlsbox
      done     
    fi

    if [ ! "$type" = "file" -a ! "$type" = "checkbox" -a ! "$type" = "radio" -a ! "$type" = "select" ];then
      echo -n "Require to input each time? (yes | no): "
      read option_answer
      if [ "$option_answer" = "yes" ];then
        option=required
      else
        option=""
      fi

      while [ ! "$option_answer" = "yes" -a ! "$option_answer" = "no" ]
      do
        echo "please input yes or no"
 
        if [ "$bat_flag" = "yes" ];then
          echo "# col${count} required check error -> failed"
          rm -rf $tmp_dir
          exit 1
        fi

        echo -n "Is it required to input each time? (yes | no): "
        read option_answer
        if [ "$option_answer" = "yes" ];then
          option=required
        else
          option=""
        fi
      done
    elif [ "$type" = "radio" -o "$type" = "select" ];then
      option=required
    fi
  
    # dump add_key
    echo "name=\"$add_key\"" > $tmp_dir/col${count}
    echo "label=\"$add_key_label\"" >> $tmp_dir/col${count}
    echo "type=\"$type\"" >> $tmp_dir/col${count}

    if [ "$type" = "select" -o "$type" = "radio" -o "$type" = "checkbox" ];then
      echo "params=\"$params\"" >> $tmp_dir/col${count}
    fi

    if [ "$type" = "pdls" ];then
      echo "pdlsbox=\"$pdlsbox\"" >> $tmp_dir/col${count}
    fi

    echo "option=\"$option\"" >> $tmp_dir/col${count}
    

    echo -n "Do you want to add more column to dataset? (yes | no) : "
    read add_col_answer 
    while [ ! "$add_col_answer" = "yes" -a ! "$add_col_answer" = "no" ]
    do
      echo "please input yes or no" 

      if [ "$bat_flag" = "yes" ];then
        echo "# col${count} additional check error -> failed"
        rm -rf $tmp_dir
        exit 1
      fi

      echo -n "Do you want to add more column to dataset? (yes | no): "
      read add_col_answer 
    done
      
    ((count += 1))  
  done

  clear
  echo "Databox will be generated by following order, please check it" 
  echo "-----------------------------------------------------------------"
  echo ""
  echo "Databox Name:$databox"

  count=1
  for column in `ls $tmp_dir/col* | xargs basename -a`
  do
    if [ "$column" = "col1" ];then
      echo "#primary_key"
    else
      echo "#column${count}"
    fi
    cat $tmp_dir/$column 
    echo ""
    ((count += 1))  
  done

  echo "-----------------------------------------------------------------"
  echo ""

  echo -n "Is it OK? (yes | no): "
  read fin_answer
  while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
  do
    echo "please input yes or no"

    if [ "$bat_flag" = "yes" ];then
      echo "# final check error -> failed"
      rm -rf $tmp_dir
      exit 1
    fi

    echo -n "Is it OK to generate Databox? (yes | no): "
    read fin_answer
  done

  if [ "$fin_answer" = "yes" ];then
    # cp, chmod, touch
    mkdir $ROOT/databox/$databox
    mkdir $ROOT/databox/$databox/log
    mkdir $ROOT/databox/$databox/data
    touch $ROOT/databox/$databox/index
    touch $ROOT/databox/$databox/hashchain
    mkdir $ROOT/databox/$databox/file
    touch $ROOT/databox/$databox/log.dump
    chown -R small-shell:small-shell $ROOT/databox/$databox
    chmod 700 $ROOT/databox/$databox/data
    chmod 700 $ROOT/databox/$databox/file
    chmod 700 $ROOT/databox/$databox/log
    chmod 700 $ROOT/databox/$databox/index
    chmod 700 $ROOT/databox/$databox/hashchain
    chmod 700 $ROOT/databox/$databox/log.dump
   
    mkdir $ROOT/databox/${databox}/def
    cp $tmp_dir/* $ROOT/databox/${databox}/def/
    rm -f $ROOT/databox/${databox}/def/databox
    chmod 755 $ROOT/databox/${databox}/def/*
    chown -R small-shell:small-shell $ROOT/databox/${databox}/def

    echo "databox:$databox created"
    echo "databox definition is here :$ROOT/databox/${databox}/def"
  else
    echo "Plese try again from beginning, #gen -databox"
    rm -rf $tmp_dir
    exit 1
  fi
fi

# ADD COLUMN TO DATABOX
if [ "$param" = "-addcol" ];then

  # start dialog
  echo -n "Databox Name: "
  read databox

  ls $ROOT/databox/$databox >/dev/null 2>&1
  if [ $? -eq 0 ];then
    existing_chk_result=existing
  else
    existing_chk_result=""
  fi

  while [ "$existing_chk_result" = "" -o ! "$databox" ]
  do

    if [ ! "$existing_chk_result" = "existing" ];then
      echo "error: databox ${databox} is not existing, please try again"
    fi
    echo -n "Databox Name: "
    read databox

    ls $ROOT/databox/$databox >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    else
      existing_chk_result=""
    fi

  done
  echo "$databox" > $tmp_dir/databox
  add_col_answer=yes
  
  count=`ls $ROOT/databox/${databox}/def/col* | wc -l | tr -d " "`
  ((count += 1))

  while [ "$add_col_answer" = "yes" ]
  do
    echo -n "key(col${count}) name: "
    read add_key
    reserved_chk_result=`echo $add_key | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data"`

    existing_chk_result=""
    grep "name=\"$add_key\"" $tmp_dir/col* >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    fi

    grep "name=\"$add_key\"" $ROOT/databox/${databox}/def/col* >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    fi

    eval $add_key=test
    load_chk=$?
    meta_chk_result=$(echo $add_key | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

    while [ "$existing_chk_result" = "existing" -o "$reserved_chk_result" -o "$meta_chk_result" -o ! "$load_chk" -eq 0 ]
    do

      if [ "$reserved_chk_result" ];then
        echo "error: you can't use {input temp binary_file params} as key, because these are reserved"
      fi

      if [ "$existing_chk_result" = "existing" ];then
        echo "error: key_name is already defined, please try again"
      fi

      if [ ! "$load_chk" -eq  0 ];then
        echo "error: key load is failed, it must be  ascii text and you can't use meta charactor or number space, please try again"
      fi

      if [ "$meta_chk_result"  ];then
        echo "error: key must be  ascii text and you can't use meta charactor or number space, please try again"
      fi

      echo -n "key(col${count}) name: "
      read add_key
      reserved_chk_result=`echo $add_key | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data"`

      existing_chk_result=""
      grep "name=\"$add_key\"" $tmp_dir/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        existing_chk_result=existing
      fi

      grep "name=\"$add_key\"" $ROOT/databox/${databox}/def/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        existing_chk_result=existing
      fi
      
      eval $add_key=test >/dev/null 2>&1
      load_chk=$?
      meta_chk_result=$(echo $add_key | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
      -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

    done

    echo -n "key (col${count}) label: "
    read add_key_label
    char_chk_result=`charset_check "$add_key_label"`

    while [ "$char_chk_result" = "ERROR" ]
    do
      echo "error: key label charset seems wrong, please use UTF-8 as charset"
      echo -n "add_key_label: "
      read add_key_label
      char_chk_result=`charset_check "$add_key_label"`
    done

    # escape meta character
    add_key_label=`echo "$add_key_label" | $SED "s/\"//g"`

    echo -n "Data Type (text | select | radio | checkbox | email | num | tel | date | date-time | url | textarea | file | pdls | mls): "
    read type
    data_chk_result=$(echo $type | grep -e "text" -e "select" -e "radio" -e "checkbox" \
     -e "email" -e "date"  -e "date-time" -e "num" -e "tel"  -e "url" -e "textarea" -e "file" -e "pdls" -e "mls")

    if [ "$type" = "file" ];then
      grep "type=\"file\"" $ROOT/databox/${databox}/def/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        data_chk_result=""
        data_chk_flg="file"
      fi
      grep "type=\"file\"" $tmp_dir/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        data_chk_result=""
        data_chk_flg="file"
      fi
    fi

    while [ ! "$data_chk_result" ]
    do
      echo "data type must be wrong, please try again"
      if [ "$data_chk_flg" = "file" ];then
        echo "1 dataset could have only 1 file, please do not add file again"
      fi

      echo -n "Data Type (text | select | radio | checkbox | email | num | tel | date | date-time | url | textarea | file | pdls | mls): "
      read type
      data_chk_result=$(echo $type | grep -e "text" -e "select" -e "radio" -e "checkbox" \
       -e "email" -e "date"  -e "date-time" -e "num" -e "tel"  -e "url" -e "textarea" -e "file" -e "pdls" -e "mls")

      data_chk_flg=""
      if [ "$type" = "file" ];then
        grep "type=\"file\"" $ROOT/databox/${databox}/def/col* >/dev/null 2>&1
        if [ $? -eq 0 ];then
          data_chk_result=""
          data_chk_flg="file"
        fi
        grep "type=\"file\"" $tmp_dir/col* >/dev/null 2>&1
        if [ $? -eq 0 ];then
          data_chk_result=""
          data_chk_flg="file"
        fi
      fi

    done
    
    if [ "$type" = "select" -o "$type" = "radio" -o "$type" = "checkbox" ];then
      echo -n "please define parameters using comma as separator: "
      read params
      char_chk_result=`charset_check "$params"`
      while [ "$char_chk_result" = "ERROR" ]
      do
        echo "It seems invalid charactor is included, please try again. try not to use backspace as much as possible"
        echo -n "parameters: "
        read params
        char_chk_result=`charset_check "$params"`
      done
    fi

    if [ "$type" = "select" -o "$type" = "radio" ];then
      separator_chk=`echo "$params" | grep ,`
      while [ ! "$separator_chk" ]
      do
        echo "There is no separator(comma), please set parameters using comma \",\""
        echo -n "parameters: "
        read params
        separator_chk=`echo "$params" | grep ,`
      done
    fi

    if [ "$type" = "num" ];then
      type=number
    fi

    if [ "$type" = "date-time" ];then
      type="datetime-local"
    fi

    if [ "$type" = "pdls" ];then
      echo -n "please input databox name for making pdls(primary value data list): "
      read pdlsbox
      while [ "$pdlsbox" -a ! -d $ROOT/databox/$pdlsbox ]
      do
        echo -n "databox seems wrong, please try again: "
        read pdlsbox
      done     
    fi

    if [ ! "$type" = "file" -a ! "$type" = "checkbox" -a ! "$type" = "radio" -a ! "$type" = "select" ];then
      echo -n "Require to input each time? (yes | no): "
      read option_answer
      if [ "$option_answer" = "yes" ];then
        option=required
      else
        option=""
      fi

      while [ ! "$option_answer" = "yes" -a ! "$option_answer" = "no" ]
      do
        echo "please input yes or no"
        echo -n "Is it required to input each time? (yes | no): "
        read option_answer
        if [ "$option_answer" = "yes" ];then
          option=required
        else
          option=""
        fi
      done
    elif [ "$type" = "radio" -o "$type" = "select" ];then
      option=required
    fi

    # dump add_key
    echo "name=\"$add_key\"" > $tmp_dir/col${count}
    echo "label=\"$add_key_label\"" >> $tmp_dir/col${count}
    echo "type=\"$type\"" >> $tmp_dir/col${count}

    if [ "$type" = "select" -o "$type" = "radio" -o "$type" = "checkbox" ];then
      echo "params=\"$params\"" >> $tmp_dir/col${count}
    fi

    if [ "$type" = "pdls" ];then
      echo "pdlsbox=\"$pdlsbox\"" >> $tmp_dir/col${count}
    fi

    echo "option=\"$option\"" >> $tmp_dir/col${count}

    echo -n "Do you want to add more column to dataset? (yes | no) : "
    read add_col_answer
    while [ ! "$add_col_answer" = "yes" -a ! "$add_col_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Do you want to add more column to dataset? (yes | no): "
      read add_col_answer
    done
    ((count += 1))
  done

  clear
  echo "Column will be added to the dataset, please check it"
  echo "-----------------------------------------------------------------"
  echo ""
  echo "Databox Name:$databox"

  count=`ls $ROOT/databox/${databox}/def/col* | wc -l | tr -d " "`
  ((count += 1))
  
  for column in `ls $tmp_dir/col* | xargs basename -a`
  do
    echo "#column${count}"
    cat $tmp_dir/$column
    echo ""
    ((count += 1))
  done

  echo "-----------------------------------------------------------------"
  echo ""

  echo -n "Is it OK? (yes | no): "
  read fin_answer
  while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
  do
    echo "please input yes or no"
    echo -n "Is it OK to add column to the Databox? (yes | no): "
    read fin_answer
  done

  if [ "$fin_answer" = "yes" ];then
    cp $tmp_dir/* $ROOT/databox/${databox}/def/
    rm -f $ROOT/databox/${databox}/def/databox
    chmod 755 $ROOT/databox/${databox}/def/*
    chown -R small-shell:small-shell $ROOT/databox/${databox}/def
    
    echo "databox definition is here :$ROOT/databox/${databox}/def"

    # rebuild index
    keys=`grep "name=" $tmp_dir/col* | sort -V | xargs basename -a | $AWK -F "=" '{print $2}' | $SED "s/\"//g" | $SED -z "s/\n/,/g" | $SED "s/,$//g"`
    $ROOT/adm/rebuild $databox $keys addcol
  else
    echo "Plese try again from beginning, #gen -addcol"
    rm -rf $tmp_dir
    exit 1
  fi
fi

# DEL COLUMN FROM DATABOX
if [ "$param" = "-delcol" ];then

  # start dialog
  echo -n "Databox Name: "
  read databox

  ls $ROOT/databox/$databox >/dev/null 2>&1
  if [ $? -eq 0 ];then
    existing_chk_result=existing
  else
    existing_chk_result=""
  fi

  while [ "$existing_chk_result" = "" -o ! "$databox" ]
  do

    if [ ! "$existing_chk_result" = "existing" ];then
      echo "error: databox ${databox} is not existing, please try again"
    fi
    echo -n "Databox Name: "
    read databox

    ls $ROOT/databox/$databox >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    else
      existing_chk_result=""
    fi

  done
  del_col_answer=yes

  count=`ls $ROOT/databox/${databox}/def/col* | wc -l | tr -d " "`
  ((count += 1))

  while [ "$del_col_answer" = "yes" ]
  do
    echo -n "column's key name: "
    read del_key

    grep "name=\"$del_key\"" $ROOT/databox/${databox}/def/col* >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result1=existing
    else
      existing_chk_result1=""
    fi

    ls  $tmp_dir/$del_key >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result2=existing
    else
      existing_chk_result2=""
    fi

    grep "name=\"$del_key\"" $ROOT/databox/${databox}/def/col1 >/dev/null 2>&1
    if [ $? -eq 0 ];then
      primary_key_chk_result=yes
    else
      primary_key_chk_result=no
    fi

    while [ "$existing_chk_result1" = "" -o "$existing_chk_result2" = "existing" -o "$primary_key_chk_result" = "yes" ]
    do
 
      if [ "$existing_chk_result1" = "" ];then
        echo "error: key_name is not existing, please try again"
      fi

      if [ "$existing_chk_result2" = "existing" ];then
        echo "error: you can not delete same key"
      fi

      if [ "$primary_key_chk_result" = "yes" ];then
        echo "error: primary_key(col1) can not be deleted"
      fi

      echo -n "Column's Key Name: "
      read del_key
      
      grep "name=\"$del_key\"" $ROOT/databox/${databox}/def/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        existing_chk_result1=existing
      else
        existing_chk_result1=""
      fi

      ls  $tmp_dir/$del_key >/dev/null 2>&1
      if [ $? -eq 0 ];then
        existing_chk_result2=existing
      else
        existing_chk_result2=""
      fi

      grep "name=\"$del_key\"" $ROOT/databox/${databox}/def/col1 >/dev/null 2>&1
      if [ $? -eq 0 ];then
        primary_key_chk_result=yes
      else
        primary_key_chk_result=no
      fi

    done


    # dump del_key
    touch $tmp_dir/$del_key
 
    echo -n "Do you want to delete more column from dataset? (yes | no) : "
    read del_col_answer
    while [ ! "$del_col_answer" = "yes" -a ! "$del_col_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Do you want to delete more column from dataset? (yes | no): "
      read del_col_answer
    done

    ((count += 1))
  done

  clear
  echo "Column will be deleted, please check it"
  echo "-----------------------------------------------------------------"
  echo ""
  echo "Databox Name:$databox"

  for key in `ls $tmp_dir/* | xargs basename -a`
  do
    echo "key of delete target column:$key"
  done

  echo ""
  echo "-----------------------------------------------------------------"
  echo ""

  echo -n "Is it OK? (yes | no): "
  read fin_answer
  while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
  do
    echo "please input yes or no"
    echo -n "Is it OK to generate Databox? (yes | no): "
    read fin_answer
  done

  if [ "$fin_answer" = "yes" ];then
  
    for target_key in `ls $tmp_dir | xargs basename -a`
    do
      col_name=`grep -l "name=\"$target_key\"" $ROOT/databox/${databox}/def/col* | xargs basename -a`

      if [ ! -f $ROOT/databox/${databox}/def/_${col_name} ];then
        mv $ROOT/databox/${databox}/def/$col_name $ROOT/databox/${databox}/def/_${col_name}
      else
        duplicated=$ROOT/databox/${databox}/def/_${col_name}.duplicated.$RANDOM
        if [ ! -f "$duplicated" ];then
          mv $ROOT/databox/${databox}/def/$col_name $ROOT/databox/${databox}/def/_${col_name}.duplicated.$RANDOM
        else
          echo "error: failed to mv def file of $key"
          rm -rf $tmp_dir
          exit 1
        fi
      fi
      
      count=1
      for column in `ls $ROOT/databox/${databox}/def/col* | sort -V | xargs basename -a`
      do
        if [ ! "$column" = "col${count}" ];then
          mv $ROOT/databox/${databox}/def/$column  $ROOT/databox/${databox}/def/col${count}
        fi
       ((count += 1))
      done
      
    done
    
    chmod 755 $ROOT/databox/${databox}/def/*
    chown -R small-shell:small-shell $ROOT/databox/${databox}/def
    echo "databox definition is here :$ROOT/databox/${databox}/def"

    # rebuild index
    keys=`ls $tmp_dir | sort -V | xargs basename -a | $SED "s/ /,/g" | $SED -z "s/\n/,/g" | $SED "s/,$//g"`
    $ROOT/adm/rebuild $databox $keys delcol
  else
    echo "Plese try again from beginning, #gen -delcol"
    rm -rf $tmp_dir
    exit 1
  fi
fi

# GENERATE APP
if [ "$param" = "-app" ];then

  # env check
  selinux_chk=`sestatus 2>/dev/null | grep enforcing` 
  if [ "$selinux_chk" ];then
    echo "warn: SE Linux is enforcing, you can't use APP shell"
    echo "please change SE linux from enforcing to permissive or disabled"
    rm -rf $tmp_dir
    exit 1
  fi

  # start dialog
  echo -n "Type of APP (1.BASE | 2.FORM | 3.SCRATCH): "
  read apptype 
  while [ ! "$apptype" = "1"  -a  ! "$apptype" = "2" -a ! "$apptype" = "3" ]
  do
    echo -n "please input number (1.BASE | 2.FORM | 3.SCRATCH) : "
    read apptype
  done

  if [ "$apptype" = "1" ];then
    apptype="1.BASE"

    echo -n "Type of server (1.small-shell WEB srv | 2.other WEB srv): "
    read srvtype
    while [ ! "$srvtype" = "1"  -a  ! "$srvtype" = "2" ]
    do
      echo -n "pleasee input number (1.small-shell WEB srv | 2.other WEB srv): "
      read srvtype
    done

    if [ "$srvtype" = 1 ];then
      srvtype=default
      www=/var/www
      cgidir=/var/www/cgi-bin
      cgiusr=small-shell
      which node > /dev/null 2>&1
      if [ ! $? -eq 0 ];then
        echo "error: please install node.js beforehand to use small-shell default server"
        rm -rf $tmp_dir
        exit 1
      fi
    else
      srvtype=other
    fi


    if [ "$srvtype" = "other" ];then
      if [ ! "$mac_chk" ];then
        echo -n "Root directory of web (/var/www): "
      else
        echo -n "Root directory of web (/Library/WebServer): "
      fi
      read www
      www=`echo $www | $SED "s/\/$//g"`

      if [ ! "$www" ];then
        if [ ! "$mac_chk" ];then
          www=/var/www
        else
          www=/Library/WebServer
        fi
      fi
      www=`echo $www | $SED "s/\/$//g"`

      while [ ! -d $www ]
      do
        echo "error: $www is not existing, please set root directory for web APP"
        echo -n "www directory: "
        read www
        if [ ! "$www" ];then
          www=/var/www
        fi
        www=`echo $www | $SED "s/\/$//g"`
      done

      www=`echo $www | $SED "s/\/$//g"`

      if [ -f /etc/redhat-release ];then
        cgi_candidate=/var/www/cgi-bin
      else
        if [ ! "$mac_chk" ];then
          cgi_candidate=/usr/lib/cgi-bin
        else
          cgi_candidate=/Library/WebServer/CGI-Executables
        fi
      fi

      echo -n "CGI directory ($cgi_candidate): "
      read cgidir
      cgidir=`echo $cgidir | $SED "s/\/$//g"`

      if [ ! "$cgidir" ];then
        cgidir=$cgi_candidate
      fi
      cgidir=`echo $cgidir | $SED "s/\/$//g"`

      while [ "$cgidir" = "$www" -o ! -d $cgidir ]
      do
        if [ ! -d $cgidir ];then
          echo "error: $cgidir is not existing, please create CGI directory and then try again"
        elif [ "$cgidir" = "$www" ];then
          echo "error: CGI dir:$cgidir must be different directory of WWW dir:$www"
        fi
        echo -n "CGI directory: "
        read cgidir
        if [ ! "$cgidir" ];then
          cgidir=/usr/lib/cgi-bin
        fi
        cgidir=`echo $cgidir | $SED "s/\/$//g"`
      done

      echo -n "APP exec user (e.g. www-data or _www or apache): "
      read cgiusr

      while [ ! "$cgiusr" ]
      do
        echo -n "please set APP exec user: "
        read cgiusr
      done

      usr_chk_result=$(grep $cgiusr /etc/passwd)
      sudo_chk_result=$(grep $cgiusr /etc/sudoers | grep small-shell | grep NOPASSWD)

      while [ ! "$usr_chk_result" -o ! "$sudo_chk_result" ]
      do
        echo "error: APP exec user seems wrong, please define cgi user which used by web server and please add sudoer setting"
        echo -n "APP exec user: "
        read cgiusr
        usr_chk_result=$(grep $cgiusr /etc/passwd)
        sudo_chk_result=$(grep $cgiusr /etc/sudoers | grep small-shell | grep NOPASSWD)
      done
    fi

    echo -n "Protocol (http | https): "
    read protocol

    while [ ! "$protocol" = "http" -a ! "$protocol" = "https" ]
    do
      echo "error: please set http or https as protocol"
      echo -n "Protocol (http | https): "
      read protocol
    done

    if [ "$protocol" = "https" -a "$srvtype" = "default" ];then

      if [ -f $www/app/cert.pem -a -f $www/app/privatekey.pem ];then
        echo -n "Do you want to use existing cert and key? (yes | no): "
        read use_existing_cert 
        while [ ! "$use_existing_cert" = "yes" -a ! "$use_existing_cert" = "no" ]
        do
          echo "please input yes or no"
          echo -n "Do you want to use existing cert and key? (yes | no): "
          read use_existing_cert
        done
      fi
      
      if [ "$use_existing_cert" = "yes" ];then
        echo "Base APP will be upgraded and restarted using exising cert & key, please be aware."
        server=`cat $ROOT/web/base | grep server= | $SED "s/server=//g" | $SED "s/\"//g"`  
        sleep 2
      fi

      if [ "$use_existing_cert" = "no" -o ! "$use_existing_cert" ];then
        if [ "$use_existing_cert" = "no" ];then
          echo "ok, let's update cert and key. Base APP will be upgraded and restarted, please be aware."
        fi
        echo -n "ssl cert path : "
        read ssl_cert

        while [ ! -f $ssl_cert ]
        do
          echo -n "$cert is not existing, please try to input cert path again : "
          read ssl_cert
        done

        echo -n "ssl privare key path : "
        read private_key

        while [ ! -f $private_key ]
        do
          echo -n "$private_key is not existing, please try to input cert path again : "
          read private_key
        done

        echo -n "Do you need to use chain certificate? (yes | no): "
        read chain_answer
        while [ ! "$chain_answer" = "yes" -a ! "$chain_answer" = "no" ]
        do
          echo "please input yes or no"
          echo -n "Do you need chain certificate? (yes | no): "
          read chain_answer
        done

        if [ "$chain_answer" = "yes" ];then
          echo -n "chain cert path : "
          read chain_cert

          while [ ! -f $chain_cert ]
          do
            echo -n "$chain_cert is not existing, please try to input cert path again : "
            read chain_cert
          done
        fi

      fi

    fi

    # command check for cgi
    sudo -u small-shell echo $HOME >/dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please add small-shell as linux user"
      rm -rf $tmp_dir
      exit 1
    fi

    if [ "$protocol" = "http" -o "$use_existing_cert" = "no" -o ! "$server" ];then
      echo -n "WEB Server FQDN or IP addr (e.g. 192.168.10.1): "
      read server

      ascii_chk_result=`ascii_check $server`
      meta_chk_result=$(echo $server | grep -e " " -e ","  -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\"  -e "/" \
      -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

      while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" -o ! "$server" ]
      do
        if [ ! "$server" ];then
          echo "error: please input FQDN or IP addr of web server"
        else
          echo "error: server must be ascii text and you can't use meta charactor including space, please try again"
        fi
        echo -n "WEB server: "
        read server
        ascii_chk_result=`ascii_check $server`
        meta_chk_result=$(echo $server | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\"  -e "/" \
        -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")
      done

      if [[ $server == *:* ]];then
        server="[${server}]"
      fi
  
    fi

    base_url="${protocol}://${server}/cgi-bin/"
    index_url="${protocol}://${server}/"

    if [ "$srvtype" = "other" ];then
      echo -n "BASE URL for WEB APP is ${base_url}, is it OK? (yes | no): "
      read base_url_answer

      while [ ! "$base_url_answer" = "yes" -a ! "$base_url_answer" = "no" ]
      do
        echo "please input yes or no"
        echo -n "Is it OK to use $base_url as BASE URL for WEB APP? (yes | no): "
        read base_url_answer
      done

      if [ "$base_url_answer" = "no" ];then

        echo -n "please input base url that defined at web server : "
        read base_url
        ascii_chk_result=`ascii_check $base_url`
        meta_chk_result=$(echo $base_url | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" \
        -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

        slash_chk=`echo $base_url | grep \/$`
        if [ ! "$slash_chk" ];then
          base_url=`echo $base_url | $SED "s/$/\//g"`
        fi

        while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" -o ! "$base_url" ]
        do
          if [ ! "$base_url" ];then
            echo "error: please input base url"
          else
            echo "error: base url must be ascii text and you can't use meta charactor including space, please try again"
          fi
          echo -n "base url: "
          read base_url
          ascii_chk_result=`ascii_check $base_url`
          meta_chk_result=$(echo $server | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" \
          -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \|)
        done
 
      fi
    fi

    clear

    echo "-----------------------------------------------------------------"
    echo "APP Type: $apptype"
    echo "Srv Type: $srvtype"
    echo "Protocol: $protocol"
    echo "APP Exec User: $cgiusr"
    echo "Root Directory: $www"
    echo "CGI Directory: $cgidir"
    echo "Server: $server"
    if [ "$srvtype" = "default" ];then
      echo "Access URL: ${index_url}base"
    else
      echo "Access URL: ${base_url}auth.base"
    fi
    echo "-----------------------------------------------------------------"

    echo -n "Is it OK? (yes | no): "
    read fin_answer
    while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Is it OK to generate APP? (yes | no): "
      read fin_answer
    done

    if [ "$fin_answer" = "yes" ];then
       
      if [ -f $ROOT/web/base ];then
        upgrade=yes
        api_authkey=`cat $ROOT/web/base | grep api_authkey | $SED "s/api_authkey=//g" | $SED "s/\"//g"` 
      fi

      # gen base info
      echo "protocol=\"$protocol\"" > $ROOT/web/base
      echo "server=\"$server\"" >> $ROOT/web/base
      echo "srvtype=\"$srvtype\"" >> $ROOT/web/base
      echo "cgiusr=\"$cgiusr\"" >> $ROOT/web/base
      echo "www=\"$www\"" >> $ROOT/web/base
      echo "cgidir=\"$cgidir\"" >> $ROOT/web/base
      echo "base_url=\"$base_url\"" >> $ROOT/web/base
      if [ "$srvtype" = "default" ];then
        echo "index_url=\"$index_url\"" >> $ROOT/web/base
      fi
      chown small-shell:small-shell $ROOT/web/base
      chmod 700 $ROOT/web/base

      # deploy cgi to cgi-dir changing path etc
      bindir="${www}/bin"
      descrdir="${www}/descriptor"
      cgitmp="${www}/tmp"

      
      if [ "$srvtype" = "default" ];then

        if [ ! -d $cgidir ];then
          mkdir -p $cgidir
          mkdir ${www}/log
          mkdir ${www}/app
          if [ ! -d ${www}/html ];then
            mkdir ${www}/html
          fi
          chown $cgiusr:$cgiusr ${www}/cgi-bin
          chown $cgiusr:$cgiusr ${www}/log
          chown $cgiusr:$cgiusr ${www}/app
          chown $cgiusr:$cgiusr ${www}/html
        fi

        if [ "$protocol" = "https" ];then
          if [ "$use_existing_cert" = "no" -o ! "$use_existing_cert" ];then
            cp $ssl_cert ${www}/app/cert.pem
            cp $private_key ${www}/app/privatekey.pem
            chown small-shell:small-shell ${www}/app/privatekey.pem
            chown small-shell:small-shell ${www}/app/cert.pem
            chmod 600 ${www}/app/privatekey.pem
            if [ "$chain_cert" ];then
              cp $chain_cert ${www}/app/chain.pem
              chown small-shell:small-shell ${www}/app/chain.pem
            fi
          fi
        fi

        if [ "$protocol" = "http" ];then
           port=80
        else
           port=443
        fi
        (cd ${www}/app;npm init -y;npm install express) 

        node_version=`node --version | $SED "s/v//g" | $AWK -F "." '{print $1}'`
        # generate index.js for upper version of v16        
        if [ "$node_version" -ge 16 ];then
          if [ "$protocol" = "https" ];then
            if [ ! "$chain_cert" ];then
              cat $ROOT/web/src/app/index.js | $SED "s/%%protocol/$protocol/g" | $SED "s/%%port/$port/g" \
              | $SED "s#%%sed#$SED#g" | $SED "s#// https ##g" | $SED "s#/\* forward option start##g" \
              | $SED "s#option end \*/##g" | $SED "s/%%cluster/cluster.isPrimary/g" > ${www}/app/index.js
            else
              cat $ROOT/web/src/app/index.js | $SED "s/%%protocol/$protocol/g" | $SED "s/%%port/$port/g" \
              | $SED "s#%%sed#$SED#g" | $SED "s#// https ##g" | $SED "s#// https_chain ##g" \
              | $SED "s#/\* forward option start##g" | $SED "s#option end \*/##g"  \
              | $SED "s/%%cluster/cluster.isPrimary/g" > ${www}/app/index.js
            fi
          else
            cat $ROOT/web/src/app/index.js | $SED "s/%%protocol/$protocol/g" | $SED "s/%%port/$port/g" \
            | $SED "s#%%sed#$SED#g" | $SED "s/%%cluster/cluster.isPrimary/g" > ${www}/app/index.js
          fi
        else
        # generate index.js for lower version of v16        
          if [ "$protocol" = "https" ];then
            if [ ! "$chain_cert" ];then
              cat $ROOT/web/src/app/index.js | $SED "s/%%protocol/$protocol/g" | $SED "s/%%port/$port/g" \
              | $SED "s#%%sed#$SED#g" | $SED "s#// https ##g" | $SED "s#/\* forward option start##g" \
              | $SED "s#option end \*/##g" | $SED "s/%%cluster/cluster.isMaster/g" > ${www}/app/index.js
            else
              cat $ROOT/web/src/app/index.js | $SED "s/%%protocol/$protocol/g" | $SED "s/%%port/$port/g" \
              | $SED "s#%%sed#$SED#g" | $SED "s#// https ##g" | $SED "s#// https_chain ##g" \
              | $SED "s#/\* forward option start##g" | $SED "s#option end \*/##g"  \
              | $SED "s/%%cluster/cluster.isMaster/g" > ${www}/app/index.js
            fi
          else
            cat $ROOT/web/src/app/index.js | $SED "s/%%protocol/$protocol/g" | $SED "s/%%port/$port/g" \
            | $SED "s#%%sed#$SED#g" | $SED "s/%%cluster/cluster.isMaster/g" > ${www}/app/index.js
          fi
        fi

        NODE=`which node`
        cat $ROOT/web/src/app/app.sh | $SED "s#%%node#$NODE#g" \
        | $SED "s#%%sed#$SED#g" > ${www}/app/app.sh
        chmod 755 ${www}/app/app.sh

        if [ ! "$mac_chk" ];then

          apache2_chk=`ps -ef | grep apache2 | grep -v grep`
          if [ "$apache2_chk" ];then
            systemctl stop apache2
            systemctl disable apache2
          fi

          if [ ! -f /etc/systemd/system/small-shell.service ];then
            cat $ROOT/web/src/app/small-shell.service | $SED "s#%%www#${www}#g" \
            > /etc/systemd/system/small-shell.service 
            systemctl enable small-shell.service 
            systemctl start small-shell 
            sleep 2
          else
            systemctl restart small-shell
            sleep 2
          fi
        else

          httpd_chk=`launchctl list | grep httpd`
          if [ "$httpd_chk" ];then
            apachectl stop
          fi

          if [ ! -f /Library/LaunchDaemons/org.small-shell.node.plist ];then

            cat $ROOT/web/src/app/org.small-shell.node.plist | $SED "s#%%www#${www}#g" \
            > /Library/LaunchDaemons/org.small-shell.node.plist

            cat $ROOT/web/src/app/org.small-shell.util.plist | $SED "s#%%www#${www}#g" \
            > /Library/LaunchDaemons/org.small-shell.util.plist

            cat $ROOT/web/src/app/util.sh | $SED "s#%%www#${www}#g" \
            > ${www}/app/util.sh
            chmod 755 ${www}/app/util.sh
 
            launchctl load /Library/LaunchDaemons/org.small-shell.node.plist
            launchctl load /Library/LaunchDaemons/org.small-shell.util.plist
            launchctl start org.small-shell.node
            launchctl start org.small-shell.util

          else
            launchctl stop org.small-shell.node
            launchctl start org.small-shell.node
          fi
        fi
      fi
  
      if [ ! -d $bindir ];then
        mkdir $bindir
      fi

      chown $cgiusr:$cgiusr $bindir
      if [ ! $? -eq 0 ];then
        echo "error: failed to create directory for small-shell APP bin"
      fi
  
      if [ ! -d $descrdir ];then
        mkdir $descrdir
        mkdir $descrdir/common_parts
        if [ ! $? -eq 0 ];then
          echo "error: failed to create directory for small-shell APP html descriptor"
        fi
      fi
      chown $cgiusr:$cgiusr $descrdir
      chown $cgiusr:$cgiusr $descrdir/common_parts

      if [ ! $? -eq 0 ];then
        echo "error: failed to create directory for small-shell APP html descriptor"
      fi

      if [ ! -d $cgitmp ];then
        mkdir $cgitmp
      fi
      chown $cgiusr:$cgiusr $cgitmp
      if [ ! $? -eq 0 ];then
        echo "error: failed to create directory for small-shell APP tmpfile"
      fi

      # gen command API key and URL  
      echo "commandapi=\"${base_url}api\"" >> $ROOT/web/base
      echo "hubapi=\"${base_url}e-cron\""  >> $ROOT/web/base

      user_name=api
      user_id=`echo "$user_name" | $SHASUM | $AWK '{print $1}'`

      if [ -d $ROOT/users/$user_id ];then
        echo "api_authkey=\"$api_authkey\"" >> $ROOT/web/base
      else
        mkdir $ROOT/users/$user_id
        echo "$user_name" > $ROOT/users/$user_id/user_name
        echo "permission=ro" > $ROOT/users/$user_id/.attr.tmp
        cat $ROOT/users/$user_id/.attr.tmp > $ROOT/users/$user_id/attr
        chown small-shell:small-shell $ROOT/users/$user_id/attr

        which openssl  >/dev/null 2>&1
        if [ $? -eq 0 ];then
          hash_gen_key=`openssl rand -hex 20`
        else
          hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
        fi
        hash=`echo "${user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}'`
        echo "$hash" > $ROOT/users/${user_id}/hash
        chown -R small-shell:small-shell $ROOT/users/$user_id
        chmod 700 $ROOT/users/${user_id}/hash
        user_key=`echo "${user_name}:${hash_gen_key}" | $BASE64_ENC`
        echo "api_authkey=\"$user_key\"" >> $ROOT/web/base
      fi

      for src in `ls $ROOT/web/src/cgi-bin | grep -v controller | grep -v tmplt | grep -v auth | xargs basename -a`
      do
        cat $ROOT/web/src/cgi-bin/$src | $SED "s#\%%www#${www}#g" > $cgidir/$src
        chmod 755 $cgidir/$src
      done
      cat $ROOT/web/src/cgi-bin/controller | $SED "s#\%%www#${www}#g" > $cgidir/base
      cat $ROOT/web/src/cgi-bin/auth | $SED "s#\%%www#${www}#g" > $cgidir/auth.base
      chmod 755 $cgidir/base
      chmod 755 $cgidir/auth.base

      for src in `ls $ROOT/web/src/bin | grep -v tmplt | xargs basename -a`
      do
        cat $ROOT/web/src/bin/$src | $SED "s#\%%www#${www}#g" > $bindir/$src
        chmod 755 $bindir/$src
      done

      if [ -f $ROOT/web/.rand ];then
        . $ROOT/web/.rand
      else
        rand=$RANDOM
        echo "rand=$rand" > $ROOT/web/.rand
      fi

      for src in `ls $ROOT/web/src/descriptor | grep -v tmplt | grep -v common_parts | grep -v redirect.html.def | xargs basename -a`
      do
        cat $ROOT/web/src/descriptor/$src | $SED "s/%%rand/$rand/g" > $descrdir/$src
        chmod 755 $descrdir/$src
      done

      for src in `ls $ROOT/web/src/descriptor/common_parts | grep -v tmplt | xargs basename -a`
      do
        cat $ROOT/web/src/descriptor/common_parts/$src  > $descrdir/common_parts/$src
        chown $cgiusr:$cgiusr $descrdir/common_parts/$src
        chmod 755 $descrdir/common_parts/$src
      done

      # standadaize owner of Base APP
      chown -R ${cgiusr}:${cgiusr} ${cgidir}/*
      chown -R ${cgiusr}:${cgiusr} ${www}/descriptor/*
      chown -R ${cgiusr}:${cgiusr} ${www}/bin/*

      if [ "$srvtype" = "default" ];then
        echo "small_shell_path=$ROOT" > $descrdir/.small_shell_conf
        echo "server=\"default\"" >>  $descrdir/.small_shell_conf
        if [ ! -d $www/html/base ];then
          mkdir $www/html/base
        fi
        cat $ROOT/web/src/descriptor/redirect.html.def | $SED "s#%%APPURL#${base_url}auth.base#g" > $www/html/base/index.html
        chmod 755 $www/html/base/index.html
      else
        echo "small_shell_path=\"sudo -u small-shell $ROOT\"" > $descrdir/.small_shell_conf
      fi

      cat $ROOT/global.conf | grep -v ROOT >> $descrdir/.small_shell_conf
      chmod 755 $descrdir/.small_shell_conf

      if [ ! "$mac_chk" ];then
        # enable standard jobs
        if [ ! -f $ROOT/util/e-cron/def/del_session.def ];then
          sudo -u small-shell echo "SCHEDULE:* * * * *" > $ROOT/util/e-cron/def/del_session.def
          sudo -u small-shell echo "exec_command=\"$ROOT/util/scripts/del_session.sh\"" >> $ROOT/util/e-cron/def/del_session.def
          chown small-shell:small-shell $ROOT/util/e-cron/def/del_session.def
        fi

        if [ ! -f $ROOT/util/e-cron/def/del_util_log.def ];then
          sudo -u small-shell echo "SCHEDULE:5 0 * * *" > $ROOT/util/e-cron/def/del_util_log.def
          sudo -u small-shell echo "exec_command=\"$ROOT/util/scripts/del_log.sh\"" >> $ROOT/util/e-cron/def/del_util_log.def
          chown small-shell:small-shell $ROOT/util/e-cron/def/del_util_log.def
        fi
 
        sudo -u small-shell $ROOT/bin/e-cron enable.del_session
        sudo -u small-shell $ROOT/bin/e-cron enable.del_util_log

        if [ "$srvtype" = "default" ];then
          if [ ! -f $ROOT/util/e-cron/def/rotate_srv_log.def ];then
            sudo -u small-shell echo "SCHEDULE:0 0 * * *" > $ROOT/util/e-cron/def/rotate_srv_log.def
            sudo -u small-shell echo "exec_command=\"$ROOT/util/scripts/rotate_srvlog.sh\"" >> $ROOT/util/e-cron/def/rotate_srv_log.def
            chown small-shell:small-shell $ROOT/util/e-cron/def/rotate_srv_log.def
          fi
          sudo -u small-shell $ROOT/bin/e-cron enable.rotate_srv_log
        fi
      fi

      ls ${cgidir}/../bin/shelltest.sh >/dev/null 2>&1

      if [ ! $? -eq 0 ];then
        (cd $cgidir && cd .. && pwd > $tmp_dir/.tdir) 
        tdir=`cat $tmp_dir/.tdir`
        clear
        echo "www dir must have relation with CGI dir. Is it OK to make symbolic link on $tdir ?"
        echo "following command will be executed"
        echo "-----------------------------------------------------------------"
        echo "ln -s $bindir $tdir/bin"
        echo "ln -s $descrdir $tdir/descriptor"
        echo "ln -s $cgitmp $tdir/tmp"
        echo "-----------------------------------------------------------------"
        echo -n "(yes | no): "
        read syml_answer
        while [ ! "$syml_answer" = "yes" -a ! "$syml_answer" = "no" ]
        do
          echo "please input yes or no"
          echo -n "Is it OK to make symlink? (yes | no): "
          read syml_answer
        done

        if [ "$syml_answer" = "yes" ];then
          ln -s $bindir $tdir/bin
          ln -s $descrdir $tdir/descriptor
          ln -s $cgitmp $tdir/tmp
        fi
     
      fi

      sleep 6
      get_test=`$CURL -k ${base_url}shelltest.cgi | grep OK`

      if [ "$get_test" ];then
        clear
        if [ ! "$upgrade" = "yes" ];then
          echo "-----------------------------------------------------------------"
          echo "Base APP has been successfully generated"
          if [ "$srvtype" = "default" ];then
            echo "Access URL: ${index_url}base"
          else  
            echo "Access URL: ${base_url}auth.base"
          fi  
          echo "-----------------------------------------------------------------"
          echo "Please add user using ops command."
          echo "-> sudo $ROOT/adm/ops add.usr:\$user"
        else
          echo "Base APP has been upgraded. please access to the APP using existing key"
        fi
      else
        if [ "$srvtype" = "default" ];then
          echo "error: it seems something is wrong,tried to get ${base_url}shelltest.cgi and it's failed." 
          rm -rf $tmp_dir
          exit 1
        else
          echo "error: it seems something is wrong,tried to get ${base_url}shelltest.cgi and it's failed." 
          echo "please check web server setting and url setting, you should start web server beforehand"
          rm -rf $tmp_dir
          exit 1
        fi
      fi
    else
      echo "please try again from begining #gen -app"
      rm -rf $tmp_dir
      exit 1
    fi
  fi

  if [ "$apptype" = "2" ];then

    if [ ! -f $ROOT/web/base ];then
      echo "error: please generate BASE APP first"
      rm -rf $tmp_dir
      exit 1
    else
     # load web/base
      . $ROOT/web/base
    fi

    apptype="2.FORM"
    echo -n "Form Name: "
    read form_name

    while [ "$form_name" = "base" -o "$form_name" = "api" -o "$form_name" = "e-cron" -o "$form_name" = "css" ]
    do
      echo "error: the name $form_name is conflicted with Base APP, please try again"
      echo -n "Form Name: "
      read form_name
    done

    ascii_chk_result=`ascii_check $form_name`
    meta_chk_result=$(echo $form_name | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e "@" -e ">" -e "<")


    while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" ]
    do
      echo "error: Form name must be ascii text and you can't use meta charactor including space, please try again"
      echo -n "Form Name: "
      read form_name
      ascii_chk_result=`ascii_check $form_name`
      meta_chk_result=$(echo $form_name | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
      -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")
    done

    echo -n "Target Databox: "
    read databox

    while [ ! "$databox" -o ! -d $ROOT/databox/$databox ]
    do
      echo "error: databox name seems wrong, please try again"
      echo -n "Target Databox: "
      read databox
    done 

    primary_key=`cat $ROOT/databox/$databox/def/col1 | grep name= | $SED "s/name=//g"  | $SED "s/\"//g"`
    if [ ! "$primary_key" = "hashid" ];then
      echo "error: $databox is not suitable, primary key must be \"hashid\" if you want to use the databox for Form"
      echo "please try again from beginning."
      exit 1
    fi

    echo -n "Description of the Form : "
    read description 

    echo -n "Do you want to enable IP whitelisting for this Form? (yes | no): "
    read IP_whitelisting
    while [ ! "$IP_whitelisting" = "yes" -a ! "$IP_whitelisting" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Do you want to enable IP whitelisting? (yes | no): "
      read IP_whitelisting
    done

    clear
    datas=`cat $ROOT/databox/$databox/def/col* | grep name=\" | grep -v $primary_key | $AWK -F "name=" '{print $2}' \
    | $SED "s/\"//g" | $SED -z "s/\n/ | /g" | $SED "s/ | $//g"`
    echo -n "Select key that must be included in the Form ($datas) : "
    read key
    
    key_chk=`grep "name=\"$key\"" $ROOT/databox/$databox/def/col*`

    while [ ! "$key_chk" ]
    do
      echo "error: key name must be wrong"
      echo -n "please try again ($datas): "
      read key
      key_chk=`grep "name=\"$key\"" $ROOT/databox/$databox/def/col*`
    done
    keys=$key
    datas=`echo $datas | $SED "s/| $key //g" | $SED "s/^$key | //g" | $SED "s/| $key$//g" | $SED "s/^$key$//g"`


    if [ "$datas" ];then
      echo -n "Do you want to add more key to the Form? (yes | no): "
      read add_form_answer
      while [ ! "$add_form_answer" = "yes" -a ! "$add_form_answer" = "no" ]
      do
        echo "please input yes or no"
        echo -n "Do you want to add more key to the Form? (yes | no): "
        read add_form_answer
      done
    else
     add_form_answer="no"
    fi

    while [ "$add_form_answer" = "yes" -a "$datas" ]
    do 
      echo -n "Select additional key that must be included in the Form ($datas) : "
      read key
      key_chk=`grep "name=\"$key\"" $ROOT/databox/$databox/def/col*`

      while [ ! "$key_chk" ]
      do
        echo "error: key name must be wrong"
        echo -n "please try again ($datas): "
        read key
        key_chk=`grep "name=\"$key\"" $ROOT/databox/$databox/def/col*`
      done
      keys="$keys,$key"
      datas=`echo $datas | $SED "s/| $key //g" | $SED "s/^$key | //g" | $SED "s/| $key$//g" | $SED "s/^$key$//g"`
  
      if [ "$datas" ];then
        echo -n "Do you want to add more key to the Form? (yes | no): "
        read add_form_answer
        while [ ! "$add_form_answer" = "yes" -a ! "$add_form_answer" = "no" ]
        do
          echo "please input yes or no"
          echo -n "Do you want to add more key to the Form? (yes | no): "
          read add_form_answer
        done
      fi
    done

    # load base info
    . $ROOT/web/base
    clear
    echo "Form will be generated by following order, please check it"
    echo "-----------------------------------------------------------------"
    echo ""
    echo "APP Type: $apptype"
    echo "Form Name: $form_name"
    echo "Target Databox: $databox"
    echo "Description: $description"
    echo "IP_whitelisting: $IP_whitelisting"
    echo "Included keys: $keys"
    if [ "$srvtype" = "default" ];then
      echo "Access URL: ${index_url}${form_name}"
    else
      echo "Access URL: ${base_url}${form_name}"
    fi
    echo ""
    echo "-----------------------------------------------------------------"
    echo ""
    echo -n "Is it OK? (yes | no): "
    read fin_answer
    while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Is it OK to generate APP? (yes | no): "
      read fin_answer
    done

    if [ "$fin_answer" = "yes" ];then

      app=$form_name
      # careate APP user and authkey
      app_user_name=${app}.app
      app_user_id=`echo "$app_user_name" | $SHASUM | $AWK '{print $1}'`

      if [ ! -d $ROOT/users/${app}.${app_user_id} ];then
        mkdir $ROOT/users/${app}.${app_user_id}
      fi
      echo "$app_user_name" > $ROOT/users/${app}.${app_user_id}/user_name
      echo "permission=rw" > $ROOT/users/${app}.${app_user_id}/.attr.tmp
      cat $ROOT/users/${app}.${app_user_id}/.attr.tmp > $ROOT/users/${app}.${app_user_id}/attr
      chown small-shell:small-shell $ROOT/users/${app}.${app_user_id}/attr

      which openssl  >/dev/null 2>&1
      if [ $? -eq 0 ];then
        hash_gen_key=`openssl rand -hex 20`
      else
        hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
      fi

      hash=`echo "${app}:${app_user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}'`
      echo "$hash" > $ROOT/users/${app}.${app_user_id}/hash
      chown -R small-shell:small-shell $ROOT/users/${app}.${app_user_id}
      chmod 700 $ROOT/users/${app}.${app_user_id}/hash
      authkey=`echo "${app_user_name}:${hash_gen_key}" | $BASE64_ENC`

      # deploy form APP
      cat $ROOT/web/src/cgi-bin/tmplt_controller_form | $SED "s#\%%www#${www}#g" | $SED "s/%%authkey/$authkey/g" \
      | $SED "s/%%IP_whitelisting/$IP_whitelisting/g" | $SED "s/%%app/$form_name/g" > $cgidir/$form_name
      cat $ROOT/web/src/cgi-bin/tmplt_css | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$form_name/g" > $cgidir/${form_name}_css

      chown $cgiusr:$cgiusr $cgidir/${form_name}*
      chmod 700 $cgidir/${form_name}*


      cat $ROOT/web/src/bin/tmplt_type2_get.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
      | $SED "s/%%app/$form_name/g"  | $SED "s/%%keys/$keys/g" > ${www}/bin/${form_name}_get.sh

      cat $ROOT/web/src/bin/tmplt_type2_set.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
      | $SED "s/%%app/$form_name/g"  | $SED "s/%%keys/$keys/g" > ${www}/bin/${form_name}_set.sh

      chown $cgiusr:$cgiusr ${www}/bin/${form_name}*
      chmod 755 ${www}/bin/${form_name}*

      cat $ROOT/web/src/descriptor/tmplt_type2_get_new.html.def | $SED "s/%%databox/$databox/g" \
      | $SED "s/%%app/$form_name/g"  | $SED "s/%%description/$description/g" > ${www}/descriptor/${form_name}_get_new.html.def

      cat $ROOT/web/src/descriptor/tmplt_type2_get_new_incf.html.def | $SED "s/%%databox/$databox/g" \
      | $SED "s/%%app/$form_name/g"  | $SED "s/%%description/$description/g" > ${www}/descriptor/${form_name}_get_new_incf.html.def

      cat $ROOT/web/src/descriptor/tmplt_type2_get.html.def | $SED "s/%%databox/$databox/g" \
      | $SED "s/%%app/$form_name/g"  > ${www}/descriptor/${form_name}_get.html.def

      cat $ROOT/web/src/descriptor/tmplt_type2_get_err.html.def | $SED "s/%%databox/$databox/g" \
      | $SED "s/%%app/$form_name/g"  > ${www}/descriptor/${form_name}_get_err.html.def

      cat $ROOT/web/src/descriptor/tmplt_type2_set.html.def | $SED "s/%%databox/$databox/g" \
      | $SED "s/%%app/$form_name/g"  > ${www}/descriptor/${form_name}_set.html.def

      cat $ROOT/web/src/descriptor/tmplt_type2.css.def > ${www}/descriptor/${form_name}.css.def

      chown $cgiusr:$cgiusr ${www}/descriptor/${form_name}*
      chmod 755 ${www}/descriptor/${form_name}*

      if [ "$srvtype" = "default" ];then
        if [ ! -d $www/html/$form_name ];then
          mkdir $www/html/$form_name
        fi
        cat $ROOT/web/src/descriptor/redirect.html.def | $SED "s#%%APPURL#${base_url}${form_name}#g" > $www/html/$form_name/index.html
        chmod 755 $www/html/$form_name/index.html
      fi

      echo "Form is successfully generated"
      ls  $cgidir/${form_name}
      ls  $cgidir/${form_name}_css
      ls  ${www}/bin/${form_name}_*
      ls  ${www}/descriptor/${form_name}_*
    else
      echo "Plese try again from beginning, #gen -app" 
      rm -rf $tmp_dir
      exit 1
    fi

  fi

  if [ "$apptype" = "3" ];then

    if [ ! -f $ROOT/web/base ];then
      echo "error: please generate BASE APP first"
      rm -rf $tmp_dir
      exit 1
    else
      # load web/base
      . $ROOT/web/base
    fi

    # load base info
    . $ROOT/web/base

    apptype="3.SCRATCH"
    echo -n "APP Name: "
    read app

    while [ "$app" = "base" -o "$app" = "api" -o "$app" = "e-cron" -o "$app" = "css" ]
    do
      echo "error: the name $app is conflicted with Base APP, please try again"
      echo -n "APP Name: "
      read app
    done

    parent_app=`echo $app | $AWK -F "@" '{print $2}'`
    if [ "$parent_app" ];then
       app=`echo $app | $AWK -F "@" '{print $1}'`
      if [ ! -f ${cgidir}/${parent_app} ];then
        echo "error: there is no parement APP $parent_app"
        exit 1
      fi
      if [ -f ${cgidir}/${app} ];then
        echo "error: there is same name APP as parent"
        exit 1
      fi
    fi
   
    ascii_chk_result=`ascii_check $app`
    meta_chk_result=$(echo $app | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e "@" -e ">" -e "<")

    while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" ]
    do
      echo "error: APP name must be ascii text and you can't use meta charactor including space, please try again"
      echo -n "APP Name: "
      read app

      parent_app=`echo $app | $AWK -F "@" '{print $2}'`
      if [ "$parent_app" ];then
       app=`echo $app | $AWK -F "@" '{print $1}'`
        if [ ! -f ${cgidir}/${parent_app} ];then
          echo "error: there is no parement APP $parent_app"
          exit 1
        fi
        if [ -f ${cgidir}/${app} ];then
          echo "error: there is same name APP as parent"
          exit 1
        fi
      fi
      ascii_chk_result=`ascii_check $app`
      meta_chk_result=$(echo $app | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
      -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")
    done

    if [ ! "$parent_app" ];then
      echo -n "Type of Authentication (1.shared pass | 2.user key | 3.other | 4.none): "
      read auth_method
      while [ ! "$auth_method" = "1"  -a  ! "$auth_method" = "2" -a ! "$auth_method" = "3" -a ! "$auth_method" = "4" ]
      do
        echo -n "please input number (1.shared pass | 2.user key | 3.other | 4.none) : "
        read auth_method
      done
    fi

    if [ "$auth_method" = 1 ];then
      auth_method=shared_pass
      echo -n "Shared Passcode: "
      read shared_pass
      num_value_chk=`echo $shared_pass | $SED "s/[0-9]//g" | $SED "s/-//g"`
      value_chk=`echo $shared_pass | $SED -z "s/\n//g"`
      while [ "$shared_pass" -a "$num_value_chk" ]
      do
        echo -n "code must be numetric character, please try again: "
        read shared_pass
        num_value_chk=`echo $shared_pass | $SED "s/[0-9]//g" | $SED "s/-//g"`
        value_chk=`echo $shared_pass | $SED -z "s/\n//g"`
      done
    fi

    if [ "$auth_method" = 2 ];then
      auth_method=key
    fi

    if [ "$auth_method" = 3 ];then
      auth_method=other
    fi

    if [ "$auth_method" = 4 ];then
      auth_method=none
    fi

    if [ ! "$parent_app" ];then
      echo -n "Primary Databox: "
    else
      echo -n "Subapp Databox: "
    fi
    read databox

    if [ ! "$databox" = "null" -a ! "$databox" = "none" ];then
      while [[ ! "$databox" || ! -d $ROOT/databox/$databox ]] && [[ ! "$databox" == "null" && ! "$databox" == "none" ]]
      do
        echo "error: databox name seems wrong, please try again"
        echo -n "Target Databox: "
        read databox
      done
    fi

    if [ ! "$parent_app" ];then
      echo -n "Do you want to enable IP whitelisting for this APP? (yes | no): "
      read IP_whitelisting
      while [ ! "$IP_whitelisting" = "yes" -a ! "$IP_whitelisting" = "no" ]
      do
        echo "please input yes or no"
        echo -n "Do you want to enable IP whitelisting? (yes | no): "
        read IP_whitelisting
      done
    fi

    clear
    echo "APP will be generated by following order, please check it"
    echo "-----------------------------------------------------------------"
    echo ""
    echo "APP Type: $apptype"
    echo "APP Name: $app"
   
    if [ ! "$parent_app" ];then

      echo "Authentication: $auth_method"
      echo "IP_whitelisting: $IP_whitelisting"

      if [ "$srvtype" = "default" ];then
        if [ ! "$auth_method" = "other" ];then
          echo "Access URL: ${index_url}${app}"
        else
          # for adaption of Oauth
          echo "Access URL: ${base_url}auth.${app}"
        fi
      else
        if [ "$auth_method" = "key" -o "$auth_method" = "other" ];then
          echo "Access URL: ${base_url}auth.${app}"
        else
          echo "Access URL: ${base_url}${app}"
        fi
      fi

      if [ "$auth_method" = "shared_pass" ];then
          echo "Shared Passcode: $shared_pass"
      fi

      echo "Primary Databox: $databox"

    else

      echo "Parent APP: $parent_app"
      echo "Sub APP Databox: $databox"

    fi

    echo ""
    echo "-----------------------------------------------------------------"
    echo ""
    echo -n "Is it OK? (yes | no): "
    read fin_answer
    while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Is it OK to generate APP? (yes | no): "
      read fin_answer
    done
  
    if [ "$fin_answer" = "yes" ];then

      if [ ! "$parent_app" ];then 

        if [ "$auth_method" = "shared_pass" ];then

          input_type="password"
          placeholder="Passcode"

          # careate app authkey
          app_user_name=${app}.app
          app_user_id=`echo "$app_user_name" | $SHASUM | $AWK '{print $1}'`

          if [ ! -d $ROOT/users/${app}.${app_user_id} ];then
            mkdir $ROOT/users/${app}.${app_user_id}
          fi
          echo "$app_user_name" > $ROOT/users/${app}.${app_user_id}/user_name
          echo "permission=rw" > $ROOT/users/${app}.${app_user_id}/.attr.tmp
          cat $ROOT/users/${app}.${app_user_id}/.attr.tmp > $ROOT/users/${app}.${app_user_id}/attr
          chown small-shell:small-shell $ROOT/users/${app}.${app_user_id}/attr

          which openssl  >/dev/null 2>&1
          if [ $? -eq 0 ];then
            hash_gen_key=`openssl rand -hex 20`
          else
            hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
          fi

          hash=`echo "${app}:${app_user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}'`
          echo "$hash" > $ROOT/users/${app}.${app_user_id}/hash
          chown -R small-shell:small-shell $ROOT/users/${app}.${app_user_id}
          chmod 700 $ROOT/users/${app}.${app_user_id}/hash
          authkey=`echo "${app_user_name}:${hash_gen_key}" | $BASE64_ENC`


          # store passcode of shared pass APP
          echo "$shared_pass" > $ROOT/web/${app}.code

          # deploy psscode APP
          cat $ROOT/web/src/cgi-bin/tmplt_controller | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" \
          | $SED "s/%%auth/required/g" | $SED "s/%%IP_whitelisting/$IP_whitelisting/g" > $cgidir/$app
          chown $cgiusr:$cgiusr $cgidir/$app
          chmod 700 $cgidir/$app

          cat $ROOT/web/src/cgi-bin/tmplt_css | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" > $cgidir/${app}_css
          chown $cgiusr:$cgiusr $cgidir/${app}_css
          chmod 700 $cgidir/${app}_css

          cat $ROOT/web/src/cgi-bin/tmplt_pass_auth | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" \
          | $SED "s/%%authkey/$authkey/g" | $SED "s/%%IP_whitelisting/$IP_whitelisting/g" > $cgidir/auth.${app}
          chown $cgiusr:$cgiusr $cgidir/auth.${app}
          chmod 700 $cgidir/auth.${app}

          cat $ROOT/web/src/bin/tmplt_type3_get.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_get.sh

          cat $ROOT/web/src/bin/tmplt_type3_set.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_set.sh

          cat $ROOT/web/src/bin/tmplt_type3_del.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_del.sh

          cat $ROOT/web/src/bin/tmplt_type3_table.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_table.sh

          cat $ROOT/web/src/bin/tmplt_log_viewer.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_log_viewer.sh

          cat $ROOT/web/src/bin/tmplt_main.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_main.sh

          cat $ROOT/web/src/bin/tmplt_page_links.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_page_links.sh

          cat $ROOT/web/src/bin/tmplt_dl.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_dl.sh

          chown $cgiusr:$cgiusr ${www}/bin/${app}*
          chmod 755 ${www}/bin/${app}*

          for src in `ls $ROOT/web/src/descriptor | grep tmplt | grep -v type2 | grep -v auth | xargs basename -a`
          do
            html_def=`echo $src | $SED "s/tmplt_//g" | $SED "s/type3_//g"`
            if [ ! "$src" = "tmplt_type3.css.def" ];then
              cat $ROOT/web/src/descriptor/$src | $SED "s/%%app/$app/g" | $SED "s/%%user/there/g" \
              | $SED "s/%%databox/$databox/g" > ${www}/descriptor/${app}_${html_def}
              chmod 755 ${www}/descriptor/${app}_${html_def}
            else
              cat $ROOT/web/src/descriptor/$src  > ${www}/descriptor/${app}.css.def
              chmod 755 ${www}/descriptor/${app}.css.def
            fi
          done

          for src in `ls $ROOT/web/src/descriptor/common_parts | grep tmplt | xargs basename -a`
          do
            menu=`echo $src | $SED "s/tmplt_//g" | $SED "s/type3_//g"`
            cat $ROOT/web/src/descriptor/common_parts/$src | $SED "s/%%app/$app/g" | $SED "s/%%databox/$databox/g" \
            > ${www}/descriptor/common_parts/${app}_${menu}
            chmod 755 ${www}/descriptor/common_parts/${app}_${menu}
          done

          chown $cgiusr:$cgiusr ${www}/descriptor/${app}*
          chown $cgiusr:$cgiusr ${www}/descriptor/common_parts/${app}*

          if [ -f $ROOT/web/.rand ];then
            . $ROOT/web/.rand
          else
            rand=$RANDOM
            echo "rand=$rand" > $ROOT/web/.rand
          fi

          cat $ROOT/web/src/descriptor/tmplt_pass_auth_form.html.def | $SED "s/%%input_type/$input_type/g" \
          | $SED "s/%%placeholder/$placeholder/g" | $SED "s/%%app/$app/g" \
          | $SED "s/%%rand/$rand/g" > ${www}/descriptor/${app}_auth_form.html.def
          chmod 755 ${www}/descriptor/${app}_auth_form.html.def
          chown $cgiusr:$cgiusr ${www}/descriptor/${app}*

          if [ "$srvtype" = "default" ];then
             if [ ! -d $www/html/$app ];then
               mkdir $www/html/$app
             fi
             cat $ROOT/web/src/descriptor/redirect.html.def | $SED "s#%%APPURL#${base_url}auth.${app}#g" > $www/html/$app/index.html
             chmod 755 $www/html/$app/index.html
          fi

        fi

        if [ "$auth_method" = "key" ];then

          # deploy key auth APP
          cat $ROOT/web/src/cgi-bin/tmplt_controller | $SED "s#\%%www#${www}#g" \
          | $SED "s/%%app/$app/g" | $SED "s/%%auth/required/g" | $SED "s/%%IP_whitelisting/$IP_whitelisting/g" > $cgidir/$app
          chown $cgiusr:$cgiusr $cgidir/$app
          chmod 700 $cgidir/$app

          cat $ROOT/web/src/cgi-bin/tmplt_css | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" > $cgidir/${app}_css
          chown $cgiusr:$cgiusr $cgidir/${app}_css
          chmod 700 $cgidir/${app}_css

          cat $ROOT/web/src/cgi-bin/tmplt_auth | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" \
          | $SED "s/%%IP_whitelisting/$IP_whitelisting/g" > $cgidir/auth.${app}
          chown $cgiusr:$cgiusr $cgidir/auth.${app}
          chmod 700 $cgidir/auth.${app}

          cat $ROOT/web/src/bin/tmplt_type3_get.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_get.sh

          cat $ROOT/web/src/bin/tmplt_type3_set.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_set.sh

          cat $ROOT/web/src/bin/tmplt_type3_del.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_del.sh

          cat $ROOT/web/src/bin/tmplt_type3_table.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_table.sh

          cat $ROOT/web/src/bin/tmplt_log_viewer.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_log_viewer.sh

          cat $ROOT/web/src/bin/tmplt_main.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_main.sh

          cat $ROOT/web/src/bin/tmplt_page_links.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_page_links.sh

          cat $ROOT/web/src/bin/tmplt_dl.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_dl.sh
          chown $cgiusr:$cgiusr ${www}/bin/${app}*
          chmod 755 ${www}/bin/${app}*

          if [ -f $ROOT/web/.rand ];then
            . $ROOT/web/.rand
          else
            rand=$RANDOM
            echo "rand=$rand" > $ROOT/web/.rand
          fi

          for src in `ls $ROOT/web/src/descriptor | grep tmplt | grep -v type2 | grep -v pass_auth | xargs basename -a`
          do
            html_def=`echo $src | $SED "s/tmplt_//g" | $SED "s/type3_//g"`
            if [ ! "$src" = "tmplt_type3.css.def" ];then
              cat $ROOT/web/src/descriptor/$src | $SED "s/%%app/$app/g" | $SED "s/%%rand/$rand/g" \
              | $SED "s/%%databox/$databox/g" > ${www}/descriptor/${app}_${html_def}
              chmod 755 ${www}/descriptor/${app}_${html_def}
            else
              cat $ROOT/web/src/descriptor/$src | $SED "s/%%app/$app/g"  > ${www}/descriptor/${app}.css.def
              chmod 755 ${www}/descriptor/${app}.css.def
            fi
          done

          for src in `ls $ROOT/web/src/descriptor/common_parts | grep tmplt | xargs basename -a`
          do
            menu=`echo $src | $SED "s/tmplt_//g" | $SED "s/type3_//g"`
            cat $ROOT/web/src/descriptor/common_parts/$src | $SED "s/%%app/$app/g" | $SED "s/%%databox/$databox/g" \
            > ${www}/descriptor/common_parts/${app}_${menu}
            chmod 755 ${www}/descriptor/common_parts/${app}_${menu}
          done

          chown $cgiusr:$cgiusr ${www}/descriptor/${app}*
          chown $cgiusr:$cgiusr ${www}/descriptor/common_parts/${app}*

          if [ "$srvtype" = "default" ];then
             if [ ! -d $www/html/$app ];then
               mkdir $www/html/$app
             fi
             cat $ROOT/web/src/descriptor/redirect.html.def | $SED "s#%%APPURL#${base_url}auth.${app}#g" > $www/html/$app/index.html
             chmod 755 $www/html/$app/index.html
          fi

        fi

        if [ "$auth_method" = "other" ];then

          # careate app authkey
          app_user_name=${app}.app
          app_user_id=`echo "$app_user_name" | $SHASUM | $AWK '{print $1}'`
          input_type="text"

          if [ ! -d $ROOT/users/${app}.${app_user_id} ];then
            mkdir $ROOT/users/${app}.${app_user_id}
          fi
          echo "$app_user_name" > $ROOT/users/${app}.${app_user_id}/user_name
          echo "permission=rw" > $ROOT/users/${app}.${app_user_id}/.attr.tmp
          cat $ROOT/users/${app}.${app_user_id}/.attr.tmp > $ROOT/users/${app}.${app_user_id}/attr
          chown small-shell:small-shell $ROOT/users/${app}.${app_user_id}/attr

          which openssl  >/dev/null 2>&1
          if [ $? -eq 0 ];then
            hash_gen_key=`openssl rand -hex 20`
          else
            hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
          fi

          hash=`echo "${app}:${app_user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}'`
          echo "$hash" > $ROOT/users/${app}.${app_user_id}/hash
          chown -R small-shell:small-shell $ROOT/users/${app}.${app_user_id}
          chmod 700 $ROOT/users/${app}.${app_user_id}/hash
          authkey=`echo "${app_user_name}:${hash_gen_key}" | $BASE64_ENC`

          # deploy other APP
          cat $ROOT/web/src/cgi-bin/tmplt_controller | $SED "s#\%%www#${www}#g" \
          | $SED "s/%%app/$app/g" | $SED "s/%%auth/required/g" | $SED "s/%%IP_whitelisting/$IP_whitelisting/g" > $cgidir/$app
          chown $cgiusr:$cgiusr $cgidir/$app
          chmod 700 $cgidir/$app

          cat $ROOT/web/src/cgi-bin/tmplt_css | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" > $cgidir/${app}_css
          chown $cgiusr:$cgiusr $cgidir/${app}_css
          chmod 700 $cgidir/${app}_css

          cat $ROOT/web/src/cgi-bin/tmplt_other_auth | $SED "s#\%%www#${www}#g" | $SED "s/%%IP_whitelisting/$IP_whitelisting/g" \
          | $SED "s/%%app/$app/g" | $SED "s/%%authkey/$authkey/g" > $cgidir/auth.${app}
          chown $cgiusr:$cgiusr $cgidir/auth.${app}
          chmod 700 $cgidir/auth.${app}

          cat $ROOT/web/src/bin/tmplt_type3_get.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_get.sh

          cat $ROOT/web/src/bin/tmplt_type3_set.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_set.sh

          cat $ROOT/web/src/bin/tmplt_type3_del.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_del.sh

          cat $ROOT/web/src/bin/tmplt_type3_table.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_table.sh

          cat $ROOT/web/src/bin/tmplt_log_viewer.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_log_viewer.sh

          cat $ROOT/web/src/bin/tmplt_main.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_main.sh

          cat $ROOT/web/src/bin/tmplt_page_links.sh | $SED "s#\%%www#${www}#g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_page_links.sh

          cat $ROOT/web/src/bin/tmplt_dl.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_dl.sh

          chown $cgiusr:$cgiusr ${www}/bin/${app}*
          chmod 755 ${www}/bin/${app}*

          for src in `ls $ROOT/web/src/descriptor | grep tmplt | grep -v type2 | grep -v auth | xargs basename -a`
          do
            html_def=`echo $src | $SED "s/tmplt_//g" | $SED "s/type3_//g"`
            if [ ! "$src" = "tmplt_type3.css.def" ];then
              cat $ROOT/web/src/descriptor/$src | $SED "s/%%app/$app/g" | $SED "s/%%user/there/g" \
              | $SED "s/%%databox/$databox/g" > ${www}/descriptor/${app}_${html_def}
              chmod 755 ${www}/descriptor/${app}_${html_def}
            else
              cat $ROOT/web/src/descriptor/$src  > ${www}/descriptor/${app}.css.def
              chmod 755 ${www}/descriptor/${app}.css.def
            fi
          done

          for src in `ls $ROOT/web/src/descriptor/common_parts | grep tmplt | xargs basename -a`
          do
            menu=`echo $src | $SED "s/tmplt_//g" | $SED "s/type3_//g"`
            cat $ROOT/web/src/descriptor/common_parts/$src | $SED "s/%%app/$app/g" | $SED "s/%%databox/$databox/g" \
            > ${www}/descriptor/common_parts/${app}_${menu}
            chmod 755 ${www}/descriptor/common_parts/${app}_${menu}
          done

          chown $cgiusr:$cgiusr ${www}/descriptor/${app}*
          chown $cgiusr:$cgiusr ${www}/descriptor/common_parts/${app}*

          if [ -f $ROOT/web/.rand ];then
            . $ROOT/web/.rand
          else
            rand=$RANDOM
            echo "rand=$rand" > $ROOT/web/.rand
          fi

          cat $ROOT/web/src/descriptor/tmplt_other_auth_form.html.def | $SED "s/%%input_type/$input_type/g" | $SED "s/%%app/$app/g" \
          | $SED "s/%%rand/$rand/g" > ${www}/descriptor/${app}_auth_form.html.def
          chmod 755 ${www}/descriptor/${app}_auth_form.html.def
          chown $cgiusr:$cgiusr ${www}/descriptor/${app}*

        fi

        if [ "$auth_method" = "none" ];then

          # careate app authkey
          app_user_name=${app}.app
          app_user_id=`echo "$app_user_name" | $SHASUM | $AWK '{print $1}'`

          input_type="text"
          placeholder="please input your name"

          if [ ! -d $ROOT/users/${app}.${app_user_id} ];then
            mkdir $ROOT/users/${app}.${app_user_id}
          fi
          echo "$app_user_name" > $ROOT/users/${app}.${app_user_id}/user_name
          echo "permission=ro" > $ROOT/users/${app}.${app_user_id}/.attr.tmp
          cat $ROOT/users/${app}.${app_user_id}/.attr.tmp > $ROOT/users/${app}.${app_user_id}/attr
          chown small-shell:small-shell $ROOT/users/${app}.${app_user_id}/attr

          which openssl  >/dev/null 2>&1
          if [ $? -eq 0 ];then
            hash_gen_key=`openssl rand -hex 20`
          else
            hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
          fi

          hash=`echo "${app}:${app_user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}'`
          echo "$hash" > $ROOT/users/${app}.${app_user_id}/hash
          chown -R small-shell:small-shell $ROOT/users/${app}.${app_user_id}
          chmod 700 $ROOT/users/${app}.${app_user_id}/hash
          authkey=`echo "${app_user_name}:${hash_gen_key}" | $BASE64_ENC`

          # deploy none auth APP
          cat $ROOT/web/src/cgi-bin/tmplt_controller_noauth | $SED "s#\%%www#${www}#g" | $SED "s/%%authkey/$authkey/g" \
          | $SED "s/%%app/$app/g" | $SED "s/%%auth//g" | $SED "s/%%IP_whitelisting/$IP_whitelisting/g" > $cgidir/$app
          chown $cgiusr:$cgiusr $cgidir/$app
          chmod 700 $cgidir/$app

          cat $ROOT/web/src/cgi-bin/tmplt_css | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" > $cgidir/${app}_css
          chown $cgiusr:$cgiusr $cgidir/${app}_css
          chmod 700 $cgidir/${app}_css

          cat $ROOT/web/src/bin/tmplt_type3_get.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_get.sh

          cat $ROOT/web/src/bin/tmplt_type3_set.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_set.sh

          cat $ROOT/web/src/bin/tmplt_type3_del.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_del.sh

          cat $ROOT/web/src/bin/tmplt_type3_table.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_table.sh

          cat $ROOT/web/src/bin/tmplt_log_viewer.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_log_viewer.sh

          cat $ROOT/web/src/bin/tmplt_main.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_main.sh

          cat $ROOT/web/src/bin/tmplt_page_links.sh | $SED "s#\%%www#${www}#g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_page_links.sh

          cat $ROOT/web/src/bin/tmplt_dl.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%databox/$databox/g" \
          | $SED "s/%%app/$app/g" > ${www}/bin/${app}_dl.sh

          chown $cgiusr:$cgiusr ${www}/bin/${app}*
          chmod 755 ${www}/bin/${app}*

          for src in `ls $ROOT/web/src/descriptor | grep tmplt | grep -v type2 | grep -v auth | xargs basename -a`
          do
            html_def=`echo $src | $SED "s/tmplt_//g" | $SED "s/type3_//g"`
            if [ ! "$src" = "tmplt_type3.css.def" ];then
              cat $ROOT/web/src/descriptor/$src | $SED "s/%%app/$app/g" | $SED "s/%%user/there/g" \
              | $SED "s/%%databox/$databox/g" > ${www}/descriptor/${app}_${html_def}
              chmod 755 ${www}/descriptor/${app}_${html_def}
            else
              cat $ROOT/web/src/descriptor/$src  > ${www}/descriptor/${app}.css.def
              chmod 755 ${www}/descriptor/${app}.css.def
            fi
          done

          for src in `ls $ROOT/web/src/descriptor/common_parts | grep tmplt | xargs basename -a`
          do
            menu=`echo $src | $SED "s/tmplt_//g" | $SED "s/type3_//g"`
            cat $ROOT/web/src/descriptor/common_parts/$src | $SED "s/%%app/$app/g" | $SED "s/%%databox/$databox/g" \
            > ${www}/descriptor/common_parts/${app}_${menu}
            chmod 755 ${www}/descriptor/common_parts/${app}_${menu}
          done

          chown $cgiusr:$cgiusr ${www}/descriptor/${app}*
          chown $cgiusr:$cgiusr ${www}/descriptor/common_parts/${app}*

          if [ "$srvtype" = "default" ];then
             if [ ! -d $www/html/$app ];then
               mkdir $www/html/$app
             fi
             cat $ROOT/web/src/descriptor/redirect.html.def | $SED "s#%%APPURL#${base_url}${app}#g" > $www/html/$app/index.html
             chmod 755 $www/html/$app/index.html
          fi

        fi

        # create UI.md.def databox
        cat $ROOT/tmp/gen/.tmplt.UI.md.def/databox.def | $SED "s/%%app/$app/g" > $tmp_dir/${app}.tmplt.UI.md.def
        $ROOT/util/scripts/bat_gen.sh $tmp_dir/${app}.tmplt.UI.md.def
        mkdir $tmp_dir/data

        for data in description righth lefth footer
        do
          cat $ROOT/tmp/gen/.tmplt.UI.md.def/$data | $SED "s/%%app/$app/g" > $tmp_dir/data/$data
        done

        if [ ! "$auth_method" = "none" ];then
          echo "Log Out: ./${app}?req=logout" >> $tmp_dir/data/righth
        fi

        # push template datas
        . $ROOT/util/scripts/.authkey
        permission=`$ROOT/bin/meta get.attr:sys`
        if [ "$permission" = "ro" ];then
          $ROOT/adm/ops set.attr:sys{rw} > /dev/null 2>&1
          sudo -u small-shell $ROOT/bin/DATA_shell authkey:$authkey databox:${app}.UI.md.def \
          action:set id:new keys:description,righth,lefth,footer input_dir:$tmp_dir/data
          $ROOT/adm/ops set.attr:sys{ro} > /dev/null 2>&1
        else
          sudo -u small-shell $ROOT/bin/DATA_shell authkey:$authkey databox:${app}.UI.md.def \
          action:set id:new keys:description,righth,lefth,footer input_dir:$tmp_dir/data
        fi

        clear
        echo "------------------------------------------------------------"
        echo "SCRATCH APP is successfully generated"

        if [ "$srvtype" = "default" ];then
          if [ ! "$auth_method" = "other" ];then
            echo "Access URL: ${index_url}${app}"
          else
            # for adaption of Oauth
            echo "Access URL: ${base_url}auth.${app}"
          fi
        else
          if [ "$auth_method" = "none" ];then
            echo "Access URL: ${base_url}${app}"
          else
            echo "Access URL: ${base_url}auth.${app}"
          fi
        fi
        echo "------------------------------------------------------------"
        echo "Following is generated codes that you can update."
        echo "You can also update portal page on Base APP #${app}.UI.md.def using markdown."

        if [ ! "$auth_method" = "none" ];then
          ls  $cgidir/auth.${app}
        fi

        ls  $cgidir/${app}
        ls  $cgidir/${app}_css
        ls  ${www}/bin/${app}_*
        ls  ${www}/descriptor/${app}_*

        if [ "$auth_method" = "key" ];then
          echo "------------------------------------------------------------"
          echo "please create user for the APP by following command"
          echo "------------------------------------------------------------"
          echo "sudo $ROOT/adm/ops app:${app} add.usr:\$user"
        fi

      else
      # else means this is subapp

        cat $ROOT/web/src/bin/tmplt_type3_table_sub.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%parent_app/$parent_app/g" \
        | $SED "s/%%databox/$databox/g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_table.sh

        cat $ROOT/web/src/bin/tmplt_type3_get_sub.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%parent_app/$parent_app/g" \
        | $SED "s/%%databox/$databox/g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_get.sh

        cat $ROOT/web/src/bin/tmplt_type3_set_sub.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%parent_app/$parent_app/g" \
        | $SED "s/%%databox/$databox/g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_set.sh

        cat $ROOT/web/src/bin/tmplt_type3_del_sub.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%parent_app/$parent_app/g" \
        | $SED "s/%%databox/$databox/g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_del.sh

        cat $ROOT/web/src/bin/tmplt_log_viewer_sub.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%parent_app/$parent_app/g" \
        | $SED "s/%%databox/$databox/g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_log_viewer.sh

        cat $ROOT/web/src/bin/tmplt_page_links.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%app/$parent_app/g" \
        > ${www}/bin/${app}_page_links.sh

        cat $ROOT/web/src/bin/tmplt_dl_sub.sh | $SED "s#\%%www#${www}#g" | $SED "s/%%parent_app/$parent_app/g" \
        | $SED "s/%%databox/$databox/g" | $SED "s/%%app/$app/g" > ${www}/bin/${app}_dl.sh

        chown $cgiusr:$cgiusr ${www}/bin/${app}*
        chmod 755 ${www}/bin/${app}*


        for src in `ls $ROOT/web/src/descriptor | grep tmplt | grep -v type2 | grep -v auth | xargs basename -a`
        do
          html_def=`echo $src | $SED "s/tmplt_//g" | $SED "s/type3_//g"`
          if [ ! "$src" = "tmplt_type3.css.def" ];then
            cat $ROOT/web/src/descriptor/$src | $SED "s/.\/%%app/.\/$parent_app/g" \
            | $SED "s/%%app/$parent_app/g" | $SED "s/%%databox/$databox/g" > ${www}/descriptor/${app}_${html_def}
          fi
        done

        for src in `ls $ROOT/web/src/descriptor/common_parts | grep tmplt | xargs basename -a`
        do
          menu=`echo $src | $SED "s/tmplt_//g" | $SED "s/type3_//g"`
          cat $ROOT/web/src/descriptor/common_parts/$src | $SED "s/%%app/$parent_app/g" | $SED "s/%%databox/$databox/g" \
          > ${www}/descriptor/common_parts/${app}_${menu}
          chmod 755 ${www}/descriptor/common_parts/${app}_${menu}
        done

        chmod 755 ${www}/descriptor/${app}*
        chown $cgiusr:$cgiusr ${www}/descriptor/${app}*
        chown $cgiusr:$cgiusr ${www}/descriptor/common_parts/${app}*

        # add routing to parent app
        cat $ROOT/web/src/cgi-bin/tmplt_subapp_routing | $SED "s#%%www#${www}#g" | $SED "s#%%app#${app}#g" > $tmp_dir/subapp_routing
        cat $cgidir/${parent_app} | $SED "/# sub app routing section/r ${tmp_dir}/subapp_routing"  > $tmp_dir/new_parent
        cat $tmp_dir/new_parent > $cgidir/${parent_app}

        # add menu to common menu
        if [ -f ${cgidir}/auth.${parent_app} ];then
          echo "<li><a href=\"./${parent_app}?%%session&subapp=${app}&req=table\">Table@${app}</a></li>" >> $tmp_dir/subAPP_link
          cat ${www}/descriptor/common_parts/${parent_app}_common_menu | $SED -e "/Log Out/i `cat $tmp_dir/subAPP_link`" > $tmp_dir/new_menu
          cat $tmp_dir/new_menu > ${www}/descriptor/common_parts/${parent_app}_common_menu
        else
          echo "<li><a href=\"./${parent_app}?%%session&subapp=${app}&req=table\">Table@${app}</a></li>" >> ${www}/descriptor/common_parts/${parent_app}_common_menu
        fi

        # add menu to UI.md.def
        . $ROOT/util/scripts/.authkey
        permission=`$ROOT/bin/meta get.attr:sys`
	chk_md_def=`$ROOT/bin/meta get.databox | grep ${parent_app}.UI.md.def`
	if [ "$chk_md_def" ];then
          id=`sudo -u small-shell $ROOT/bin/DATA_shell authkey:$authkey databox:${parent_app}.UI.md.def command:head_-1 format:none | $AWK -F "," '{print $1}'`
          sudo -u small-shell $ROOT/bin/DATA_shell authkey:$authkey databox:${parent_app}.UI.md.def action:get id:$id key:righth format:none \
          | $SED "s/righth://g" | $SED "s/_%%enter_/\n/g" > $tmp_dir/UI_md_def_menu
          mkdir $tmp_dir/data

          if [ "$permission" = "ro" ];then
            $ROOT/adm/ops set.attr:sys{rw} > /dev/null 2>&1
            tmp_permission_flg=yes
          fi

          if [ -f ${cgidir}/auth.${parent_app} ];then
            cat $tmp_dir/UI_md_def_menu | $SED -e "/Log Out/i Table@${app}: ./${parent_app}?req=table&subapp=${app}" > $tmp_dir/data/righth
            sudo -u small-shell $ROOT/bin/DATA_shell authkey:$authkey databox:${parent_app}.UI.md.def \
            action:set id:$id key:righth input_dir:$tmp_dir/data
          else
            cat $tmp_dir/UI_md_def_menu > $tmp_dir/data/righth
            echo "Table@${app}: ./${parent_app}?req=table&subapp=${app}" >> $tmp_dir/data/righth
            sudo -u small-shell $ROOT/bin/DATA_shell authkey:$authkey databox:${parent_app}.UI.md.def \
            action:set id:$id key:righth input_dir:$tmp_dir/data
          fi

          if [ "$tmp_permission_flg" = "yes" ];then
              $ROOT/adm/ops set.attr:sys{ro} > /dev/null 2>&1
          fi

	fi

        echo "subAPP is successfully generated, parent app is updated -> $cgidir/${parent_app},${www}/descriptor/common_parts/${parent_app}_common_menu"
        echo "Following is generated codes that you can update."
        ls  ${www}/bin/${app}_*
        ls  ${www}/descriptor/${app}_*

      fi

    else
      echo "Plese try again from beginning, #gen -app"
      rm -rf $tmp_dir
      exit 1
    fi

  fi

fi

# GENERATE BATCH (e-cron)

function gen_schedule(){
  echo -n "" > $tmp_dir/cron_entry
  echo "--Define schedule--"
  echo -n "Month [ any | 1-12 ]: "
  read month
  month_chk=`echo $month | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[1-9]\"" -e "\"[1][0-2]\""`

  while [ ! "$month" = "any" -a ! "$month_chk" ]  
  do
    echo -n "Try again [ any | 1-12 ]: "
    read month
    month_chk=`echo $month | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[1-9]\"" -e "\"[1][0-2]\""`
  done 

  echo -n "Date  [ any | 1-31 ]: "
  read date
  date_chk=`echo $date | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[1-9]\"" -e "\"[1-2][0-9]\"" -e  "\"[3][0-1]\""`

  while [ ! "$date" = "any" -a ! "$date_chk" ]
  do
    echo -n "Try again [ any | 1-31 ]: "
    read date
    date_chk=`echo $date | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[1-9]\"" -e "\"[1-2][0-9]\"" -e  "\"[3][0-1]\""`
  done

  echo -n "Hour  [ any | 0-23 ]: "
  read hour
  hour_chk=`echo $hour | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[0-9]\"" -e "\"[1][0-9]\""  -e "\"[2][0-3]\""`

  while [ ! "$hour" = "any" -a ! "$hour_chk" ]
  do
    echo -n "Try again [ any | 0-23 ]: "
    read hour
    hour_chk=`echo $hour | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[0-9]\"" -e "\"[1][0-9]\""  -e "\"[2][0-3]\""`
  done

  echo -n "Min   [ any | 0-59 ]: "
  read min
  min_chk=`echo $min | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[0-9]\"" -e "\"[1-5][0-9]\""`

  while [ ! "$min" = "any" -a ! "$min_chk" ]
  do
    echo -n "Try again [ any | 0-59 ]: "
    read min
    min_chk=`echo $min | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[0-9]\"" -e "\"[1-5][0-9]\""`
  done

  if [ "$min" = "any" ];then
    echo -n "* " >> $tmp_dir/cron_entry
    echo "Min: any" >> $tmp_dir/confirm
  else
    echo -n "$min " >> $tmp_dir/cron_entry
    echo "Min: $min" >> $tmp_dir/confirm
  fi

  if [ "$hour" = "any" ];then
    echo -n "* " >> $tmp_dir/cron_entry
    echo "Hour: any" >> $tmp_dir/confirm
  else
    echo -n "$hour " >> $tmp_dir/cron_entry
    echo "Hour: $hour" >> $tmp_dir/confirm
  fi

  if [ "$date" = "any" ];then
    echo -n "* " >> $tmp_dir/cron_entry
    echo "Date: any" >> $tmp_dir/confirm
  else
    echo -n "$date " >> $tmp_dir/cron_entry
    echo "Date: $date" >> $tmp_dir/confirm
  fi

  if [ "$month" = "any" ];then
    echo -n "* " >> $tmp_dir/cron_entry
    echo "Month: any" >> $tmp_dir/confirm
  else
    echo -n "$month " >> $tmp_dir/cron_entry
    echo "Month: $month" >> $tmp_dir/confirm
  fi

  echo -n "Week  [ any | mon - sun ]: "
  read week
  week_chk=`echo $week | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep -e "\"mon\"" -e "\"tue\"" -e "\"wed\"" -e "\"thu\"" \
            -e "\"fri\"" -e  "\"sat\"" -e "\"sun\""`

  while [ ! "$week" = "any" -a ! "$week_chk" ]
  do
    echo -n "Try again [ any | mon - sun ]: "
    read week
     week_chk=`echo $week | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep -e "\"mon\"" -e "\"tue\"" -e "\"wed\"" -e "\"thu\"" \
            -e "\"fri\"" -e  "\"sat\"" -e "\"sun\""`
  done

  if [ "$week" = "any" ];then
    echo "*" >> $tmp_dir/cron_entry
    echo "Week: any" >> $tmp_dir/confirm

  elif [ "$week" = "mon" ];then
    echo "1" >> $tmp_dir/cron_entry
    echo "Week: $week" >> $tmp_dir/confirm

  elif [ "$week" = "tue" ];then
    echo "2" >> $tmp_dir/cron_entry
    echo "Week: $week" >> $tmp_dir/confirm

  elif [ "$week" = "wed" ];then
    echo "3" >> $tmp_dir/cron_entry
    echo "Week: $week" >> $tmp_dir/confirm

  elif [ "$week" = "thu" ];then
    echo "4" >> $tmp_dir/cron_entry
    echo "Week: $week" >> $tmp_dir/confirm

  elif [ "$week" = "fri" ];then
    echo "5" >> $tmp_dir/cron_entry
    echo "Week: $week" >> $tmp_dir/confirm

  elif [ "$week" = "sat" ];then
    echo "6" >> $tmp_dir/cron_entry
    echo "Week: $week" >> $tmp_dir/confirm

  elif [ "$week" = "sun" ];then
    echo "7" >> $tmp_dir/cron_entry
    echo "Week: $week" >> $tmp_dir/confirm
  fi
}

if [ "$param" = "-job" ];then

  # start dialog
  echo -n "Job Name: "
  read job
  ascii_chk_result=`ascii_check $job`
  meta_chk_result=$(echo $job | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
  -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "\." -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

  ls $ROOT/util/e-cron/def/${job}.def >/dev/null 2>&1
  if [ $? -eq 0 ];then
    existing_chk_result=existing
  else
    existing_chk_result=""
  fi

  while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" -o ! "$job" ]
  do

    if [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" ];then
      echo "error: Job name must be ascii text and you can't use meta charactor including space, please try again"
    fi
    echo -n "Job Name: "
    read job
    ascii_chk_result=`ascii_check $job`
    meta_chk_result=$(echo $job | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "\." -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

    ls $ROOT/util/e-cron/def/${job}.def >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    else
      existing_chk_result=""
    fi

  done
  echo "Job_name: $job" > $tmp_dir/confirm
  touch $tmp_dir/${job}.def

  if [ ! "$existing_chk_result" = existing ];then
    echo -n "Type of job (1.job automation | 2.file exchange) : "
    read jobtype
    while [ ! "$jobtype" = "1" -a  ! "$jobtype" = "2" ]
    do
      echo -n "please input number (1.job automation | 2.file exchange) : "
      read jobtype
    done
  else
    command_chk=`grep "^exec_command=" $ROOT/util/e-cron/def/${job}.def`
    if [ "$command_chk" ];then
      jobtype=1
    else
      jobtype=2
    fi
  fi

  if [ "$jobtype" = "1" ];then

    if [ "$existing_chk_result" = existing ];then
      clear
      echo "WARN job:${job} is existing, please update the job by dialog.and if you don't want to update it, please exit with ctrl + C"
    fi
    gen_schedule
    cat $tmp_dir/cron_entry | $SED "s/^/SCHEDULE:/g" > $tmp_dir/${job}.def
    echo -n "Exec command or batch script: "
    read exec_command

    if [ "$exec_command" ];then
      solo_command=`echo $exec_command | $AWK '{print $1}'`

      if [ ! -f "$solo_command" -a -f ${ROOT}/util/scripts/${solo_command} ];then
        solo_command="${ROOT}/util/scripts/${solo_command}"
        command_path=`echo $ROOT/util/scripts/ | $SED "s/\//{%%%%%%%}/g"`
        exec_command=`echo "$exec_command" | $SED "s/^/$command_path/g" | $SED "s/{%%%%%%%}/\//g"`
      fi

      if [ ! -f "$solo_command" -a -f /usr/bin/${solo_command} ];then
        solo_command="/usr/bin/${solo_command}"
        command_path=`echo /usr/bin/ | $SED "s/\//{%%%%%%%}/g"`
        exec_command=`echo "$exec_command" | $SED "s/^/$command_path/g" | $SED "s/{%%%%%%%}/\//g"`
      fi

      if [ ! -f "$solo_command" -a -f /bin/${solo_command} ];then
        solo_command="/bin/${solo_command}"
        command_path=`echo /bin/ | $SED "s/\//{%%%%%%%}/g"`
        exec_command=`echo "$exec_command" | $SED "s/^/$command_path/g" | $SED "s/{%%%%%%%}/\//g"`
      fi

      exec_chk=`sudo -u small-shell file $solo_command | grep -i -e executable -e gnu`

    fi

    while [ ! "$exec_command" -o ! -x "$solo_command" -o ! "$exec_chk" ]
    do
      if [ ! "$exec_command" ];then
        echo -n "please input exec command or batch script: "
      elif [  ! -x "$solo_command" ];then
        echo "seems $solo_command is not executable, please input full path for the command"
        echo -n "please input exec command or batch script: "
      elif [ ! "$exec_chk" ];then
        echo "seems $solo_command is not executable by small-shell"
        echo -n "please input exec command or batch script: "
      fi

      read exec_command

      if [ "$exec_command" ];then
        solo_command=`echo $exec_command | $AWK '{print $1}'`
        if [ ! -f "$solo_command" -a -f ${ROOT}/util/scripts/${solo_command} ];then
          solo_command="${ROOT}/util/scripts/${solo_command}"
          command_path=`echo $ROOT/util/scripts/ | $SED "s/\//{%%%%%%%}/g"`
          exec_command=`echo "$exec_command" | $SED "s/^/$command_path/g" | $SED "s/{%%%%%%%}/\//g"`
        fi

        if [ ! -f "$solo_command" -a -f /usr/bin/${solo_command} ];then
          solo_command="/usr/bin/${solo_command}"
          command_path=`echo /usr/bin/ | $SED "s/\//{%%%%%%%}/g"`
          exec_command=`echo "$exec_command" | $SED "s/^/$command_path/g" | $SED "s/{%%%%%%%}/\//g"`
        fi

        if [ ! -f "$solo_command" -a -f /bin/${solo_command} ];then
          solo_command="/bin/${solo_command}"
          command_path=`echo /bin/ | $SED "s/\//{%%%%%%%}/g"`
          exec_command=`echo "$exec_command" | $SED "s/^/$command_path/g" | $SED "s/{%%%%%%%}/\//g"`
        fi

        exec_chk=`sudo -u small-shell file $solo_command | grep -i -e executable -e gnu`

      fi
    done
    echo "exec_command=\"`echo $exec_command | $SED "s/'/{%%%%%%}/g"\
    | php -r "echo addslashes(file_get_contents('php://stdin'));"\
    | $SED "s/{%%%%%%}/'/g"`\"" >> $tmp_dir/${job}.def

    echo "Exec_command: `echo $exec_command |  $SED "s/'/{%%%%%%}/g" \
    | php -r "echo addslashes(file_get_contents('php://stdin'));"\
    | $SED "s/{%%%%%%}/'/g"`" >> $tmp_dir/confirm

    echo "input_message=\"\"" >> $tmp_dir/${job}.def
    echo "output_message=\"\"" >> $tmp_dir/${job}.def
    echo "hubapi=\"\"" >> $tmp_dir/${job}.def
    echo "api_authkey=\"\"" >> $tmp_dir/${job}.def

    #clear
    echo "Job will be generated by following order, please check it" 
    echo "-----------------------------------------------------------------"
    echo ""
    echo "Jobtype: 1.job automation"
    cat $tmp_dir/confirm
    echo ""
    echo "-----------------------------------------------------------------"
    echo -n "Is it OK? (yes | no): "
    read fin_answer
    while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Is it OK to generate job? (yes | no): "
      read fin_answer
    done
   
    if [ "$fin_answer" = "yes" ];then

      if [ "$existing_chk_result" = "existing" ];then
        sudo -u small-shell $ROOT/bin/e-cron disable.${job}
      fi
      cat $tmp_dir/${job}.def > $ROOT/util/e-cron/def/${job}.def
      chown small-shell:small-shell $ROOT/util/e-cron/def/${job}.def
      chmod 755 $ROOT/util/e-cron/def/${job}.def


      if [ $? -eq 0 ];then
        echo "Succesfully generated. job definition is here"
        echo "def: $ROOT/util/e-cron/def/${job}.def" 
        echo "Please enable job \"sudo -u small-shell $ROOT/bin/e-cron enable.$job\""
        cat $tmp_dir/confirm | grep -v "Exec_command:" | grep -v "Job_name:" > $ROOT/util/e-cron/def/.${job}.dump
      else
        echo "error: something wrong"
      fi
    else
      echo "Plese try again from beginning, #gen -job"
      rm -rf $tmp_dir
      exit 1
    fi
  fi

  if [ "$jobtype" = "2" ];then

    if [ "$existing_chk_result" = existing ];then
      clear
      echo "WARN job:${job} is existing, please update the job by dialog.and if you don't want to update it, please exit with ctrl + C"
    fi
    gen_schedule
    cat $tmp_dir/cron_entry | $SED "s/^/SCHEDULE:/g" > $tmp_dir/${job}.def
    echo -n "Type of file exchange (push | get): "
    read exchange_type
    while [ ! "$exchange_type" = "push" -a ! "$exchange_type" = "get" ]
    do
      echo "please input push or get"
      echo -n "Type (push | get): "
      read exchange_type
    done
    echo "Exchange Type: $exchange_type" >> $tmp_dir/confirm

    if [ "$exchange_type" = "get" ];then
      echo -n "Local directory: "
      read local_dir
      if [ -d $local_dir ];then
        sudo -u small-shell echo "test" > $local_dir/.gentest
	if [ $? -eq 0 ];then
	  gen_test=success
        else
          gen_test=""
	fi
      fi
      while [ ! "$gen_test" = "success" ]
      do
        echo "Oops something wrong, small-shell could not write down test file to the directory. please review the path or permission, then try again"
        echo -n "Local directory: "
        read local_dir
        if [ -d $local_dir ];then
          sudo -u small-shell echo "test" > $local_dir/.gentest
          if [ $? -eq 0 ];then
            gen_test=success
          else
            gen_test=""
          fi
        fi
      done
      echo "local_dir=\"$local_dir\"" >> $tmp_dir/${job}.def
    fi

    if [ "$exchange_type" = "push" ];then
      echo -n "Local directory: "
      read local_dir
      if [ -d $local_dir ];then
        echo "test" > $local_dir/.gentest
        sudo -u small-shell ls $local_dir/.gentest > /dev/null 2>&1
        if [ $? -eq 0 ];then
          gen_test=success
        else
          gen_test=""
        fi
      fi
      while [ ! "$gen_test" = "success" ]
      do
        echo "Oops something wrong, small-shell could not access to the directory. please review the path or permission, then try again"
        echo -n "Local directory: "
        read local_dir
        if [ -d $local_dir ];then
          echo "test" > $local_dir/.gentest
          sudo -u small-shell ls  $local_dir/.gentest > /dev/null 2>&1
          if [ $? -eq 0 ];then
            gen_test=success
          else
            gen_test=""
          fi
        fi
      done
      echo "local_dir=\"$local_dir\"" >> $tmp_dir/${job}.def
    fi

    echo -n "File_name: "
    read file_name
    file_name_excld_astrsk=`echo $file_name | tr -d \*`
    ascii_chk_result=`ascii_check $file_name_excld_astrsk`
    meta_chk_result=$(echo $file_name_exld_astrsk | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

    while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" -o ! "$file_name" ]
    do
      echo "error: File_name must be ascii text and you can't use meta charactor including space, please try again"
      echo -n "File_name: "
      read file_name
      file_name_excld_astrsk=`echo $file_name | tr -d \*`
      ascii_chk_result=`ascii_check $file_name_excld_astrsk`
      meta_chk_result=$(echo $file_name_excld_astrsk | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
      -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")
    done
    echo "${exchange_type}_file=\"$file_name\"" >> $tmp_dir/${job}.def
    echo "File: $file_name" >> $tmp_dir/confirm
    
    echo -n "HUB API URL: "
    read hubapi
    while [ ! "$hubapi" ]
    do
      echo "seems input is null, please try again"
      echo -n "HUB API URL: "
      read hubapi
    done

    echo -n "API authkey: "
    read authkey
    while [ ! "$authkey" ]
    do
      echo "seems input is null, please try again"
      echo -n "API authkey: "
      read authkey
    done
   
    echo "HUB API test will be started (push & get)..."
    sleep 0.2
    clear
    echo "HUB API test will be started (push & get).."
    sleep 0.2
    clear
    echo "HUB API test will be started (push & get)"
    clear

    # push test
    file_que=${ROOT}/util/e-cron/que/file
    echo "test" > ${file_que}/e-cron_test
    chown small-shell:small-shell ${file_que}/e-cron_test
    push_file=e-cron_test
    result=`$CURL -X POST "${hubapi}?req=push&filename=${push_file}" \
    -H "Content-Type:application/octet-stream" -H "X-small-shell-authkey:${authkey}" \
    --data-binary @${file_que}/${push_file}`

    if [ ! "$result" -o ! "$result" = "file push failed" ];then
      echo "File push test has been succesfully done" 
    else
      echo "Something wrong for file push test"
      echo "please set correct URL and authkey, and try again"
      echo "URL and authkey can be checked on dataExchange HUB server (e.g. cat /usr/local/small-shell/web/base)"
      rm -rf $tmp_dir
      exit 1
    fi 

    # get test
    if [ ! -d ${file_que}/.e-cron_test ];then
      mkdir ${file_que}/.e-cron_test
      chown small-shell:small-shell ${file_que}/.e-cron_test
    fi
    (cd ${file_que}/.e-cron_test && $CURL -OLJ "${hubapi}?req=get&filename=e-cron_test" -H "X-small-shell-authkey:$authkey")

    if [ -f ${file_que}/.e-cron_test/e-cron_test ];then
      echo "File get test has been succesfully done" 
      rm -rf ${file_que}/.e-cron_test
    else
      echo "Something wrong for file get test"
      echo "please set correct URL and authkey, and try again"
      echo "URL and authkey can be checked on dataExchange HUB server (e.g. cat /usr/local/small-shell/web/base)"
      rm -rf ${file_que}/.e-cron_test
      rm -rf $tmp_dir
      exit 1
    fi   
    echo "hubapi=\"$hubapi\"" >> $tmp_dir/${job}.def
    echo "api_authkey=\"$authkey\"" >> $tmp_dir/${job}.def
    echo "HUB API URL: $hubapi" >> $tmp_dir/confirm
    echo "API authkey: $authkey" >> $tmp_dir/confirm

    sleep 1
    clear
    echo "Job will be generated by following order, please check it"
    echo "-----------------------------------------------------------------"
    echo ""
    echo "Job_type: 2.file exchange"
    cat $tmp_dir/confirm
    echo ""
    echo "-----------------------------------------------------------------"
    echo -n "Is it OK? (yes | no): "
    read fin_answer
    while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Is it OK to generate job? (yes | no): "
      read fin_answer
    done

    if [ "$fin_answer" = "yes" ];then

      if [ "$existing_chk_result" = "existing" ];then
        sudo -u small-shell $ROOT/bin/e-cron disable.${job}
      fi

      cat $tmp_dir/${job}.def > $ROOT/util/e-cron/def/${job}.def
      chown small-shell:small-shell $ROOT/util/e-cron/def/${job}.def
      chmod 755 $ROOT/util/e-cron/def/${job}.def

      if [ $? -eq 0 ];then
        echo "Succesfully generated. job definition is here"
        echo "def: $ROOT/util/e-cron/def/${job}.def"
        echo "Please enable job \"sudo -u small-shell $ROOT/bin/e-cron enable.$job\""

        cat $tmp_dir/confirm | grep -v "HUB API URL:" | grep -v "API authkey:" \
        | grep -v "File:" | grep -v "Job_name:" | grep -v "Exchange Type: " > $ROOT/util/e-cron/def/.${job}.dump

      else
        echo "error: something is wrong"
      fi
    else
      echo "Plese try again from beginning, #gen -job"
      rm -rf $tmp_dir
      exit 1
    fi
    
  fi
fi

rm -rf $tmp_dir
