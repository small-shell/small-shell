#!/bin/bash

#----------------------------------------------------------
# PARAM FOR GEN
#----------------------------------------------------------
# -databox # generate new DataBox
# -addcol  # add column to existing DataBox
# -delcol  # delete column from existing DataBox
# -app     # generate new app
# -job     # generate automate shell
#----------------------------------------------------------

param=$1
WHOAMI=$(whoami)
if [ ! "$WHOAMI" = "root" ];then
  echo "error: user must be root"
  exit 1
fi

# user check
cat /etc/passwd | grep small-shell > /dev/null 2>&1
if [ ! $? -eq 0 ];then
  mac_chk=$(dscl . list /Users 2>/dev/null | grep small-shell 2>/dev/null)
  if [ ! "$mac_chk" ];then
    echo "error: small-shell is not existing, please add user beforehand"
    exit 1
  fi
fi

# create .env
SCRIPT_DIR=$(dirname $0)

if [ ! -f ${SCRIPT_DIR}/../.env ];then

  # set permissions
  cp ${SCRIPT_DIR}/../global.conf ${SCRIPT_DIR}/../.env
  chmod 755 ${SCRIPT_DIR}/../.env
  . ${SCRIPT_DIR}/../.env
  sudo chown -R small-shell:small-shell $ROOT
  chmod 755 ${ROOT}/util/scripts/*
  chmod 755 ${ROOT}/util/e-cron/bin/*
  chmod 755 ${ROOT}/util/pyshell/pygraph.sh
  chmod 755 ${ROOT}/util/pyshell/env
  chmod 755 ${ROOT}/bin/*
  chmod 755 ${ROOT}/adm/*
  chmod 755 ${ROOT}/sbin/*

  if [ ! "$mac_chk" ];then

    which sha256sum > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install sha256sum command first"
      exit 1
    fi

    which base64 > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install base64 command first"
      exit 1
    fi

    which flock > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install flock command first"
      exit 1
    fi

    which php > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install php command first"
      exit 1
    fi

    which curl > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install curl command first"
      exit 1
    fi

    which bc > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install bc command first"
      exit 1
    fi

    which jq >/dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install jq command first"
      exit 1
    fi 

    which crontab >/dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install cron first"
      exit 1
    fi

    echo "SHASUM=\"$(which sha256sum)\"" >> ${SCRIPT_DIR}/../.env
    echo "BASE64_ENC=\"$(which base64) -w 0\"" >> ${SCRIPT_DIR}/../.env
    echo "BASE64_DEC=\"$(which base64) -d\"" >> ${SCRIPT_DIR}/../.env
    echo "SED=\"$(which sed)\"" >> ${SCRIPT_DIR}/../.env
    echo "AWK=\"$(which awk)\"" >> ${SCRIPT_DIR}/../.env
    echo "FLOCK=\"$(which flock)\"" >> ${SCRIPT_DIR}/../.env
    echo "PHP=\"$(which php)\"" >> ${SCRIPT_DIR}/../.env
    echo "CURL=\"$(which curl)\"" >> ${SCRIPT_DIR}/../.env
    echo "BC=\"$(which bc)\"" >> ${SCRIPT_DIR}/../.env
    echo "JQ=\"$(which jq)\"" >> ${SCRIPT_DIR}/../.env

  else

    which shasum > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install shasum command first"
      exit 1
    fi

    which base64 > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install base64 command first"
      exit 1
    fi

    which gsed > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install gsed first"
      exit 1
    fi

    which gawk > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install gawk first"
      exit 1
    fi

    which flock > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install flock first"
      exit 1
    fi

    which php > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install php command first"
      exit 1
    fi

    which curl > /dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "error: please install curl command first"
      exit 1
    fi

    echo "SHASUM=\"$(which shasum) -a 256\"" >> ${SCRIPT_DIR}/../.env
    echo "BASE64_ENC=\"$(which base64)\"" >> ${SCRIPT_DIR}/../.env
    echo "BASE64_DEC=\"$(which base64) -D\"" >> ${SCRIPT_DIR}/../.env
    echo "SED=\"$(which gsed)\"" >> ${SCRIPT_DIR}/../.env
    echo "AWK=\"$(which gawk)\"" >> ${SCRIPT_DIR}/../.env
    echo "FLOCK=\"$(which flock)\"" >> ${SCRIPT_DIR}/../.env
    echo "PHP=\"$(which php)\"" >> ${SCRIPT_DIR}/../.env
    echo "CURL=\"$(which curl)\"" >> ${SCRIPT_DIR}/../.env

    which jq >/dev/null 2>&1
    if [ ! $? -eq 0 ];then
      echo "warn: please install jq command, if you want to use Web API "
    else
      echo "JQ=\"$(which jq)\"" >> ${SCRIPT_DIR}/../.env
    fi

  fi
fi

# load .env 
if [ ! -x ${SCRIPT_DIR}/../.env ];then
  chmod 755 ${SCRIPT_DIR}/../.env
fi
 . ${SCRIPT_DIR}/../.env

# owner check
shell_owner=$(ls -ld $ROOT | $AWK '{print $3}')
if [ ! "$shell_owner" = "small-shell" ];then
  echo "error: $ROOT is not owned by small-shell. please change owner by following command"
  echo "sudo chown -R small-shell:small-shell $ROOT"
  exit 1
fi

# gen tmpdir
random=$RANDOM
while [ -d ${ROOT}/tmp/gen/${random} ]
do
 sleep 0.01
 count=$(expr $count + 1)
 if [ $count -eq 100 ];then
   echo "error: something is wrong"
   exit 1
 fi
 random=$RANDOM
done
mkdir ${ROOT}/tmp/gen/${random}
tmp_dir="${ROOT}/tmp/gen/${random}"

# handle kill signal
trap 'clear_dialog' SIGINT
function clear_dialog(){
  if [ -d "$tmp_dir" ];then
    echo ""
    echo "tmp file will be deleted, please try again from beginning"
    rm -rf $tmp_dir
    exit 1
  else
    echo ""
    echo "dialog will be ended, please try again from beginning"
    exit 1
  fi
}

# ascii check
function ascii_check(){
  input=$1  
  check=$(echo "$input" | file -i - | grep -i ascii)
  if [ "$check" ]; then
    echo "NP"
    return 0
  else
    echo "ERROR"
    return 1
  fi
}

function charset_check(){
  input=$1
  check=$(echo "$input" | file -i - | grep -i -e ascii -e utf)
  if [ "$check" ]; then
    echo "NP"
    return 0
  else
    echo "ERROR"
    return 1
  fi
}


# create AUTHKEY for SYS
user_name=sys
user_id=$(echo "$user_name" | $SHASUM | $AWK '{print $1}')

if [ ! -d ${ROOT}/users/${user_id} ];then
  mkdir ${ROOT}/users/${user_id}
  echo "$user_name" > ${ROOT}/users/${user_id}/user_name
  echo "permission=ro" > ${ROOT}/users/${user_id}/.attr.tmp
  cat ${ROOT}/users/${user_id}/.attr.tmp > ${ROOT}/users/${user_id}/attr
  chown small-shell:small-shell ${ROOT}/users/${user_id}/attr

  which openssl  >/dev/null 2>&1
  if [ $? -eq 0 ];then
    hash_gen_key=$(openssl rand -hex 20)
  else
    hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
  fi

  hash=$(echo "${user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}')
  echo "$hash" > ${ROOT}/users/${user_id}/hash
  chown -R small-shell:small-shell ${ROOT}/users/${user_id}
  chmod 700 ${ROOT}/users/${user_id}/hash
  user_key=$(echo "${user_name}:${hash_gen_key}" | $BASE64_ENC)
  echo "authkey=\"${user_key}\"" > ${ROOT}/util/scripts/.authkey
  chown small-shell:small-shell ${ROOT}/util/scripts/.authkey
  chmod 700 ${ROOT}/util/scripts/.authkey
fi

# GENERATE DATA BOX 
if [ "$param" = "-databox" ];then

  if [ $2 ];then
    bat_chk=$2
    if [ "$bat_chk" = "-bat" ];then
      bat_flag=yes
    fi
  fi

  # command check for databox 
  (cd ${ROOT}/tmp && sudo -u small-shell echo "\n" | $SED -z "s/\n//g" >/dev/null 2>&1)
  if [ ! $? -eq 0 ];then
    echo "error: please install $SED command which can use -z option #above version 4.2.2"
    rm -rf $tmp_dir
    exit 1
  fi

  (cd ${ROOT}/tmp && sudo -u small-shell echo "Create" | $AWK 'IGNORECASE = 1;/^create/;' >/dev/null 2>&1)
  if [ ! $? -eq 0 ];then
    echo "error: please install $AWK command which can use INNORECASE option"
    rm -rf $tmp_dir
    exit 1
  fi

  # start dialog 
  echo -n "Databox Name: "
  read databox
  ascii_chk_result=$(ascii_check $databox)
  meta_chk_result=$(echo "$databox" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
  -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

  ls ${ROOT}/databox/${databox} >/dev/null 2>&1
  if [ $? -eq 0 ];then
    existing_chk_result=existing
  else
    existing_chk_result=""
  fi

  while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" -o "$existing_chk_result" = "existing" -o ! "$databox" ]
  do

    if [ ! "$existing_chk_result" = "existing" ];then
      echo "error: databox name must be ascii text and you can't use meta charactor including space, please try again"
    else
      echo "error: databox ${databox} is existing, please try again"
    fi

    if [ "$bat_flag" = "yes" ];then
      echo "#databox check error -> failed"
      rm -rf $tmp_dir
      exit 1
    fi

    echo -n "Databox Name: "
    read databox
    ascii_chk_result=$(ascii_check $databox)
    meta_chk_result=$(echo "$databox" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

    ls ${ROOT}/databox/${databox} >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    else
      existing_chk_result=""
    fi

  done
  echo "$databox" > ${tmp_dir}/databox

  # define primary key 
  echo -n "Primary Key Name: "
  read primary_key
  reserved_chk_result=$(echo "$primary_key" | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data")
  eval $primary_key=test >/dev/null 2>&1
  load_chk=$?
  meta_chk_result=$(echo "$primary_key" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
  -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

  while [ "$reserved_chk_result" -o "$meta_chk_result" -o ! "$load_chk" -eq 0 ]
  do
    if [ "$reserved_chk_result" ];then
      echo "error: you can't use {input temp binary_file params} as key, because these are reserved"
    else
      echo "error: key load is failed, it must be  ascii text and you can't use meta charactor or number space, please try again"
    fi

    if [ "$bat_flag" = "yes" ];then
      echo "#primary_key check error -> failed"
      rm -rf $tmp_dir
      exit 1
    fi

    echo -n "primary_key: "
    read primary_key
    reserved_chk_result=$(echo "$primary_key" | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data")
    eval $primary_key=test >/dev/null 2>&1
    load_chk=$?
    meta_chk_result=$(echo "$primary_key" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \|)
  done

  if [ ! "$primary_key" = "hashid" ];then
    
    echo -n "Primary Key Label: "
    read primary_key_label
    char_chk_result=$(charset_check "$primary_key_label")

    while [ "$char_chk_result" = "ERROR" ]
    do
      echo "error: key label charset seems wrong, please use UTF-8 as charset"

      if [ "$bat_flag" = "yes" ];then
        echo "#primary_key_label check error -> failed"
        rm -rf $tmp_dir
        exit 1
      fi

      echo -n "primary_key_label: "
      read primary_key_label
      char_chk_result=$(charset_check "$primary_key_label")
    done
  else
    primary_key_label="#ID"
  fi

  # escape meta character
  primary_key_label=$(echo "$primary_key_label" | $SED "s/\"//g")
  
  # dump primary_key
  echo "name=\"${primary_key}\"" > ${tmp_dir}/col1
  echo "label=\"${primary_key_label}\"" >> ${tmp_dir}/col1
  echo "type=\"text\"" >> ${tmp_dir}/col1
  echo "option=\"required\"" >> ${tmp_dir}/col1

  if [ ! "$primary_key" = "hashid" ];then
    echo -n "Add more columns to the databox? (yes | no): "
    read add_col_answer 
  else
    add_col_answer=yes
  fi

  while [ ! "$add_col_answer" = "yes" -a ! "$add_col_answer" = "no" ]
  do
    echo "please input yes or no" 

    if [ "$bat_flag" = "yes" ];then
      echo "#add col answer check error -> failed"
      rm -rf $tmp_dir
      exit 1
    fi

    echo -n "Add more columns to the databox? (yes | no): "

    read add_col_answer 
  done

  count=2

  while [ "$add_col_answer" = "yes" ]
  do
  clear
  echo -n "Col${count} Key Name: "
  read add_key 
  reserved_chk_result=$(echo "$add_key" | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data")
  eval $add_key=test >/dev/null 2>&1
  load_chk=$?
  meta_chk_result=$(echo "$add_key" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
  -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")


  grep "name=\"${add_key}\"" ${tmp_dir}/col* >/dev/null 2>&1
  if [ $? -eq 0 ];then
    existing_chk_result=existing
  else
    existing_chk_result=""
  fi

    while [ "$existing_chk_result" = "existing" -o "$reserved_chk_result" -o "$meta_chk_result" -o ! "$load_chk" -eq 0 ]
    do

      if [ "$reserved_chk_result" ];then
        echo "error: you can't use {input temp binary_file params} as key, because these are reserved"
      fi

      if [ "$existing_chk_result" = "existing" ];then
        echo "error: key_name is already defined, please try again"
      fi

      if [ ! "$load_chk" -eq  0 ];then
        echo "error: key load is failed, it must be  ascii text and you can't use meta charactor or number space, please try again"
      fi

      if [ "$bat_flag" = "yes" ];then
        echo "# col${count} key check error -> failed"
        rm -rf $tmp_dir
        exit 1
      fi

      echo -n "Col${count} Key Name: "
      read add_key
      reserved_chk_result=$(echo "$add_key" | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data")
      eval $add_key=test >/dev/null 2>&1
      load_chk=$?
      meta_chk_result=$(echo "$add_key" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
      -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \|)

      grep "name=\"${add_key}\"" ${tmp_dir}/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        existing_chk_result=existing
      else
        existing_chk_result=""
      fi

    done

    echo -n "Col${count} Key Label: "
    read add_key_label
    char_chk_result=$(charset_check "$add_key_label")

    while [ "$char_chk_result" = "ERROR" ]
    do
      echo "error: key label charset seems wrong, please use UTF-8 as charset"

      if [ "$bat_flag" = "yes" ];then
        echo "# col${count} key label check error -> failed"
        rm -rf $tmp_dir
        exit 1
      fi

      echo -n "add_key_label: "
      read add_key_label
      char_chk_result=$(charset_check "$add_key_label")
    done

    # escape meta character
    add_key_label=$(echo "$add_key_label" | $SED "s/\"//g")

    echo -n "Data Type (text | select | radio | checkbox | email | num | tel | date | date-time | url | textarea | file | pdls | mls): "
    read type
    data_chk_result=$(echo "$type" | grep -e "text" -e "select" -e "radio" -e "checkbox" \
    -e "email" -e "date"  -e "date-time" -e "num" -e "tel"  -e "url" -e "textarea" -e "file" -e "pdls" -e "mls")

    if [ "$type" = "file" ];then
      grep "type=\"file\"" ${tmp_dir}/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        data_chk_result=""
        data_chk_flg="file"
      fi
    fi

    while [ ! "$data_chk_result" ]
    do
      echo "Data type is wrong, please try again"

      if [ "$data_chk_flg" = "file" ];then
        echo "1 dataset could have only 1 file, please do not add file again"
      fi

      if [ "$bat_flag" = "yes" ];then
        echo "# col${count} data type check error -> failed"
        rm -rf $tmp_dir
        exit 1
      fi

      echo -n "Data Type (text | select | radio | checkbox | email | num | tel | date | date-time | url | textarea | file | pdls | mls): "
      read type
      data_chk_result=$(echo "$type" | grep -e "text" -e "select" -e "radio" -e "checkbox" \
      -e "email" -e "date"  -e "date-time" -e "num" -e "tel"  -e "url" -e "textarea" -e "file" -e "pdls" -e "mls")

      data_chk_flg=""
      if [ "$type" = "file" ];then
        grep "type=\"file\"" ${tmp_dir}/col* >/dev/null 2>&1
        if [ $? -eq 0 ];then
          data_chk_result=""
          data_chk_flg="file"
        fi
      fi

    done   

    if [ "$type" = "select" -o "$type" = "radio" ];then
      echo -n "Please list the values, separated by commas: "
      read params
      char_chk_result=$(charset_check "$params")
      while [ "$char_chk_result" = "ERROR" ]
      do
        echo "It seems invalid charactor is included, please try again."
        echo -n "values: "
        read params
        char_chk_result=$(charset_check "$params")
      done
    fi

    if [ "$type" = "select" -o "$type" = "radio" ];then
      separator_chk=$(echo "$params" | grep ,)
      while [ ! "$separator_chk" ]
      do
        echo "There is no separator(comma), please list the values using comma \",\""
        echo -n "values: "
        read params
        separator_chk=$(echo "$params" | grep ,)
      done
    fi

    if [ "$type" = "num" ];then
      type=number
    fi

    if [ "$type" = "date-time" ];then
      type="datetime-local"
    fi

    if [ "$type" = "pdls" ];then
      echo -n "please input databox name for making pdls(primary value data list): "
      read pdlsbox
      while [ "$pdlsbox" -a ! -d ${ROOT}/databox/${pdlsbox} ]
      do
        echo -n "databox seems wrong, please try again: "
        read pdlsbox
      done     
    fi

    if [ ! "$type" = "file" -a ! "$type" = "checkbox" -a ! "$type" = "radio" -a ! "$type" = "select" ];then
      echo -n "Set this as required? (yes | no): "
      read option_answer
      if [ "$option_answer" = "yes" ];then
        option=required
      else
        option=""
      fi

      while [ ! "$option_answer" = "yes" -a ! "$option_answer" = "no" ]
      do
        echo "please input yes or no"
 
        if [ "$bat_flag" = "yes" ];then
          echo "# col${count} required check error -> failed"
          rm -rf $tmp_dir
          exit 1
        fi

        echo -n "Set this as required? (yes | no): "
        read option_answer
        if [ "$option_answer" = "yes" ];then
          option=required
        else
          option=""
        fi
      done
    elif [ "$type" = "radio" -o "$type" = "select" ];then
      option=required
    fi
  
    # dump add_key
    echo "name=\"${add_key}\"" > ${tmp_dir}/col${count}
    echo "label=\"${add_key_label}\"" >> ${tmp_dir}/col${count}
    echo "type=\"${type}\"" >> ${tmp_dir}/col${count}

    if [ "$type" = "select" -o "$type" = "radio" ];then
      echo "params=\"${params}\"" >> ${tmp_dir}/col${count}
    fi

    if [ "$type" = "pdls" ];then
      echo "pdlsbox=\"${pdlsbox}\"" >> ${tmp_dir}/col${count}
    fi

    echo "option=\"${option}\"" >> ${tmp_dir}/col${count}
    

    echo -n "Add more columns to the databox? (yes | no) : "
    read add_col_answer 
    while [ ! "$add_col_answer" = "yes" -a ! "$add_col_answer" = "no" ]
    do
      echo "please input yes or no" 

      if [ "$bat_flag" = "yes" ];then
        echo "# col${count} additional check error -> failed"
        rm -rf $tmp_dir
        exit 1
      fi

      echo -n "Add more columns to the databox? (yes | no): "
      read add_col_answer 
    done
      
    ((count += 1))  
  done

  clear
  echo "The databox will be generated in the following order. Please check it." 
  echo "-----------------------------------------------------------------"
  echo ""
  echo "Databox Name:$databox"

  count=1
  for column in $(ls ${tmp_dir}/col* | xargs basename -a)
  do
    if [ "$column" = "col1" ];then
      echo "#primary_key"
    else
      echo "#key(col${count})"
    fi
    cat ${tmp_dir}/${column} 
    echo ""
    ((count += 1))  
  done

  echo "-----------------------------------------------------------------"

  echo -n "Is that OK? (yes | no): "
  read fin_answer
  while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
  do
    echo "please input yes or no"

    if [ "$bat_flag" = "yes" ];then
      echo "# final check error -> failed"
      rm -rf $tmp_dir
      exit 1
    fi

    echo -n "Is it OK to generate the databox? (yes | no): "
    read fin_answer
  done

  if [ "$fin_answer" = "yes" ];then
    # cp, chmod, touch
    mkdir ${ROOT}/databox/${databox}
    mkdir ${ROOT}/databox/${databox}/log
    mkdir ${ROOT}/databox/${databox}/data
    touch ${ROOT}/databox/${databox}/index
    touch ${ROOT}/databox/${databox}/hashchain
    mkdir ${ROOT}/databox/${databox}/file
    touch ${ROOT}/databox/${databox}/log.dump
    chown -R small-shell:small-shell ${ROOT}/databox/${databox}
    chmod 700 ${ROOT}/databox/${databox}/data
    chmod 700 ${ROOT}/databox/${databox}/file
    chmod 700 ${ROOT}/databox/${databox}/log
    chmod 700 ${ROOT}/databox/${databox}/index
    chmod 700 ${ROOT}/databox/${databox}/hashchain
    chmod 700 ${ROOT}/databox/${databox}/log.dump
   
    mkdir ${ROOT}/databox/${databox}/def
    cp ${tmp_dir}/* ${ROOT}/databox/${databox}/def/
    rm -f ${ROOT}/databox/${databox}/def/databox
    chmod 755 ${ROOT}/databox/${databox}/def/*
    chown -R small-shell:small-shell ${ROOT}/databox/${databox}/def

    echo "databox:$databox has been successfully created"
  else
    echo "Plese try again from beginning, #gen -databox"
    rm -rf $tmp_dir
    exit 1
  fi
fi

# ADD COLUMN TO DATABOX
if [ "$param" = "-addcol" ];then

  # start dialog
  echo -n "Databox Name: "
  read databox

  ls ${ROOT}/databox/${databox} >/dev/null 2>&1
  if [ $? -eq 0 ];then
    existing_chk_result=existing
  else
    existing_chk_result=""
  fi

  while [ "$existing_chk_result" = "" -o ! "$databox" ]
  do

    if [ ! "$existing_chk_result" = "existing" ];then
      echo "error: databox ${databox} is not existing, please try again"
    fi
    echo -n "Databox Name: "
    read databox

    ls ${ROOT}/databox/${databox} >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    else
      existing_chk_result=""
    fi

  done
  echo "$databox" > ${tmp_dir}/databox
  add_col_answer=yes
  
  count=$(ls ${ROOT}/databox/${databox}/def/col* | wc -l | tr -d " ")
  ((count += 1))

  while [ "$add_col_answer" = "yes" ]
  do
    clear
    echo -n "key(col${count}) name: "
    read add_key
    reserved_chk_result=$(echo "$add_key" | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data")

    existing_chk_result=""
    grep "name=\"${add_key}\"" ${tmp_dir}/col* >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    fi

    grep "name=\"${add_key}\"" ${ROOT}/databox/${databox}/def/col* >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    fi

    eval $add_key=test
    load_chk=$?
    meta_chk_result=$(echo "$add_key" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

    while [ "$existing_chk_result" = "existing" -o "$reserved_chk_result" -o "$meta_chk_result" -o ! "$load_chk" -eq 0 ]
    do

      if [ "$reserved_chk_result" ];then
        echo "error: you can't use {input temp binary_file params} as key, because these are reserved"
      fi

      if [ "$existing_chk_result" = "existing" ];then
        echo "error: key_name is already defined, please try again"
      fi

      if [ ! "$load_chk" -eq  0 ];then
        echo "error: key load is failed, it must be  ascii text and you can't use meta charactor or number space, please try again"
      fi

      if [ "$meta_chk_result"  ];then
        echo "error: key must be  ascii text and you can't use meta charactor or number space, please try again"
      fi

      echo -n "key(col${count}) name: "
      read add_key
      reserved_chk_result=$(echo "$add_key" | grep -e "input" -e "temp" -e "binary_file" -e "params" -e "binary.data")

      existing_chk_result=""
      grep "name=\"${add_key}\"" ${tmp_dir}/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        existing_chk_result=existing
      fi

      grep "name=\"${add_key}\"" ${ROOT}/databox/${databox}/def/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        existing_chk_result=existing
      fi
      
      eval $add_key=test >/dev/null 2>&1
      load_chk=$?
      meta_chk_result=$(echo "$add_key" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
      -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

    done

    echo -n "Key (col${count}) Label: "
    read add_key_label
    char_chk_result=$(charset_check "$add_key_label")

    while [ "$char_chk_result" = "ERROR" ]
    do
      echo "error: key label charset seems wrong, please use UTF-8 as charset"
      echo -n "add_key_label: "
      read add_key_label
      char_chk_result=$(charset_check "$add_key_label")
    done

    # escape meta character
    add_key_label=$(echo "$add_key_label" | $SED "s/\"//g")

    echo -n "Data Type (text | select | radio | checkbox | email | num | tel | date | date-time | url | textarea | file | pdls | mls): "
    read type
    data_chk_result=$(echo "$type" | grep -e "text" -e "select" -e "radio" -e "checkbox" \
     -e "email" -e "date"  -e "date-time" -e "num" -e "tel"  -e "url" -e "textarea" -e "file" -e "pdls" -e "mls")

    if [ "$type" = "file" ];then
      grep "type=\"file\"" ${ROOT}/databox/${databox}/def/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        data_chk_result=""
        data_chk_flg="file"
      fi
      grep "type=\"file\"" ${tmp_dir}/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        data_chk_result=""
        data_chk_flg="file"
      fi
    fi

    while [ ! "$data_chk_result" ]
    do
      echo "data type must be wrong, please try again"
      if [ "$data_chk_flg" = "file" ];then
        echo "1 dataset could have only 1 file, please do not add file again"
      fi

      echo -n "Data Type (text | select | radio | checkbox | email | num | tel | date | date-time | url | textarea | file | pdls | mls): "
      read type
      data_chk_result=$(echo "$type" | grep -e "text" -e "select" -e "radio" -e "checkbox" \
       -e "email" -e "date"  -e "date-time" -e "num" -e "tel"  -e "url" -e "textarea" -e "file" -e "pdls" -e "mls")

      data_chk_flg=""
      if [ "$type" = "file" ];then
        grep "type=\"file\"" ${ROOT}/databox/${databox}/def/col* >/dev/null 2>&1
        if [ $? -eq 0 ];then
          data_chk_result=""
          data_chk_flg="file"
        fi
        grep "type=\"file\"" ${tmp_dir}/col* >/dev/null 2>&1
        if [ $? -eq 0 ];then
          data_chk_result=""
          data_chk_flg="file"
        fi
      fi

    done
    
    if [ "$type" = "select" -o "$type" = "radio" ];then
      echo -n "Please list the values, separated by commas: "
      read params
      char_chk_result=$(charset_check "$params")
      while [ "$char_chk_result" = "ERROR" ]
      do
        echo "It seems invalid charactor is included, please try again."
        echo -n "values: "
        read params
        char_chk_result=$(charset_check "$params")
      done
    fi

    if [ "$type" = "select" -o "$type" = "radio" ];then
      separator_chk=$(echo "$params" | grep ,)
      while [ ! "$separator_chk" ]
      do
        echo "There is no separator(comma), please list the values using comma \",\""
        echo -n "values: "
        read params
        separator_chk=$(echo "$params" | grep ,)
      done
    fi

    if [ "$type" = "num" ];then
      type=number
    fi

    if [ "$type" = "date-time" ];then
      type="datetime-local"
    fi

    if [ "$type" = "pdls" ];then
      echo -n "please input databox name for making pdls(primary value data list): "
      read pdlsbox
      while [ "$pdlsbox" -a ! -d ${ROOT}/databox/${pdlsbox} ]
      do
        echo -n "databox seems wrong, please try again: "
        read pdlsbox
      done     
    fi

    if [ ! "$type" = "file" -a ! "$type" = "checkbox" -a ! "$type" = "radio" -a ! "$type" = "select" ];then
      echo -n "Set this as required? (yes | no): "
      read option_answer
      if [ "$option_answer" = "yes" ];then
        option=required
      else
        option=""
      fi

      while [ ! "$option_answer" = "yes" -a ! "$option_answer" = "no" ]
      do
        echo "please input yes or no"
        echo -n "Set this as required? (yes | no): "
        read option_answer
        if [ "$option_answer" = "yes" ];then
          option=required
        else
          option=""
        fi
      done
    elif [ "$type" = "radio" -o "$type" = "select" ];then
      option=required
    fi

    # dump add_key
    echo "name=\"${add_key}\"" > ${tmp_dir}/col${count}
    echo "label=\"${add_key_label}\"" >> ${tmp_dir}/col${count}
    echo "type=\"${type}\"" >> ${tmp_dir}/col${count}

    if [ "$type" = "select" -o "$type" = "radio" ];then
      echo "params=\"${params}\"" >> ${tmp_dir}/col${count}
    fi

    if [ "$type" = "pdls" ];then
      echo "pdlsbox=\"${pdlsbox}\"" >> ${tmp_dir}/col${count}
    fi

    echo "option=\"${option}\"" >> ${tmp_dir}/col${count}

    echo -n "Add more columns to the databox? (yes | no) : "
    read add_col_answer
    while [ ! "$add_col_answer" = "yes" -a ! "$add_col_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Add more columns to the databox? (yes | no): "
      read add_col_answer
    done
    ((count += 1))
  done

  clear
  echo "The databox will be updated in the following order. Please check it."
  echo "-----------------------------------------------------------------"
  echo ""
  echo "Databox Name:$databox"
  echo "+addcol"
  echo ""

  count=$(ls ${ROOT}/databox/${databox}/def/col* | wc -l | tr -d " ")
  ((count += 1))
  
  for column in $(ls ${tmp_dir}/col* | xargs basename -a)
  do
    echo "#key(col${count})"
    cat ${tmp_dir}/${column}
    echo ""
    ((count += 1))
  done

  echo "-----------------------------------------------------------------"

  echo -n "Is that OK? (yes | no): "
  read fin_answer
  while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
  do
    echo "please input yes or no"
    echo -n "Is it OK to add column to the databox? (yes | no): "
    read fin_answer
  done

  if [ "$fin_answer" = "yes" ];then
    cp ${tmp_dir}/* ${ROOT}/databox/${databox}/def/
    rm -f ${ROOT}/databox/${databox}/def/databox
    chmod 755 ${ROOT}/databox/${databox}/def/*
    chown -R small-shell:small-shell ${ROOT}/databox/${databox}/def
    
    echo "The databox definition has been successfully updated"

    # rebuild index
    keys=$(grep "name=" ${tmp_dir}/col* | sort -V | xargs basename -a | $AWK -F "=" '{print $2}' | $SED "s/\"//g" | $SED -z "s/\n/,/g" | $SED "s/,$//g")
    ${ROOT}/adm/rebuild $databox $keys addcol
  else
    echo "Plese try again from beginning, #gen -addcol"
    rm -rf $tmp_dir
    exit 1
  fi
fi

# DEL COLUMN FROM DATABOX
if [ "$param" = "-delcol" ];then

  # start dialog
  echo -n "Databox Name: "
  read databox

  ls ${ROOT}/databox/${databox} >/dev/null 2>&1
  if [ $? -eq 0 ];then
    existing_chk_result=existing
  else
    existing_chk_result=""
  fi

  while [ "$existing_chk_result" = "" -o ! "$databox" ]
  do

    if [ ! "$existing_chk_result" = "existing" ];then
      echo "error: databox ${databox} is not existing, please try again"
    fi
    echo -n "Databox Name: "
    read databox

    ls ${ROOT}/databox/${databox} >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    else
      existing_chk_result=""
    fi

  done
  del_col_answer=yes

  count=$(ls ${ROOT}/databox/${databox}/def/col* | wc -l | tr -d " ")
  ((count += 1))

  while [ "$del_col_answer" = "yes" ]
  do
    clear
    echo -n "column's key name: "
    read del_key

    grep "name=\"${del_key}\"" ${ROOT}/databox/${databox}/def/col* >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result1=existing
    else
      existing_chk_result1=""
    fi

    ls  ${tmp_dir}/${del_key} >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result2=existing
    else
      existing_chk_result2=""
    fi

    grep "name=\"${del_key}\"" ${ROOT}/databox/${databox}/def/col1 >/dev/null 2>&1
    if [ $? -eq 0 ];then
      primary_key_chk_result=yes
    else
      primary_key_chk_result=no
    fi

    while [ "$existing_chk_result1" = "" -o "$existing_chk_result2" = "existing" -o "$primary_key_chk_result" = "yes" ]
    do
 
      if [ "$existing_chk_result1" = "" ];then
        echo "error: key_name is not existing, please try again"
      fi

      if [ "$existing_chk_result2" = "existing" ];then
        echo "error: you can not delete same key"
      fi

      if [ "$primary_key_chk_result" = "yes" ];then
        echo "error: primary_key(col1) can not be deleted"
      fi

      echo -n "Column's Key Name: "
      read del_key
      
      grep "name=\"${del_key}\"" ${ROOT}/databox/${databox}/def/col* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        existing_chk_result1=existing
      else
        existing_chk_result1=""
      fi

      ls  ${tmp_dir}/${del_key} >/dev/null 2>&1
      if [ $? -eq 0 ];then
        existing_chk_result2=existing
      else
        existing_chk_result2=""
      fi

      grep "name=\"${del_key}\"" ${ROOT}/databox/${databox}/def/col1 >/dev/null 2>&1
      if [ $? -eq 0 ];then
        primary_key_chk_result=yes
      else
        primary_key_chk_result=no
      fi

    done


    # dump del_key
    touch ${tmp_dir}/${del_key}
 
    echo -n "Delete more columns from the databox? (yes | no) : "
    read del_col_answer
    while [ ! "$del_col_answer" = "yes" -a ! "$del_col_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Delete more columns from the databox? (yes | no): "
      read del_col_answer
    done

    ((count += 1))
  done

  clear
  echo "The daatabox will be updated in the following order. Please check it."
  echo "-----------------------------------------------------------------"
  echo ""
  echo "Databox Name:$databox"
  echo "-delcol"
  echo ""

  for key in $(ls ${tmp_dir}/* | xargs basename -a)
  do
    echo "Key name:$key"
  done

  echo ""
  echo "-----------------------------------------------------------------"

  echo -n "Is that OK? (yes | no): "
  read fin_answer
  while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
  do
    echo "please input yes or no"
    echo -n "Is it OK to generate the databox? (yes | no): "
    read fin_answer
  done

  if [ "$fin_answer" = "yes" ];then
  
    for target_key in $(ls $tmp_dir | xargs basename -a)
    do
      col_name=$(grep -l "name=\"${target_key}\"" ${ROOT}/databox/${databox}/def/col* | xargs basename -a)

      if [ ! -f ${ROOT}/databox/${databox}/def/_${col_name} ];then
        mv ${ROOT}/databox/${databox}/def/${col_name} ${ROOT}/databox/${databox}/def/_${col_name}
      else
        duplicated=${ROOT}/databox/${databox}/def/_${col_name}.duplicated.$RANDOM
        if [ ! -f "$duplicated" ];then
          mv ${ROOT}/databox/${databox}/def/${col_name} ${ROOT}/databox/${databox}/def/_${col_name}.duplicated.$RANDOM
        else
          echo "error: failed to mv def file of $key"
          rm -rf $tmp_dir
          exit 1
        fi
      fi
      
      count=1
      for column in $(ls ${ROOT}/databox/${databox}/def/col* | sort -V | xargs basename -a)
      do
        if [ ! "$column" = "col${count}" ];then
          mv ${ROOT}/databox/${databox}/def/${column}  ${ROOT}/databox/${databox}/def/col${count}
        fi
       ((count += 1))
      done
      
    done
    
    chmod 755 ${ROOT}/databox/${databox}/def/*
    chown -R small-shell:small-shell ${ROOT}/databox/${databox}/def
    echo "The databox definition has been successfully updated"

    # rebuild index
    keys=$(ls $tmp_dir | sort -V | xargs basename -a | $SED "s/ /,/g" | $SED -z "s/\n/,/g" | $SED "s/,$//g")
    ${ROOT}/adm/rebuild $databox $keys delcol
  else
    echo "Plese try again from beginning, #gen -delcol"
    rm -rf $tmp_dir
    exit 1
  fi
fi

# GENERATE App
if [ "$param" = "-app" ];then

  # env check
  selinux_chk=$(sestatus 2>/dev/null | grep enforcing) 
  if [ "$selinux_chk" ];then
    echo "warn: SE Linux is enforcing, you can't use app shell"
    echo "please change SE linux from enforcing to permissive or disabled"
    rm -rf $tmp_dir
    exit 1
  fi

  if [ -f ${ROOT}/web/base ];then
    replica_chk=$(grep ^cluster_base_url= ${ROOT}/web/base)
    if [ "$replica_chk" ];then
      echo "warn: you must purge replication first. please execute \"${ROOT}/util/scripts/mkrep.sh purge\""
      rm -rf $tmp_dir
      exit 1
    fi
  fi

  # start dialog
  echo -n "Type of Apo (1.BASE | 2.FORM | 3.CUSTOM): "
  read apptype 
  while [ ! "$apptype" = "1"  -a  ! "$apptype" = "2" -a ! "$apptype" = "3" ]
  do
    echo -n "please input number (1.BASE | 2.FORM | 3.CUSTOM) : "
    read apptype
  done

  if [ "$apptype" = "1" ];then
    apptype="1.BASE"

    echo -n "Type of Server (1.small-shell Web srv | 2.other Web srv): "
    read srv_type
    while [ ! "$srv_type" = "1"  -a  ! "$srv_type" = "2" ]
    do
      echo -n "pleasee input number (1.small-shell Web srv | 2.other Web srv): "
      read srv_type
    done

    if [ "$srv_type" = 1 ];then
      srv_type=default
      www=/var/www
      cgi_dir=/var/www/cgi-bin
      cgi_usr=small-shell
      which node > /dev/null 2>&1
      if [ ! $? -eq 0 ];then
        echo "error: please install node.js beforehand to use small-shell default server"
        rm -rf $tmp_dir
        exit 1
      fi
    else
      srv_type=other
    fi


    if [ "$srv_type" = "other" ];then
      if [ ! "$mac_chk" ];then
        echo -n "Root directory of web (/var/www): "
      else
        echo -n "Root directory of web (/Library/WebServer): "
      fi
      read www
      www=$(echo "$www" | $SED "s/\/$//g")

      if [ ! "$www" ];then
        if [ ! "$mac_chk" ];then
          www=/var/www
        else
          www=/Library/WebServer
        fi
      fi
      www=$(echo "$www" | $SED "s/\/$//g")

      while [ ! -d $www ]
      do
        echo "error: $www is not existing, please set root directory for Web App"
        echo -n "www directory: "
        read www
        if [ ! "$www" ];then
          www=/var/www
        fi
        www=$(echo "$www" | $SED "s/\/$//g")
      done

      www=$(echo "$www" | $SED "s/\/$//g")

      if [ -f /etc/redhat-release ];then
        # load directory for almalinux, centOS stream, RHEL 
        cgi_candidate=/var/www/cgi-bin
        static_candidate=/var/www/html
      else
        if [ ! "$mac_chk" ];then
          # load directory for MacOS
          cgi_candidate=/usr/lib/cgi-bin
          static_candidate=/var/www/html
        else
          # load directory mainly for Ubuntu 
          cgi_candidate=/Library/WebServer/CGI-Executables
          static_candidate=/Library/WebServer/Documents
        fi
      fi

      echo -n "CGI directory ($cgi_candidate): "
      read cgi_dir
      cgi_dir=$(echo "$cgi_dir" | $SED "s/\/$//g")

      if [ ! "$cgi_dir" ];then
        cgi_dir=$cgi_candidate
      fi
      cgi_dir=$(echo "$cgi_dir" | $SED "s/\/$//g")

      while [ "$cgi_dir" = "$www" -o ! -d $cgi_dir ]
      do
        if [ ! -d $cgi_dir ];then
          echo "error: $cgi_dir is not existing, please create CGI directory and then try again"
        elif [ "$cgi_dir" = "$www" ];then
          echo "error: CGI dir:$cgi_dir must be different directory of WWW dir:$www"
        fi
        echo -n "CGI directory: "
        read cgi_dir
        cgi_dir=$(echo "$cgi_dir" | $SED "s/\/$//g")
      done

      echo -n "Static page directory ($static_candidate): "
      read static_dir
      static_dir=$(echo "$static_dir" | $SED "s/\/$//g")

      if [ ! "$static_dir" ];then
        static_dir=$static_candidate
      fi
      static_dir=$(echo "$static_dir" | $SED "s/\/$//g")

      while [ "$static_dir" = "$www" -o ! -d $static_dir ]
      do
        if [ ! -d $static_dir ];then
          echo "error: $static_dir is not existing, please try again"
        elif [ "$static_dir" = "$www" ];then
          echo "error: Static dir:$static_dir must be different directory of WWW dir:$www"
        fi
        echo -n "Static page directory: "
        read static_dir
        static_dir=$(echo "$static_dir" | $SED "s/\/$//g")
      done


      echo -n "Web Server Process Owner (e.g. www-data): "
      read cgi_usr

      while [ ! "$cgi_usr" ]
      do
        echo -n "please set web server process owner: "
        read cgi_usr
      done

      usr_chk_result=$(grep $cgi_usr /etc/passwd)
      sudo_chk_result=$(grep $cgi_usr /etc/sudoers | grep small-shell | grep NOPASSWD)

      while [ ! "$usr_chk_result" -o ! "$sudo_chk_result" ]
      do
        if [ ! "$usr_chk_result" ];then
          echo "error: it seems user name is wrong"
        else
          echo "error: please add sudoer setting for $cgi_usr"
        fi
        echo -n "Web Server Process Owner: "
        read cgi_usr
        usr_chk_result=$(grep $cgi_usr /etc/passwd)
        sudo_chk_result=$(grep $cgi_usr /etc/sudoers | grep small-shell | grep NOPASSWD)
      done
    fi

    echo -n "Protocol (http | https): "
    read protocol

    while [ ! "$protocol" = "http" -a ! "$protocol" = "https" ]
    do
      echo "error: please set http or https as protocol"
      echo -n "Protocol (http | https): "
      read protocol
    done

    if [ "$protocol" = "https" -a "$srv_type" = "default" ];then

     if [ -f ${ROOT}/web/base ];then
        reverse_proxy=$(cat ${ROOT}/web/base | grep reverse_proxy= | $SED "s/reverse_proxy=//g" | $SED "s/\"//g")  
        if [ "$reverse_proxy" = "yes" ];then
          echo -n "Continue to use automation setting of ssl cert deployement ? (yes | no): "
          read use_existing_cert 
          while [ ! "$use_existing_cert" = "yes" -a ! "$use_existing_cert" = "no" ]
          do
            echo "please input yes or no"
            echo -n "Continue to use automation setting of ssl cert deployement ? (yes | no): "
            read use_existing_cert
          done
        fi
        retain_ssl_auto=$use_existing_cert
      fi

      if [ ! "$use_existing_cert" ];then
        if [ -f ${www}/app/cert.pem -a -f ${www}/app/privatekey.pem ];then
          echo -n "Do you want to use existing cert and key? (yes | no): "
          read use_existing_cert 
          while [ ! "$use_existing_cert" = "yes" -a ! "$use_existing_cert" = "no" ]
          do
            echo "please input yes or no"
            echo -n "Do you want to use existing cert and key? (yes | no): "
            read use_existing_cert
          done
        fi
      fi
      
      if [ "$use_existing_cert" = "yes" ];then
        echo "Base App will be upgraded and restarted using exising cert & key, please be aware."
        server=$(cat ${ROOT}/web/base | grep server= | $SED "s/server=//g" | $SED "s/\"//g")  
        sleep 2
      fi

      if [ "$use_existing_cert" = "no" -o ! "$use_existing_cert" ];then
        if [ "$use_existing_cert" = "no" ];then
          echo "ok, let's update cert and key. Base App will be upgraded and restarted, please be aware."
        fi
        echo -n "ssl cert path : "
        read ssl_cert

        while [ ! -f $ssl_cert ]
        do
          echo -n "$cert is not existing, please try to input cert path again : "
          read ssl_cert
        done

        echo -n "ssl privare key path : "
        read private_key

        while [ ! -f $private_key ]
        do
          echo -n "$private_key is not existing, please try to input cert path again : "
          read private_key
        done

        echo -n "Do you need to use chain certificate? (yes | no): "
        read chain_answer
        while [ ! "$chain_answer" = "yes" -a ! "$chain_answer" = "no" ]
        do
          echo "please input yes or no"
          echo -n "Do you need chain certificate? (yes | no): "
          read chain_answer
        done

        if [ "$chain_answer" = "yes" ];then
          echo -n "chain cert path : "
          read chain_cert

          while [ ! -f $chain_cert ]
          do
            echo -n "$chain_cert is not existing, please try to input cert path again : "
            read chain_cert
          done
        fi

      fi

    fi

    # command check for cgi
    (cd ${ROOT}/tmp && sudo -u small-shell echo "$HOME" >/dev/null 2>&1)
    if [ ! $? -eq 0 ];then
      echo "error: please add small-shell as linux user"
      rm -rf $tmp_dir
      exit 1
    fi

    if [ "$protocol" = "http" -o "$use_existing_cert" = "no" -o ! "$server" ];then
      echo -n "Web Server FQDN or IP addr (e.g. 192.168.10.1): "
      read server

      ascii_chk_result=$(ascii_check $server)
      meta_chk_result=$(echo "$server" | grep -e " " -e ","  -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\"  -e "/" \
      -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

      while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" -o ! "$server" ]
      do
        if [ ! "$server" ];then
          echo "error: please input FQDN or IP addr of web server"
        else
          echo "error: server must be ascii text and you can't use meta charactor including space, please try again"
        fi
        echo -n "Web server: "
        read server
        ascii_chk_result=$(ascii_check $server)
        meta_chk_result=$(echo "$server" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\"  -e "/" \
        -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")
      done

      if [[ $server == *:* ]];then
        server="[${server}]"
      fi
  
    fi

    base_url="${protocol}://${server}/cgi-bin/"
    static_url="${protocol}://${server}/"

    if [ "$srv_type" = "other" ];then
      echo -n "CGI base URL for Web App is ${base_url}, is it OK? (yes | no): "
      read base_url_answer

      while [ ! "$base_url_answer" = "yes" -a ! "$base_url_answer" = "no" ]
      do
        echo "please input yes or no"
        echo -n "Is it OK to use $base_url as CGI base URL for Web App? (yes | no): "
        read base_url_answer
      done

      if [ "$base_url_answer" = "no" ];then

        echo -n "please input CGI base url that defined at web server : "
        read base_url
        ascii_chk_result=$(ascii_check $base_url)
        meta_chk_result=$(echo "$base_url" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" \
        -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

        slash_chk=$(echo "$base_url" | grep \/$)
        if [ ! "$slash_chk" ];then
          base_url=$(echo "$base_url" | $SED "s/$/\//g")
        fi

        while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" -o ! "$base_url" ]
        do
          if [ ! "$base_url" ];then
            echo "error: please input base url"
          else
            echo "error: base url must be ascii text and you can't use meta charactor including space, please try again"
          fi
          echo -n "CGI base url: "
          read base_url
          ascii_chk_result=$(ascii_check $base_url)
          meta_chk_result=$(echo "$server" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" \
          -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \|)
        done
 
      fi
    fi

    clear

    echo "-----------------------------------------------------------------"
    echo "App Type: $apptype"
    echo "Srv Type: $srv_type"
    echo "Protocol: $protocol"

    if [ "$srv_type" = "other" ];then
      echo "Web Server Process Owner: $cgi_usr"
      echo "Root Directory: $www"
      echo "CGI Directory: $cgi_dir"
      echo "CGI base URL: $base_url"
      echo "Static Page Directory: $static_dir"
    fi

    echo "Server: $server"
    echo "Access URL: ${static_url}base"
    echo "-----------------------------------------------------------------"

    echo -n "Is that OK? (yes | no): "
    read fin_answer
    while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Is it OK to generate the app? (yes | no): "
      read fin_answer
    done

    if [ "$fin_answer" = "yes" ];then
       
      if [ -f ${ROOT}/web/base ];then
        upgrade=yes
        api_authkey=$(cat ${ROOT}/web/base | grep api_authkey | $SED "s/api_authkey=//g" | $SED "s/\"//g") 
      fi

      # gen base info
      if [ "$srv_type" = "default" ];then
        static_dir=/var/www/html
      fi
      echo "protocol=\"${protocol}\"" > ${ROOT}/web/base
      echo "server=\"${server}\"" >> ${ROOT}/web/base
      echo "srv_type=\"${srv_type}\"" >> ${ROOT}/web/base
      echo "cgi_usr=\"${cgi_usr}\"" >> ${ROOT}/web/base
      echo "www=\"${www}\"" >> ${ROOT}/web/base
      echo "cgi_dir=\"${cgi_dir}\"" >> ${ROOT}/web/base
      echo "static_dir=\"${static_dir}\"" >> ${ROOT}/web/base
      echo "base_url=\"${base_url}\"" >> ${ROOT}/web/base
      echo "static_url=\"${static_url}\"" >> ${ROOT}/web/base
      if [ "$reverse_proxy" = "yes" ];then
        echo "reverse_proxy=\"yes\"" >> ${ROOT}/web/base
      fi
      chown small-shell:small-shell ${ROOT}/web/base
      chmod 700 ${ROOT}/web/base

      # deploy cgi to cgi-dir changing path etc
      bindir="${www}/bin"
      def_dir="${www}/def"
      cgitmp="${www}/tmp"
      
      if [ "$srv_type" = "default" ];then

        if [ ! -d ${www}/app ];then
          mkdir -p ${www}/app
          mkdir ${www}/log
          if [ ! -d $cgi_dir ];then
            mkdir -p $cgi_dir
          fi
          if [ ! -d ${www}/html ];then
            mkdir ${www}/html
          fi
          chown $cgi_usr:$cgi_usr ${www}/cgi-bin
          chown $cgi_usr:$cgi_usr ${www}/log
          chown $cgi_usr:$cgi_usr ${www}/app
          chown $cgi_usr:$cgi_usr ${www}/html
        fi

        if [ "$protocol" = "https" ];then
          if [ "$use_existing_cert" = "no" -o ! "$use_existing_cert" ];then
            cp $ssl_cert ${www}/app/cert.pem
            cp $private_key ${www}/app/privatekey.pem
            chown small-shell:small-shell ${www}/app/privatekey.pem
            chown small-shell:small-shell ${www}/app/cert.pem
            chmod 600 ${www}/app/privatekey.pem
            if [ "$chain_cert" ];then
              cp $chain_cert ${www}/app/chain.pem
              chown small-shell:small-shell ${www}/app/chain.pem
            fi
          fi
        fi

        if [ "$protocol" = "http" ];then
           port=80
        else
           port=443
        fi

        node_version=$(node --version | $SED "s/v//g" | $AWK -F "." '{print $1}')
        if [ "$node_version" -ge 18 ];then
          (cd ${www}/app;npm init -y;npm install express@5) 
	else
          (cd ${www}/app;npm init -y;npm install express@4) 
	fi

        # handle reverse proxy setting
        if [ "$reverse_proxy" = "yes" -a "$retain_ssl_auto" = "yes" ];then
          # overwrite params
          port=8080
          protocol=http
        elif [ "$reverse_proxy" = "yes" -a "$retain_ssl_auto" = "no" ];then
          systemctl stop nginx
          systemctl disable nginx
          reverse_proxy=""
          (cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/e-cron disable.ssl_auto)
        else
          nginx_chk=$(ps -ef | grep nginx | grep -v grep)
          if [ "$nginx_chk" ];then
            if [ ! "$mac_chk" ];then
              systemctl stop nginx
              systemctl disable nginx
              if [ ! $? -eq 0 ];then
                echo "error: nginx can not be stopped"
                exit 1 
              fi
            fi
          fi
        fi

        # generate index.js for upper version of v16        
	if [ "$node_version" -ge 18 ];then
	   any_routing="/{*any}"
	else
	   any_routing="*"
        fi

        if [ "$node_version" -ge 16 ];then
           cluster="cluster.isPrimary"
	else
           cluster="cluster.isMaster"
        fi
          
        if [ "$protocol" = "https" ];then
          if [ ! "$chain_cert" ];then
            cat ${ROOT}/web/src/app/index.js | $SED "s/%%protocol/${protocol}/g" | $SED "s/%%port/${port}/g" \
            | $SED "s#%%sed#${SED}#g" | $SED "s#// https ##g" | $SED "s#/\* forward option start##g" \
            | $SED "s#option end \*/##g" | $SED "s/%%cluster/${cluster}/g" \
	    | $SED "s#%%any_routing#${any_routing}#g" > ${www}/app/index.js
          else
            cat ${ROOT}/web/src/app/index.js | $SED "s/%%protocol/${protocol}/g" | $SED "s/%%port/${port}/g" \
            | $SED "s#%%sed#${SED}#g" | $SED "s#// https ##g" | $SED "s#// https_chain ##g" \
            | $SED "s#/\* forward option start##g" | $SED "s#option end \*/##g"  \
            | $SED "s/%%cluster/${cluster}/g" | $SED "s#%%any_routing#${any_routing}#g" > ${www}/app/index.js
          fi
        else
          cat ${ROOT}/web/src/app/index.js | $SED "s/%%protocol/${protocol}/g" | $SED "s/%%port/${port}/g" \
          | $SED "s#%%sed#${SED}#g" | $SED "s/%%cluster/${cluster}/g" \
	  | $SED "s#%%any_routing#${any_routing}#g" > ${www}/app/index.js
        fi

        NODE=$(which node)
        cat ${ROOT}/web/src/app/app.sh | $SED "s#%%node#${NODE}#g" \
        | $SED "s#%%sed#${SED}#g" > ${www}/app/app.sh
        chmod 755 ${www}/app/app.sh

        if [ ! "$mac_chk" ];then

          apache2_chk=$(ps -ef | grep apache2 | grep -v grep)
          if [ "$apache2_chk" ];then
            systemctl stop apache2
            systemctl disable apache2
          fi

          if [ ! -f /etc/systemd/system/small-shell.service ];then
            cat ${ROOT}/web/src/app/small-shell.service | $SED "s#%%www#${www}#g" \
            > /etc/systemd/system/small-shell.service 
            systemctl enable small-shell.service 
            systemctl start small-shell 
            sleep 2
          else
            systemctl restart small-shell
            enable_chk=$(systemctl is-enabled small-shell)
            if [ "$enable_chk" != "enabled" ];then
               systemctl enable small-shell.service
            fi
            sleep 2
          fi
        else

          httpd_chk=$(launchctl list | grep httpd)
          if [ "$httpd_chk" ];then
            apachectl stop
          fi

          if [ ! -f /Library/LaunchDaemons/org.small-shell.node.plist ];then

            cat ${ROOT}/web/src/app/org.small-shell.node.plist | $SED "s#%%www#${www}#g" \
            > /Library/LaunchDaemons/org.small-shell.node.plist

            cat ${ROOT}/web/src/app/org.small-shell.util.plist | $SED "s#%%www#${www}#g" \
            > /Library/LaunchDaemons/org.small-shell.util.plist

            cat ${ROOT}/web/src/app/util.sh | $SED "s#%%www#${www}#g" \
            > ${www}/app/util.sh
            chmod 755 ${www}/app/util.sh
 
            launchctl load /Library/LaunchDaemons/org.small-shell.node.plist
            launchctl load /Library/LaunchDaemons/org.small-shell.util.plist
            launchctl start org.small-shell.node
            launchctl start org.small-shell.util

          else
            launchctl stop org.small-shell.node
            launchctl start org.small-shell.node
          fi
        fi

      else

        # for other Web srv
        if [ "$mac_chk" ];then

          if [ ! -d ${www}/app ];then
            mkdir -p ${www}/app
          fi

          if [ ! -f /Library/LaunchDaemons/org.small-shell.util.plist ];then
            cat ${ROOT}/web/src/app/org.small-shell.util.plist | $SED "s#%%www#${www}#g" \
            > /Library/LaunchDaemons/org.small-shell.util.plist

            cat ${ROOT}/web/src/app/util.sh | $SED "s#%%www#${www}#g" \
            > ${www}/app/util.sh
            chmod 755 ${www}/app/util.sh

            launchctl load /Library/LaunchDaemons/org.small-shell.util.plist
            launchctl start org.small-shell.util
          fi

        fi

      fi
  
      if [ ! -d $bindir ];then
        mkdir $bindir
      fi

      chown $cgi_usr:$cgi_usr $bindir
      if [ ! $? -eq 0 ];then
        echo "error: failed to create directory for small-shell bin"
      fi
  
      if [ ! -d $def_dir ];then
        mkdir $def_dir
        mkdir ${def_dir}/common_parts
        if [ ! $? -eq 0 ];then
          echo "error: failed to create directory for small-shell def"
        fi
      fi
      chown $cgi_usr:$cgi_usr $def_dir
      chown $cgi_usr:$cgi_usr ${def_dir}/common_parts

      if [ ! $? -eq 0 ];then
        echo "error: failed to create directory for small-shell def"
      fi

      if [ ! -d $cgitmp ];then
        mkdir $cgitmp
      fi
      chown $cgi_usr:$cgi_usr $cgitmp
      if [ ! $? -eq 0 ];then
        echo "error: failed to create directory for small-shell tmp"
      fi

      # gen command API key and URL  
      echo "command_api=\"${base_url}api\"" >> ${ROOT}/web/base
      echo "hub_api=\"${base_url}e-cron\""  >> ${ROOT}/web/base

      user_name=api
      user_id=$(echo "$user_name" | $SHASUM | $AWK '{print $1}')

      if [ -d ${ROOT}/users/${user_id} ];then
        echo "api_authkey=\"${api_authkey}\"" >> ${ROOT}/web/base
      else
        mkdir ${ROOT}/users/${user_id}
        echo "$user_name" > ${ROOT}/users/${user_id}/user_name
        echo "permission=ro" > ${ROOT}/users/${user_id}/.attr.tmp
        cat ${ROOT}/users/${user_id}/.attr.tmp > ${ROOT}/users/${user_id}/attr
        chown small-shell:small-shell ${ROOT}/users/${user_id}/attr

        which openssl  >/dev/null 2>&1
        if [ $? -eq 0 ];then
          hash_gen_key=$(openssl rand -hex 20)
        else
          hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
        fi
        hash=$(echo "${user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}')
        echo "$hash" > ${ROOT}/users/${user_id}/hash
        chown -R small-shell:small-shell ${ROOT}/users/${user_id}
        chmod 700 ${ROOT}/users/${user_id}/hash
        user_key=$(echo "${user_name}:${hash_gen_key}" | $BASE64_ENC)
        echo "api_authkey=\"${user_key}\"" >> ${ROOT}/web/base
      fi

      for src in $(ls ${ROOT}/web/src/cgi-bin | grep -v controller | grep -v tmplt | grep -v auth | xargs basename -a)
      do
        cat ${ROOT}/web/src/cgi-bin/${src} | $SED "s#%%www#${www}#g" > ${cgi_dir}/${src}
        chmod 755 ${cgi_dir}/${src}
      done
      cat ${ROOT}/web/src/cgi-bin/controller | $SED "s#%%www#${www}#g" > ${cgi_dir}/base
      cat ${ROOT}/web/src/cgi-bin/auth | $SED "s#%%www#${www}#g" > ${cgi_dir}/auth.base
      cp ${ROOT}/web/src/lib/base.css $static_dir
      cp ${ROOT}/web/src/lib/simple-calendar.css $static_dir
      cp ${ROOT}/web/src/lib/simple-calendar.js $static_dir
      chmod 755 ${cgi_dir}/base
      chmod 755 ${cgi_dir}/auth.base
      chmod 755 ${static_dir}/base.css
      chmod 755 ${static_dir}/simple-calendar.css
      chmod 755 ${static_dir}/simple-calendar.js

      for src in $(ls ${ROOT}/web/src/bin | grep -v tmplt | xargs basename -a)
      do
        cat ${ROOT}/web/src/bin/${src} | $SED "s#%%www#${www}#g" > ${bindir}/${src}
        chmod 755 ${bindir}/${src}
      done

      if [ -f ${ROOT}/web/.rand ];then
        . ${ROOT}/web/.rand
      else
        rand=$RANDOM
        echo "rand=$rand" > ${ROOT}/web/.rand
        chmod 755 ${ROOT}/web/.rand
        chown small-shell:small-shell ${ROOT}/web/.rand
      fi

      for src in $(ls ${ROOT}/web/src/def | grep -v tmplt | grep -v common_parts | grep -v redirect.html.def | xargs basename -a)
      do
        cat ${ROOT}/web/src/def/${src} | $SED "s/%%rand/${rand}/g" | $SED "s#%%static_url/#${static_url}#g" > ${def_dir}/${src}
        chmod 755 ${def_dir}/${src}
      done

      for src in $(ls ${ROOT}/web/src/def/common_parts | grep -v tmplt | grep -v common_menu_button | xargs basename -a)
      do
        cat ${ROOT}/web/src/def/common_parts/${src}  > ${def_dir}/common_parts/${src}
        chown $cgi_usr:$cgi_usr ${def_dir}/common_parts/${src}
        chmod 755 ${def_dir}/common_parts/${src}
      done
      
      cat ${ROOT}/web/src/def/common_parts/common_menu_button \
      | $SED "s/%%rand/${rand}/g"  >> ${def_dir}/common_parts/common_menu

      cat ${ROOT}/web/src/def/common_parts/common_menu_button \
      | $SED "s/%%rand/${rand}/g"  >> ${def_dir}/common_parts/common_menu_ro 

      cat ${ROOT}/web/src/def/common_parts/common_menu_button \
      | $SED "s/%%rand/${rand}/g"  >> ${def_dir}/common_parts/common_menu_rw

      # standadaize owner of Base App
      chown -R ${cgi_usr}:${cgi_usr} ${cgi_dir}/*
      chown -R ${cgi_usr}:${cgi_usr} ${www}/def/*
      chown -R ${cgi_usr}:${cgi_usr} ${www}/bin/*

      if [ "$srv_type" = "default" ];then
        echo "small_shell_path=$ROOT" > ${def_dir}/.env
        echo "server=\"default\"" >>  ${def_dir}/.env
      else
        echo "small_shell_path=\"sudo -u small-shell ${ROOT}\"" > ${def_dir}/.env
      fi

      if [ ! -d $static_dir ];then
        mkdir $static_dir
      fi
      if [ ! -d ${static_dir}/base ];then
        mkdir ${static_dir}/base
      fi
      cat ${ROOT}/web/src/def/redirect.html.def | $SED "s#%%APPURL#${base_url}auth.base#g" > ${static_dir}/base/index.html
      chmod 755 ${static_dir}/base/index.html
      cat ${ROOT}/.env | grep -v ROOT >> ${def_dir}/.env
      chmod 755 ${def_dir}/.env

      if [ ! "$mac_chk" ];then
        # enable standard jobs
        if [ ! -f ${ROOT}/util/e-cron/def/del_session.def ];then
          (cd $tmp_dir && sudo -u small-shell echo "SCHEDULE:* * * * *" > ${ROOT}/util/e-cron/def/del_session.def)
          (cd $tmp_dir && sudo -u small-shell echo "exec_command=\"${ROOT}/util/scripts/del_session.sh\"" >> ${ROOT}/util/e-cron/def/del_session.def)
          chown small-shell:small-shell ${ROOT}/util/e-cron/def/del_session.def
        fi

        if [ ! -f ${ROOT}/util/e-cron/def/del_util_log.def ];then
          (cd $tmp_dir && sudo -u small-shell echo "SCHEDULE:5 0 * * *" > ${ROOT}/util/e-cron/def/del_util_log.def)
          (cd $tmp_dir && sudo -u small-shell echo "exec_command=\"${ROOT}/util/scripts/del_log.sh\"" >> ${ROOT}/util/e-cron/def/del_util_log.def)
          chown small-shell:small-shell ${ROOT}/util/e-cron/def/del_util_log.def
        fi
 
        (cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/e-cron enable.del_session)
        (cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/e-cron enable.del_util_log)

        if [ "$srv_type" = "default" ];then
          if [ ! -f ${ROOT}/util/e-cron/def/rotate_srv_log.def ];then
            (cd $tmp_dir && sudo -u small-shell echo "SCHEDULE:0 0 * * *" > ${ROOT}/util/e-cron/def/rotate_srv_log.def)
            (cd $tmp_dir && sudo -u small-shell echo "exec_command=\"${ROOT}/util/scripts/rotate_srvlog.sh\"" >> ${ROOT}/util/e-cron/def/rotate_srv_log.def)
            chown small-shell:small-shell ${ROOT}/util/e-cron/def/rotate_srv_log.def
          fi
          (cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/e-cron enable.rotate_srv_log)
        fi
      fi

      ls ${cgi_dir}/../bin/shelltest.sh >/dev/null 2>&1

      if [ ! $? -eq 0 ];then
        (cd $cgi_dir && cd .. && pwd > ${tmp_dir}/.tdir) 
        tdir=$(cat ${tmp_dir}/.tdir)
        clear
        echo "www dir must have relation with CGI dir. Is it OK to make symbolic link on $tdir ?"
        echo "following command will be executed"
        echo "-----------------------------------------------------------------"
        echo "ln -s $bindir ${tdir}/bin"
        echo "ln -s $def_dir ${tdir}/def"
        echo "ln -s $cgitmp ${tdir}/tmp"
        echo "-----------------------------------------------------------------"
        echo -n "(yes | no): "
        read syml_answer
        while [ ! "$syml_answer" = "yes" -a ! "$syml_answer" = "no" ]
        do
          echo "please input yes or no"
          echo -n "Is it OK to make symlink? (yes | no): "
          read syml_answer
        done

        if [ "$syml_answer" = "yes" ];then
          ln -s $bindir ${tdir}/bin
          ln -s $def_dir ${tdir}/def
          ln -s $cgitmp ${tdir}/tmp
        fi
     
      fi

      sleep 6

      if [ "$reverse_proxy" = "yes" -a "$retain_ssl_auto" = "yes" ];then
        test_url=$(echo "$base_url" | $SED "s/https:/http:/g")
      else
        test_url=$base_url
      fi

      get_test=$($CURL -k ${test_url}shelltest.cgi | grep OK)

      if [ "$get_test" ];then
        clear
        if [ ! "$upgrade" = "yes" ];then
          echo "-----------------------------------------------------------------"
          echo "Base App has been successfully generated"
          echo "Access URL: ${static_url}base"
          echo "-----------------------------------------------------------------"
          echo "Please add user using ops command."
          echo "-> sudo ${ROOT}/adm/ops add.usr:\$user"
        else
          echo "Base App has been upgraded. please access to the App using existing key"
        fi
      else
        if [ "$srv_type" = "default" ];then
          echo "error: it seems something is wrong,tried to get ${base_url}shelltest.cgi and it's failed." 
          rm -rf $tmp_dir
          exit 1
        else
          echo "error: it seems something is wrong,tried to get ${base_url}shelltest.cgi and it's failed." 
          echo "please check web server setting and url setting, you should start web server beforehand"
          rm -rf $tmp_dir
          exit 1
        fi
      fi
    else
      echo "please try again from begining #gen -app"
      rm -rf $tmp_dir
      exit 1
    fi
  fi

  if [ "$apptype" = "2" ];then

    if [ ! -f ${ROOT}/web/base ];then
      echo "error: please generate Base App first"
      rm -rf $tmp_dir
      exit 1
    else
     # load web/base
      . ${ROOT}/web/base
    fi

    apptype="2.FORM"
    echo -n "Form Name: "
    read form_name

    while [ "$form_name" = "base" -o "$form_name" = "api" -o "$form_name" = "e-cron" ]
    do
      echo "error: the name $form_name is conflicted with Base App, please try again"
      echo -n "Form Name: "
      read form_name
    done

    ascii_chk_result=$(ascii_check $form_name)
    meta_chk_result=$(echo "$form_name" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e "@" -e ">" -e "<")


    while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" ]
    do
      echo "error: Form name must be ascii text and you can't use meta charactor including space, please try again"
      echo -n "Form Name: "
      read form_name
      ascii_chk_result=$(ascii_check $form_name)
      meta_chk_result=$(echo "$form_name" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
      -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")
    done

    echo -n "Target Databox: "
    read databox

    while [ ! "$databox" -o ! -d ${ROOT}/databox/${databox} ]
    do
      echo "error: databox name seems wrong, please try again"
      echo -n "Target Databox: "
      read databox
    done 

    primary_key=$(cat ${ROOT}/databox/${databox}/def/col1 | grep name= | $SED "s/name=//g"  | $SED "s/\"//g")
    if [ ! "$primary_key" = "hashid" ];then
      echo "error: $databox is not suitable, primary key must be \"hashid\" if you want to use the databox for Form"
      echo "please try again from beginning."
      exit 1
    fi

    echo -n "Description of the Form : "
    read description 

    clear
    datas=$(cat ${ROOT}/databox/${databox}/def/col* | grep name=\" | grep -v $primary_key | $AWK -F "name=" '{print $2}' \
    | $SED "s/\"//g" | $SED -z "s/\n/ | /g" | $SED "s/ | $//g")
    echo -n "Select key that must be in the Form ($datas) : "
    read key
    
    key_chk=$(grep "name=\"${key}\"" ${ROOT}/databox/${databox}/def/col*)

    while [ ! "$key_chk" ]
    do
      echo "error: key name must be wrong"
      echo -n "please try again ($datas): "
      read key
      key_chk=$(grep "name=\"${key}\"" ${ROOT}/databox/${databox}/def/col*)
    done
    keys=$key
    datas=$(echo "$datas" | $SED "s/| $key //g" | $SED "s/^$key | //g" | $SED "s/| $key$//g" | $SED "s/^$key$//g")


    if [ "$datas" ];then
      echo -n "Add more keys to the Form? (yes | no): "
      read add_form_answer
      while [ ! "$add_form_answer" = "yes" -a ! "$add_form_answer" = "no" ]
      do
        echo "please input yes or no"
        echo -n "Add more keys to the Form? (yes | no): "
        read add_form_answer
      done
    else
     add_form_answer="no"
    fi

    while [ "$add_form_answer" = "yes" -a "$datas" ]
    do 
      echo -n "Select additional key that must be in the Form ($datas) : "
      read key
      key_chk=$(grep "name=\"${key}\"" ${ROOT}/databox/${databox}/def/col*)

      while [ ! "$key_chk" ]
      do
        echo "error: key name must be wrong"
        echo -n "please try again ($datas): "
        read key
        key_chk=$(grep "name=\"${key}\"" ${ROOT}/databox/${databox}/def/col*)
      done
      keys="$keys,$key"
      datas=$(echo "$datas" | $SED "s/| $key //g" | $SED "s/^$key | //g" | $SED "s/| $key$//g" | $SED "s/^$key$//g")
  
      if [ "$datas" ];then
        echo -n "Add more keys to the Form? (yes | no): "
        read add_form_answer
        while [ ! "$add_form_answer" = "yes" -a ! "$add_form_answer" = "no" ]
        do
          echo "please input yes or no"
          echo -n "Add more keys to the Form? (yes | no): "
          read add_form_answer
        done
      fi
    done

    # load base info
    . ${ROOT}/web/base
    clear
    echo "The Form will be generated in the following order. Please check it."
    echo "-----------------------------------------------------------------"
    echo ""
    echo "App Type: $apptype"
    echo "Form Name: $form_name"
    echo "Target Databox: $databox"
    echo "Description: $description"
    echo "Included keys: $keys"
    echo "Access URL: ${static_url}${form_name}"
    echo ""
    echo "-----------------------------------------------------------------"
    echo -n "Is that OK? (yes | no): "
    read fin_answer
    while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Is it OK to generate the app? (yes | no): "
      read fin_answer
    done

    if [ "$fin_answer" = "yes" ];then

      app=$form_name
      # careate App user and authkey
      app_user_name=${app}.app
      app_user_id=$(echo "$app_user_name" | $SHASUM | $AWK '{print $1}')

      if [ ! -d ${ROOT}/users/${app}.${app_user_id} ];then
        mkdir ${ROOT}/users/${app}.${app_user_id}
      fi
      echo "$app_user_name" > ${ROOT}/users/${app}.${app_user_id}/user_name
      echo "permission=rw" > ${ROOT}/users/${app}.${app_user_id}/.attr.tmp
      cat ${ROOT}/users/${app}.${app_user_id}/.attr.tmp > ${ROOT}/users/${app}.${app_user_id}/attr
      chown small-shell:small-shell ${ROOT}/users/${app}.${app_user_id}/attr

      which openssl  >/dev/null 2>&1
      if [ $? -eq 0 ];then
        hash_gen_key=$(openssl rand -hex 20)
      else
        hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
      fi

      hash=$(echo "${app}:${app_user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}')
      echo "$hash" > ${ROOT}/users/${app}.${app_user_id}/hash
      chown -R small-shell:small-shell ${ROOT}/users/${app}.${app_user_id}
      chmod 700 ${ROOT}/users/${app}.${app_user_id}/hash
      authkey=$(echo "${app_user_name}:${hash_gen_key}" | $BASE64_ENC)

      # deploy form App
      cat ${ROOT}/web/src/cgi-bin/tmplt_controller_form | $SED "s#%%www#${www}#g" | $SED "s/%%authkey/${authkey}/g" \
      | $SED "s/%%app/${form_name}/g" > ${cgi_dir}/${form_name}
      cp ${ROOT}/web/src/lib/tmplt_type2.css  ${static_dir}/${form_name}.css

      chown $cgi_usr:$cgi_usr ${cgi_dir}/${form_name}*
      chmod 700 ${cgi_dir}/${form_name}*
      chmod 755 ${static_dir}/${form_name}*

      cat ${ROOT}/web/src/bin/tmplt_type2_get.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
      | $SED "s/%%app/${form_name}/g"  | $SED "s/%%keys/${keys}/g" > ${www}/bin/${form_name}_get.sh

      cat ${ROOT}/web/src/bin/tmplt_type2_set.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
      | $SED "s/%%app/${form_name}/g"  | $SED "s/%%keys/${keys}/g" > ${www}/bin/${form_name}_set.sh

      chown $cgi_usr:$cgi_usr ${www}/bin/${form_name}*
      chmod 755 ${www}/bin/${form_name}*

      for src in $(ls ${ROOT}/web/src/def | grep tmplt_type2 | xargs basename -a)
      do
        html_def=$(echo "$src" | $SED "s/tmplt_type2_//g")
        cat ${ROOT}/web/src/def/${src} | $SED "s/%%app/${form_name}/g" | $SED "s/%%description/${description}/g" \
        | $SED "s#%%static_url/#${static_url}#g" | $SED "s/%%databox/${databox}/g" > ${www}/def/${form_name}_${html_def}
        chmod 755 ${www}/def/${form_name}_${html_def}
      done

      if [ ! -d ${www}/html/${form_name} ];then
        mkdir ${www}/html/${form_name}
      fi
      cat ${ROOT}/web/src/def/redirect.html.def | $SED "s#%%APPURL#${base_url}${form_name}#g" > ${www}/html/${form_name}/index.html
      chmod 755 ${www}/html/${form_name}/index.html

      echo "Form is successfully generated"
      ls  ${cgi_dir}/${form_name}
      ls  ${static_dir}/${form_name}.css
      ls  ${www}/bin/${form_name}_*
      ls  ${www}/def/${form_name}_*
    else
      echo "Plese try again from beginning, #gen -app" 
      rm -rf $tmp_dir
      exit 1
    fi

  fi

  if [ "$apptype" = "3" ];then

    if [ ! -f ${ROOT}/web/base ];then
      echo "error: please generate Base App first"
      rm -rf $tmp_dir
      exit 1
    else
      # load web/base
      . ${ROOT}/web/base
    fi

    # load base info
    . ${ROOT}/web/base

    apptype="3.CUSTOM"
    echo -n "App Name: "
    read app

    while [ "$app" = "base" -o "$app" = "api" -o "$app" = "e-cron" ]
    do
      echo "error: the name $app is conflicted with Base App, please try again"
      echo -n "App Name: "
      read app
    done

    parent_app=$(echo "$app" | $AWK -F "@" '{print $2}')
    if [ "$parent_app" ];then
       app=$(echo "$app" | $AWK -F "@" '{print $1}')
      if [ ! -f ${cgi_dir}/${parent_app} ];then
        echo "error: there is no parent app $parent_app"
        exit 1
      fi
      if [ -f ${cgi_dir}/${app} ];then
        echo "error: there is same name app"
        exit 1
      fi
    fi
   
    ascii_chk_result=$(ascii_check $app)
    meta_chk_result=$(echo "$app" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e "@" -e ">" -e "<")

    while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" ]
    do
      echo "error: App name must be ascii text and you can't use meta charactor including space, please try again"
      echo -n "App Name: "
      read app

      parent_app=$(echo "$app" | $AWK -F "@" '{print $2}')
      if [ "$parent_app" ];then
       app=$(echo "$app" | $AWK -F "@" '{print $1}')
        if [ ! -f ${cgi_dir}/${parent_app} ];then
          echo "error: there is no parent app $parent_app"
          exit 1
        fi
        if [ -f ${cgi_dir}/${app} ];then
          echo "error: there is same name app"
          exit 1
        fi
      fi
      ascii_chk_result=$(ascii_check $app)
      meta_chk_result=$(echo "$app" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
      -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")
    done

    if [ ! "$parent_app" ];then
      echo -n "Type of Authentication (1.shared pass | 2.user key | 3.other | 4.none): "
      read auth_method
      while [ ! "$auth_method" = "1"  -a  ! "$auth_method" = "2" -a ! "$auth_method" = "3" -a ! "$auth_method" = "4" ]
      do
        echo -n "please input number (1.shared pass | 2.user key | 3.other | 4.none) : "
        read auth_method
      done
    fi

    if [ "$auth_method" = 1 ];then
      auth_method=shared_pass
      echo -n "Shared Passcode: "
      read shared_pass
      num_value_chk=$(echo "$shared_pass" | $SED "s/[0-9]//g" | $SED "s/-//g")
      value_chk=$(echo "$shared_pass" | $SED -z "s/\n//g")
      while [ "$shared_pass" -a "$num_value_chk" ]
      do
        echo -n "code must be numetric character, please try again: "
        read shared_pass
        num_value_chk=$(echo "$shared_pass" | $SED "s/[0-9]//g" | $SED "s/-//g")
        value_chk=$(echo "$shared_pass" | $SED -z "s/\n//g")
      done
    fi

    if [ "$auth_method" = 2 ];then
      auth_method=key
    fi

    if [ "$auth_method" = 3 ];then
      auth_method=other
    fi

    if [ "$auth_method" = 4 ];then
      auth_method=none
    fi

    if [ ! "$parent_app" ];then
      echo -n "Primary Databox: "
    else
      echo -n "Subapp Databox: "
    fi
    read databox

    if [ ! "$databox" = "null" -a ! "$databox" = "none" ];then
      while [[ ! "$databox" || ! -d ${ROOT}/databox/${databox} ]] && [[ ! "$databox" == "null" && ! "$databox" == "none" ]]
      do
        echo "error: databox name seems wrong, please try again"
        echo -n "Target Databox: "
        read databox
      done
    fi

    clear
    echo "The App will be generated in the following order. Please check it."
    echo "-----------------------------------------------------------------"
    echo ""
    echo "App Type: $apptype"
    echo "App Name: $app"
   
    if [ ! "$parent_app" ];then

      echo "Authentication: $auth_method"

      if [ ! "$auth_method" = "other" ];then
        echo "Access URL: ${static_url}${app}"
      else
        # for adaption of Oauth
        echo "Access URL: ${base_url}auth.${app}"
      fi

      if [ "$auth_method" = "shared_pass" ];then
        echo "Shared Passcode: $shared_pass"
      fi

      echo "Primary Databox: $databox"

    else

      echo "Parent App: $parent_app"
      echo "Sub App Databox: $databox"

    fi

    echo ""
    echo "-----------------------------------------------------------------"
    echo -n "Is that OK? (yes | no): "
    read fin_answer
    while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Is it OK to generate the app? (yes | no): "
      read fin_answer
    done
  
    if [ "$fin_answer" = "yes" ];then

      if [ ! "$parent_app" ];then 

        if [ "$auth_method" = "shared_pass" ];then

          input_type="password"
          placeholder="Passcode"

          # careate app authkey
          app_user_name=${app}.app
          app_user_id=$(echo "$app_user_name" | $SHASUM | $AWK '{print $1}')

          if [ ! -d ${ROOT}/users/${app}.${app_user_id} ];then
            mkdir ${ROOT}/users/${app}.${app_user_id}
          fi
          echo "$app_user_name" > ${ROOT}/users/${app}.${app_user_id}/user_name
          echo "permission=rw" > ${ROOT}/users/${app}.${app_user_id}/.attr.tmp
          cat ${ROOT}/users/${app}.${app_user_id}/.attr.tmp > ${ROOT}/users/${app}.${app_user_id}/attr
          chown small-shell:small-shell ${ROOT}/users/${app}.${app_user_id}/attr

          which openssl  >/dev/null 2>&1
          if [ $? -eq 0 ];then
            hash_gen_key=$(openssl rand -hex 20)
          else
            hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
          fi

          hash=$(echo "${app}:${app_user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}')
          echo "$hash" > ${ROOT}/users/${app}.${app_user_id}/hash
          chown -R small-shell:small-shell ${ROOT}/users/${app}.${app_user_id}
          chmod 700 ${ROOT}/users/${app}.${app_user_id}/hash
          authkey=$(echo "${app_user_name}:${hash_gen_key}" | $BASE64_ENC)


          # store passcode of shared pass App
          echo "$shared_pass" > ${ROOT}/web/${app}.code

          # deploy psscode App
          cat ${ROOT}/web/src/cgi-bin/tmplt_controller | $SED "s#%%www#${www}#g" | $SED "s/%%app/${app}/g" \
          | $SED "s/%%auth/required/g" > ${cgi_dir}/${app}
          chown $cgi_usr:$cgi_usr ${cgi_dir}/${app}
          chmod 700 ${cgi_dir}/${app}

          cat ${ROOT}/web/src/cgi-bin/tmplt_pass_auth | $SED "s#%%www#${www}#g" | $SED "s/%%app/${app}/g" \
          | $SED "s/%%authkey/${authkey}/g" > ${cgi_dir}/auth.${app}
          chown $cgi_usr:$cgi_usr ${cgi_dir}/auth.${app}
          chmod 700 ${cgi_dir}/auth.${app}

          cp ${ROOT}/web/src/lib/tmplt_type3.css ${static_dir}/${app}.css
          chmod 755 ${static_dir}/${app}.css

          cat ${ROOT}/web/src/bin/tmplt_type3_get.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_get.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_set.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_set.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_del.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_del.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_table.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_table.sh

          cat ${ROOT}/web/src/bin/tmplt_log_viewer.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_log_viewer.sh

          cat ${ROOT}/web/src/bin/tmplt_main.sh | $SED "s#%%www#${www}#g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_main.sh

          cat ${ROOT}/web/src/bin/tmplt_page_links.sh | $SED "s#%%www#${www}#g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_page_links.sh

          cat ${ROOT}/web/src/bin/tmplt_dl.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_dl.sh

          chown $cgi_usr:$cgi_usr ${www}/bin/${app}*
          chmod 755 ${www}/bin/${app}*

          for src in $(ls ${ROOT}/web/src/def | grep tmplt | grep -v type2 | grep -v auth | xargs basename -a)
          do
            html_def=$(echo "$src" | $SED "s/tmplt_//g" | $SED "s/type3_//g")
            cat ${ROOT}/web/src/def/${src} | $SED "s/%%app/${app}/g" | $SED "s/%%user/there/g" \
            | $SED "s/%%databox/${databox}/g" | $SED "s#%%static_url/#${static_url}#g" > ${www}/def/${app}_${html_def}
            chmod 755 ${www}/def/${app}_${html_def}
          done

          for src in $(ls ${ROOT}/web/src/def/common_parts | grep tmplt | grep -v common_menu_button | xargs basename -a)
          do
            menu=$(echo "$src" | $SED "s/tmplt_//g" | $SED "s/type3_//g")
            cat ${ROOT}/web/src/def/common_parts/${src} | $SED "s/%%app/${app}/g" | $SED "s/%%databox/${databox}/g" \
            > ${www}/def/common_parts/${app}_${menu}
            chmod 755 ${www}/def/common_parts/${app}_${menu}
          done

          chown $cgi_usr:$cgi_usr ${www}/def/${app}*
          chown $cgi_usr:$cgi_usr ${www}/def/common_parts/${app}*

          . ${ROOT}/web/.rand
          cat ${ROOT}/web/src/def/tmplt_pass_auth_form.html.def | $SED "s/%%input_type/${input_type}/g" \
          | $SED "s/%%placeholder/${placeholder}/g" | $SED "s/%%app/${app}/g" | $SED "s#%%static_url/#${static_url}#g" \
          | $SED "s/%%rand/${rand}/g" > ${www}/def/${app}_auth_form.html.def
          chmod 755 ${www}/def/${app}_auth_form.html.def
          chown $cgi_usr:$cgi_usr ${www}/def/${app}*

          if [ ! -d ${www}/html/${app} ];then
            mkdir ${www}/html/${app}
          fi
          cat ${ROOT}/web/src/def/redirect.html.def | $SED "s#%%APPURL#${base_url}auth.${app}#g" > ${www}/html/${app}/index.html
          chmod 755 ${www}/html/${app}/index.html

        fi

        if [ "$auth_method" = "key" ];then

          # deploy key auth App
          cat ${ROOT}/web/src/cgi-bin/tmplt_controller | $SED "s#%%www#${www}#g" \
          | $SED "s/%%app/${app}/g" | $SED "s/%%auth/required/g" > ${cgi_dir}/${app}
          chown $cgi_usr:$cgi_usr ${cgi_dir}/${app}
          chmod 700 ${cgi_dir}/${app}

          cp ${ROOT}/web/src/lib/tmplt_type3.css ${static_dir}/${app}.css
          chmod 755 ${static_dir}/${app}.css

          cat ${ROOT}/web/src/cgi-bin/tmplt_auth | $SED "s#%%www#${www}#g" | $SED "s/%%app/${app}/g" > ${cgi_dir}/auth.${app}
          chown $cgi_usr:$cgi_usr ${cgi_dir}/auth.${app}
          chmod 700 ${cgi_dir}/auth.${app}

          cat ${ROOT}/web/src/bin/tmplt_type3_get.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_get.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_set.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_set.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_del.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_del.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_table.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_table.sh

          cat ${ROOT}/web/src/bin/tmplt_log_viewer.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_log_viewer.sh

          cat ${ROOT}/web/src/bin/tmplt_main.sh | $SED "s#%%www#${www}#g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_main.sh

          cat ${ROOT}/web/src/bin/tmplt_page_links.sh | $SED "s#%%www#${www}#g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_page_links.sh

          cat ${ROOT}/web/src/bin/tmplt_dl.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_dl.sh
          chown $cgi_usr:$cgi_usr ${www}/bin/${app}*
          chmod 755 ${www}/bin/${app}*

          . ${ROOT}/web/.rand
          for src in $(ls ${ROOT}/web/src/def | grep tmplt | grep -v type2 | grep -v pass_auth | grep -v other_auth | xargs basename -a)
          do
            html_def=$(echo "$src" | $SED "s/tmplt_//g" | $SED "s/type3_//g")
            cat ${ROOT}/web/src/def/${src} | $SED "s/%%app/${app}/g" | $SED "s/%%rand/${rand}/g" \
            | $SED "s/%%databox/${databox}/g" | $SED "s#%%static_url/#${static_url}#g" > ${www}/def/${app}_${html_def}
            chmod 755 ${www}/def/${app}_${html_def}
          done

          for src in $(ls ${ROOT}/web/src/def/common_parts | grep tmplt | grep -v common_menu_button | xargs basename -a)
          do
            menu=$(echo "$src" | $SED "s/tmplt_//g" | $SED "s/type3_//g")
            cat ${ROOT}/web/src/def/common_parts/${src} | $SED "s/%%app/${app}/g" | $SED "s/%%databox/${databox}/g" \
            > ${www}/def/common_parts/${app}_${menu}
            chmod 755 ${www}/def/common_parts/${app}_${menu}
          done

           cat ${ROOT}/web/src/def/common_parts/tmplt_common_menu_button | $SED "s/%%app/${app}/g" | $SED "s/%%rand/${rand}/g" \
           >> ${www}/def/common_parts/${app}_common_menu

          chown $cgi_usr:$cgi_usr ${www}/def/${app}*
          chown $cgi_usr:$cgi_usr ${www}/def/common_parts/${app}*

          if [ "$srv_type" = "default" ];then
             if [ ! -d ${www}/html/${app} ];then
               mkdir ${www}/html/${app}
             fi
             cat ${ROOT}/web/src/def/redirect.html.def | $SED "s#%%APPURL#${base_url}auth.${app}#g" > ${www}/html/${app}/index.html
             chmod 755 ${www}/html/${app}/index.html
          fi

        fi

        if [ "$auth_method" = "other" ];then

          # careate app authkey
          app_user_name=${app}.app
          app_user_id=$(echo "$app_user_name" | $SHASUM | $AWK '{print $1}')
          input_type="text"

          if [ ! -d ${ROOT}/users/${app}.${app_user_id} ];then
            mkdir ${ROOT}/users/${app}.${app_user_id}
          fi
          echo "$app_user_name" > ${ROOT}/users/${app}.${app_user_id}/user_name
          echo "permission=rw" > ${ROOT}/users/${app}.${app_user_id}/.attr.tmp
          cat ${ROOT}/users/${app}.${app_user_id}/.attr.tmp > ${ROOT}/users/${app}.${app_user_id}/attr
          chown small-shell:small-shell ${ROOT}/users/${app}.${app_user_id}/attr

          which openssl  >/dev/null 2>&1
          if [ $? -eq 0 ];then
            hash_gen_key=$(openssl rand -hex 20)
          else
            hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
          fi

          hash=$(echo "${app}:${app_user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}')
          echo "$hash" > ${ROOT}/users/${app}.${app_user_id}/hash
          chown -R small-shell:small-shell ${ROOT}/users/${app}.${app_user_id}
          chmod 700 ${ROOT}/users/${app}.${app_user_id}/hash
          authkey=$(echo "${app_user_name}:${hash_gen_key}" | $BASE64_ENC)

          # deploy other App
          cat ${ROOT}/web/src/cgi-bin/tmplt_controller | $SED "s#%%www#${www}#g" \
          | $SED "s/%%app/${app}/g" | $SED "s/%%auth/required/g" > ${cgi_dir}/${app}
          chown $cgi_usr:$cgi_usr ${cgi_dir}/${app}
          chmod 700 ${cgi_dir}/${app}

          cp ${ROOT}/web/src/lib/tmplt_type3.css ${static_dir}/${app}.css
          chmod 755 ${static_dir}/${app}.css

          cat ${ROOT}/web/src/cgi-bin/tmplt_other_auth | $SED "s#%%www#${www}#g" \
          | $SED "s/%%app/${app}/g" | $SED "s/%%authkey/${authkey}/g" > ${cgi_dir}/auth.${app}
          chown $cgi_usr:$cgi_usr ${cgi_dir}/auth.${app}
          chmod 700 ${cgi_dir}/auth.${app}

          cat ${ROOT}/web/src/bin/tmplt_type3_get.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_get.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_set.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_set.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_del.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_del.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_table.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_table.sh

          cat ${ROOT}/web/src/bin/tmplt_log_viewer.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_log_viewer.sh

          cat ${ROOT}/web/src/bin/tmplt_main.sh | $SED "s#%%www#${www}#g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_main.sh

          cat ${ROOT}/web/src/bin/tmplt_page_links.sh | $SED "s#%%www#${www}#g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_page_links.sh

          cat ${ROOT}/web/src/bin/tmplt_dl.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_dl.sh

          chown $cgi_usr:$cgi_usr ${www}/bin/${app}*
          chmod 755 ${www}/bin/${app}*

          for src in $(ls ${ROOT}/web/src/def | grep tmplt | grep -v type2 | grep -v auth | xargs basename -a)
          do
            html_def=$(echo "$src" | $SED "s/tmplt_//g" | $SED "s/type3_//g")
            cat ${ROOT}/web/src/def/${src} | $SED "s/%%app/${app}/g" | $SED "s/%%user/there/g" \
            | $SED "s#%%static_url/#${static_url}#g" | $SED "s/%%databox/${databox}/g" > ${www}/def/${app}_${html_def}
            chmod 755 ${www}/def/${app}_${html_def}
          done

          for src in $(ls ${ROOT}/web/src/def/common_parts | grep tmplt | grep -v common_menu_button | xargs basename -a)
          do
            menu=$(echo "$src" | $SED "s/tmplt_//g" | $SED "s/type3_//g")
            cat ${ROOT}/web/src/def/common_parts/${src} | $SED "s/%%app/${app}/g" | $SED "s/%%databox/${databox}/g" \
            > ${www}/def/common_parts/${app}_${menu}
            chmod 755 ${www}/def/common_parts/${app}_${menu}
          done

          chown $cgi_usr:$cgi_usr ${www}/def/${app}*
          chown $cgi_usr:$cgi_usr ${www}/def/common_parts/${app}*

          . ${ROOT}/web/.rand
          cat ${ROOT}/web/src/def/tmplt_other_auth_form.html.def | $SED "s/%%input_type/${input_type}/g" | $SED "s/%%app/${app}/g" \
          | $SED "s/%%rand/${rand}/g" | $SED "s#%%static_url/#${static_url}#g" > ${www}/def/${app}_auth_form.html.def
          chmod 755 ${www}/def/${app}_auth_form.html.def
          chown $cgi_usr:$cgi_usr ${www}/def/${app}*

        fi

        if [ "$auth_method" = "none" ];then

          # careate app authkey
          app_user_name=${app}.app
          app_user_id=$(echo "$app_user_name" | $SHASUM | $AWK '{print $1}')

          input_type="text"
          placeholder="please input your name"

          if [ ! -d ${ROOT}/users/${app}.${app_user_id} ];then
            mkdir ${ROOT}/users/${app}.${app_user_id}
          fi
          echo "$app_user_name" > ${ROOT}/users/${app}.${app_user_id}/user_name
          echo "permission=ro" > ${ROOT}/users/${app}.${app_user_id}/.attr.tmp
          cat ${ROOT}/users/${app}.${app_user_id}/.attr.tmp > ${ROOT}/users/${app}.${app_user_id}/attr
          chown small-shell:small-shell ${ROOT}/users/${app}.${app_user_id}/attr

          which openssl  >/dev/null 2>&1
          if [ $? -eq 0 ];then
            hash_gen_key=$(openssl rand -hex 20)
          else
            hash_gen_key="${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
          fi

          hash=$(echo "${app}:${app_user_name}:${hash_gen_key}" | $SHASUM | $AWK '{print $1}')
          echo "$hash" > ${ROOT}/users/${app}.${app_user_id}/hash
          chown -R small-shell:small-shell ${ROOT}/users/${app}.${app_user_id}
          chmod 700 ${ROOT}/users/${app}.${app_user_id}/hash
          authkey=$(echo "${app_user_name}:${hash_gen_key}" | $BASE64_ENC)

          # deploy none auth App
          cat ${ROOT}/web/src/cgi-bin/tmplt_controller_noauth | $SED "s#%%www#${www}#g" | $SED "s/%%authkey/${authkey}/g" \
          | $SED "s/%%app/${app}/g" | $SED "s/%%auth//g" > ${cgi_dir}/${app}
          chown $cgi_usr:$cgi_usr ${cgi_dir}/${app}
          chmod 700 ${cgi_dir}/${app}

          cp ${ROOT}/web/src/lib/tmplt_type3.css ${static_dir}/${app}.css
          chmod 755 ${static_dir}/${app}.css

          cat ${ROOT}/web/src/bin/tmplt_type3_get.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_get.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_set.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_set.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_del.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_del.sh

          cat ${ROOT}/web/src/bin/tmplt_type3_table.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_table.sh

          cat ${ROOT}/web/src/bin/tmplt_log_viewer.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_log_viewer.sh

          cat ${ROOT}/web/src/bin/tmplt_main.sh | $SED "s#%%www#${www}#g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_main.sh

          cat ${ROOT}/web/src/bin/tmplt_page_links.sh | $SED "s#%%www#${www}#g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_page_links.sh

          cat ${ROOT}/web/src/bin/tmplt_dl.sh | $SED "s#%%www#${www}#g" | $SED "s/%%databox/${databox}/g" \
          | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_dl.sh

          chown $cgi_usr:$cgi_usr ${www}/bin/${app}*
          chmod 755 ${www}/bin/${app}*

          for src in $(ls ${ROOT}/web/src/def | grep tmplt | grep -v type2 | grep -v auth | xargs basename -a)
          do
            html_def=$(echo "$src" | $SED "s/tmplt_//g" | $SED "s/type3_//g")
            cat ${ROOT}/web/src/def/${src} | $SED "s/%%app/${app}/g" | $SED "s/%%user/there/g" \
            | $SED "s/%%databox/${databox}/g" | $SED "s#%%static_url/#${static_url}#g" > ${www}/def/${app}_${html_def}
            chmod 755 ${www}/def/${app}_${html_def}
          done

          for src in $(ls ${ROOT}/web/src/def/common_parts | grep tmplt | grep -v common_menu_button | xargs basename -a)
          do
            menu=$(echo "$src" | $SED "s/tmplt_//g" | $SED "s/type3_//g")
            cat ${ROOT}/web/src/def/common_parts/${src} | $SED "s/%%app/${app}/g" | $SED "s/%%databox/${databox}/g" \
            > ${www}/def/common_parts/${app}_${menu}
            chmod 755 ${www}/def/common_parts/${app}_${menu}
          done

          chown $cgi_usr:$cgi_usr ${www}/def/${app}*
          chown $cgi_usr:$cgi_usr ${www}/def/common_parts/${app}*

          if [ "$srv_type" = "default" ];then
             if [ ! -d ${www}/html/${app} ];then
               mkdir ${www}/html/${app}
             fi
             cat ${ROOT}/web/src/def/redirect.html.def | $SED "s#%%APPURL#${base_url}${app}#g" > ${www}/html/${app}/index.html
             chmod 755 ${www}/html/${app}/index.html
          fi

        fi

        # create databox for images, UI.md.def and claendar
        if [ ! -d ${ROOT}/databox/images.db ];then
          ${ROOT}/util/scripts/bat_gen.sh ${ROOT}/tmp/gen/.images.db/databox.def
          if [ ! -d ${www}/html/images ];then
            mkdir ${www}/html/images
            chown $cgi_usr:$cgi_usr ${www}/html/images
          fi 
        fi

        cat ${ROOT}/tmp/gen/.tmplt.UI.md.def/databox.def | $SED "s/%%app/${app}/g" > ${tmp_dir}/${app}.tmplt.UI.md.def
        ${ROOT}/util/scripts/bat_gen.sh ${tmp_dir}/${app}.tmplt.UI.md.def
        mkdir ${tmp_dir}/data


        for data in body righth lefth footer
        do
          cat ${ROOT}/tmp/gen/.tmplt.UI.md.def/${data} | $SED "s/%%app/${app}/g" | $SED "s/%%databox/${databox}/g" > ${tmp_dir}/data/${data}
        done

        if [ "$auth_method" = "key" ];then
          $SED -e "1i ExportKey: yes" ${tmp_dir}/data/righth > ${tmp_dir}/data/.righth
          cat ${tmp_dir}/data/.righth > ${tmp_dir}/data/righth
          rm ${tmp_dir}/data/.righth
        fi
        if [ ! "$auth_method" = "none" ];then
          echo "Log Out: ./${app}?req=logout" >> ${tmp_dir}/data/righth
        fi

        cat ${ROOT}/tmp/gen/.calendar.events/databox.def | $SED "s/%%app/${app}/g" > ${tmp_dir}/${app}.events.def
        ${ROOT}/util/scripts/bat_gen.sh ${tmp_dir}/${app}.events.def

        # push template datas
        . ${ROOT}/util/scripts/.authkey
        permission=$(${ROOT}/bin/meta get.attr:sys)
        if [ "$permission" = "ro" ];then
          ${ROOT}/adm/ops set.attr:sys{rw} > /dev/null 2>&1
          (cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/DATA_shell authkey:$authkey databox:${app}.UI.md.def \
          action:set id:new keys:body,righth,lefth,footer input_dir:${tmp_dir}/data)
          ${ROOT}/adm/ops set.attr:sys{ro} > /dev/null 2>&1
        else
          (cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/DATA_shell authkey:$authkey databox:${app}.UI.md.def \
          action:set id:new keys:body,righth,lefth,footer input_dir:${tmp_dir}/data)
        fi

        clear
        echo "------------------------------------------------------------"
        echo "$app has been successfully generated"

        if [ ! "$auth_method" = "other" ];then
          echo "Access URL: ${static_url}${app}"
        else
          # for adaption of Oauth
          echo "Access URL: ${base_url}auth.${app}"
        fi
        echo "------------------------------------------------------------"
        echo "Here is the generated code that you can modify."
        echo "You can also update main page on Base App #${app}.UI.md.def using markdown."

        if [ ! "$auth_method" = "none" ];then
          ls  ${cgi_dir}/auth.${app}
        fi

        ls  ${cgi_dir}/${app}
        ls  ${static_dir}/${app}.css
        ls  ${www}/bin/${app}_*
        ls  ${www}/def/${app}_*

        if [ "$auth_method" = "key" ];then
          echo "------------------------------------------------------------"
          echo "please create user for the app by following command"
          echo "------------------------------------------------------------"
          echo "sudo ${ROOT}/adm/ops app:${app} add.usr:\$user"
        fi

      else
      # else means this is subapp

        cat ${ROOT}/web/src/bin/tmplt_type3_table_sub.sh | $SED "s#%%www#${www}#g" | $SED "s/%%parent_app/${parent_app}/g" \
        | $SED "s/%%databox/${databox}/g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_table.sh

        cat ${ROOT}/web/src/bin/tmplt_type3_get_sub.sh | $SED "s#%%www#${www}#g" | $SED "s/%%parent_app/${parent_app}/g" \
        | $SED "s/%%databox/${databox}/g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_get.sh

        cat ${ROOT}/web/src/bin/tmplt_type3_set_sub.sh | $SED "s#%%www#${www}#g" | $SED "s/%%parent_app/${parent_app}/g" \
        | $SED "s/%%databox/${databox}/g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_set.sh

        cat ${ROOT}/web/src/bin/tmplt_type3_del_sub.sh | $SED "s#%%www#${www}#g" | $SED "s/%%parent_app/${parent_app}/g" \
        | $SED "s/%%databox/${databox}/g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_del.sh

        cat ${ROOT}/web/src/bin/tmplt_log_viewer_sub.sh | $SED "s#%%www#${www}#g" | $SED "s/%%parent_app/${parent_app}/g" \
        | $SED "s/%%databox/${databox}/g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_log_viewer.sh

        cat ${ROOT}/web/src/bin/tmplt_page_links.sh | $SED "s#%%www#${www}#g" | $SED "s/%%app/${parent_app}/g" \
        > ${www}/bin/${app}_page_links.sh

        cat ${ROOT}/web/src/bin/tmplt_dl_sub.sh | $SED "s#%%www#${www}#g" | $SED "s/%%parent_app/${parent_app}/g" \
        | $SED "s/%%databox/${databox}/g" | $SED "s/%%app/${app}/g" > ${www}/bin/${app}_dl.sh

        chown $cgi_usr:$cgi_usr ${www}/bin/${app}*
        chmod 755 ${www}/bin/${app}*


        for src in $(ls ${ROOT}/web/src/def | grep tmplt | grep -v type2 | grep -v auth | xargs basename -a)
        do
          html_def=$(echo "$src" | $SED "s/tmplt_//g" | $SED "s/type3_//g")
          cat ${ROOT}/web/src/def/${src} | $SED "s/\".\/%%app/\".\/${parent_app}/g" | $SED "s#%%static_url/#${static_url}#g" \
          | $SED "s/%%app/${parent_app}/g" | $SED "s/%%databox/${databox}/g" > ${www}/def/${app}_${html_def}
        done

        for src in $(ls ${ROOT}/web/src/def/common_parts | grep tmplt_table | grep -v common_menu_button | xargs basename -a)
        do
          menu=$(echo "$src" | $SED "s/tmplt_//g" | $SED "s/type3_//g")
          cat ${ROOT}/web/src/def/common_parts/${src} | $SED "s/%%app/${parent_app}/g" | $SED "s/%%databox/${databox}/g" \
          > ${www}/def/common_parts/${app}_${menu}
          chmod 755 ${www}/def/common_parts/${app}_${menu}
        done

        chmod 755 ${www}/def/${app}*
        chown $cgi_usr:$cgi_usr ${www}/def/${app}*
        chown $cgi_usr:$cgi_usr ${www}/def/common_parts/${app}*

        # add routing to parent app
        cat ${ROOT}/web/src/cgi-bin/tmplt_subapp_routing | $SED "s#%%www#${www}#g" | $SED "s#%%app#${app}#g" > ${tmp_dir}/subapp_routing
        cat ${cgi_dir}/${parent_app} | $SED "/# sub app routing section/r ${tmp_dir}/subapp_routing"  > ${tmp_dir}/new_parent
        cat ${tmp_dir}/new_parent > ${cgi_dir}/${parent_app}

        # add menu to common menu
        if [ -f ${cgi_dir}/auth.${parent_app} ];then
          echo "<li><a href=\"./${parent_app}?%%session&subapp=${app}&req=table\"><p style=\"text-transform: capitalize;\">${databox} Table</p></a></li>" \
          >> ${tmp_dir}/subAPP_link
          cat ${www}/def/common_parts/${parent_app}_common_menu | $SED -e "/Log Out/i $(cat ${tmp_dir}/subAPP_link)" > ${tmp_dir}/new_menu
          cat ${tmp_dir}/new_menu > ${www}/def/common_parts/${parent_app}_common_menu
        else
          echo "<li><a href=\"./${parent_app}?%%session&subapp=${app}&req=table\"><p style=\"text-transform: capitalize;\">${databox} Table</p></a></li>" \
           >> ${www}/def/common_parts/${parent_app}_common_menu
        fi

        # add menu to UI.md.def
        . ${ROOT}/util/scripts/.authkey
        permission=$(${ROOT}/bin/meta get.attr:sys)
	chk_md_def=$(${ROOT}/bin/meta get.databox | grep ${parent_app}.UI.md.def)
	if [ "$chk_md_def" ];then
          id=$(cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/DATA_shell authkey:$authkey \
          databox:${parent_app}.UI.md.def command:head_-1 format:none | $AWK -F "," '{print $1}')

          (cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/DATA_shell authkey:$authkey databox:${parent_app}.UI.md.def action:get id:$id key:righth format:none \
          | $SED "s/righth://g" | $SED "s/_%%enter_/\n/g" > ${tmp_dir}/UI_md_def_menu)
          mkdir ${tmp_dir}/data

          if [ "$permission" = "ro" ];then
            ${ROOT}/adm/ops set.attr:sys{rw} > /dev/null 2>&1
            tmp_permission_flg=yes
          fi

          if [ -f ${cgi_dir}/auth.${parent_app} ];then
            cat ${tmp_dir}/UI_md_def_menu | $SED -e "/Log Out/i ${databox} Table: ./${parent_app}?req=table&subapp=${app}" > ${tmp_dir}/data/righth
            (cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/DATA_shell authkey:$authkey databox:${parent_app}.UI.md.def \
            action:set id:$id key:righth input_dir:${tmp_dir}/data)
          else
            cat ${tmp_dir}/UI_md_def_menu > ${tmp_dir}/data/righth
            echo "${databox} Table: ./${parent_app}?req=table&subapp=${app}" >> ${tmp_dir}/data/righth
            (cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/DATA_shell authkey:$authkey databox:${parent_app}.UI.md.def \
            action:set id:$id key:righth input_dir:${tmp_dir}/data)
          fi

          if [ "$tmp_permission_flg" = "yes" ];then
              ${ROOT}/adm/ops set.attr:sys{ro} > /dev/null 2>&1
          fi

	fi

        echo "subapp is successfully generated, parent app is updated -> ${cgi_dir}/${parent_app},${www}/def/common_parts/${parent_app}_common_menu"
        echo "Here is the generated code that you can modify."
        ls  ${www}/bin/${app}_*
        ls  ${www}/def/${app}_*

      fi

    else
      echo "Plese try again from beginning, #gen -app"
      rm -rf $tmp_dir
      exit 1
    fi

  fi

fi

# GENERATE BATCH (e-cron)

function gen_schedule(){
  echo -n "" > ${tmp_dir}/cron_entry
  echo "--Define schedule--"
  echo -n "Month [ any | 1-12 ]: "
  read month
  month_chk=$(echo "$month" | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[1-9]\"" -e "\"[1][0-2]\"")

  while [ ! "$month" = "any" -a ! "$month_chk" ]  
  do
    echo -n "Try again [ any | 1-12 ]: "
    read month
    month_chk=$(echo "$month" | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[1-9]\"" -e "\"[1][0-2]\"")
  done 

  echo -n "Date  [ any | 1-31 ]: "
  read date
  date_chk=$(echo "$date" | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[1-9]\"" -e "\"[1-2][0-9]\"" -e  "\"[3][0-1]\"")

  while [ ! "$date" = "any" -a ! "$date_chk" ]
  do
    echo -n "Try again [ any | 1-31 ]: "
    read date
    date_chk=$(echo "$date" | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[1-9]\"" -e "\"[1-2][0-9]\"" -e  "\"[3][0-1]\"")
  done

  echo -n "Hour  [ any | 0-23 ]: "
  read hour
  hour_chk=$(echo "$hour" | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[0-9]\"" -e "\"[1][0-9]\""  -e "\"[2][0-3]\"")

  while [ ! "$hour" = "any" -a ! "$hour_chk" ]
  do
    echo -n "Try again [ any | 0-23 ]: "
    read hour
    hour_chk=$(echo "$hour" | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[0-9]\"" -e "\"[1][0-9]\""  -e "\"[2][0-3]\"")
  done

  echo -n "Min   [ any | 0-59 ]: "
  read min
  min_chk=$(echo "$min" | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[0-9]\"" -e "\"[1-5][0-9]\"")

  while [ ! "$min" = "any" -a ! "$min_chk" ]
  do
    echo -n "Try again [ any | 0-59 ]: "
    read min
    min_chk=$(echo "$min" | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep  -e  "\"[0-9]\"" -e "\"[1-5][0-9]\"")
  done

  if [ "$min" = "any" ];then
    echo -n "* " >> ${tmp_dir}/cron_entry
    echo "Min: any" >> ${tmp_dir}/confirm
  else
    echo -n "$min " >> ${tmp_dir}/cron_entry
    echo "Min: $min" >> ${tmp_dir}/confirm
  fi

  if [ "$hour" = "any" ];then
    echo -n "* " >> ${tmp_dir}/cron_entry
    echo "Hour: any" >> ${tmp_dir}/confirm
  else
    echo -n "$hour " >> ${tmp_dir}/cron_entry
    echo "Hour: $hour" >> ${tmp_dir}/confirm
  fi

  if [ "$date" = "any" ];then
    echo -n "* " >> ${tmp_dir}/cron_entry
    echo "Date: any" >> ${tmp_dir}/confirm
  else
    echo -n "$date " >> ${tmp_dir}/cron_entry
    echo "Date: $date" >> ${tmp_dir}/confirm
  fi

  if [ "$month" = "any" ];then
    echo -n "* " >> ${tmp_dir}/cron_entry
    echo "Month: any" >> ${tmp_dir}/confirm
  else
    echo -n "$month " >> ${tmp_dir}/cron_entry
    echo "Month: $month" >> ${tmp_dir}/confirm
  fi

  echo -n "Week  [ any | mon - sun ]: "
  read week
  week_chk=$(echo "$week" | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep -e "\"mon\"" -e "\"tue\"" -e "\"wed\"" -e "\"thu\"" \
  -e "\"fri\"" -e  "\"sat\"" -e "\"sun\"")

  while [ ! "$week" = "any" -a ! "$week_chk" ]
  do
    echo -n "Try again [ any | mon - sun ]: "
    read week
     week_chk=$(echo "$week" | $SED "s/^/\"/g" | $SED "s/$/\"/g" | grep -e "\"mon\"" -e "\"tue\"" -e "\"wed\"" -e "\"thu\"" \
     -e "\"fri\"" -e  "\"sat\"" -e "\"sun\"")
  done

  if [ "$week" = "any" ];then
    echo "*" >> ${tmp_dir}/cron_entry
    echo "Week: any" >> ${tmp_dir}/confirm

  elif [ "$week" = "mon" ];then
    echo "1" >> ${tmp_dir}/cron_entry
    echo "Week: $week" >> ${tmp_dir}/confirm

  elif [ "$week" = "tue" ];then
    echo "2" >> ${tmp_dir}/cron_entry
    echo "Week: $week" >> ${tmp_dir}/confirm

  elif [ "$week" = "wed" ];then
    echo "3" >> ${tmp_dir}/cron_entry
    echo "Week: $week" >> ${tmp_dir}/confirm

  elif [ "$week" = "thu" ];then
    echo "4" >> ${tmp_dir}/cron_entry
    echo "Week: $week" >> ${tmp_dir}/confirm

  elif [ "$week" = "fri" ];then
    echo "5" >> ${tmp_dir}/cron_entry
    echo "Week: $week" >> ${tmp_dir}/confirm

  elif [ "$week" = "sat" ];then
    echo "6" >> ${tmp_dir}/cron_entry
    echo "Week: $week" >> ${tmp_dir}/confirm

  elif [ "$week" = "sun" ];then
    echo "7" >> ${tmp_dir}/cron_entry
    echo "Week: $week" >> ${tmp_dir}/confirm
  fi
}

if [ "$param" = "-job" ];then

  # start dialog
  echo -n "Job Name: "
  read job
  ascii_chk_result=$(ascii_check $job)
  meta_chk_result=$(echo "$job" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
  -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "\." -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

  ls ${ROOT}/util/e-cron/def/${job}.def >/dev/null 2>&1
  if [ $? -eq 0 ];then
    existing_chk_result=existing
  else
    existing_chk_result=""
  fi

  while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" -o ! "$job" ]
  do

    if [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" ];then
      echo "error: Job name must be ascii text and you can't use meta charactor including space, please try again"
    fi
    echo -n "Job Name: "
    read job
    ascii_chk_result=$(ascii_check $job)
    meta_chk_result=$(echo "$job" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "\." -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

    ls ${ROOT}/util/e-cron/def/${job}.def >/dev/null 2>&1
    if [ $? -eq 0 ];then
      existing_chk_result=existing
    else
      existing_chk_result=""
    fi

  done
  echo "Job_name: $job" > ${tmp_dir}/confirm
  touch ${tmp_dir}/${job}.def

  if [ ! "$existing_chk_result" = existing ];then
    echo -n "Type of job (1.job automation | 2.file exchange) : "
    read jobtype
    while [ ! "$jobtype" = "1" -a  ! "$jobtype" = "2" ]
    do
      echo -n "please input number (1.job automation | 2.file exchange) : "
      read jobtype
    done
  else
    command_chk=$(grep "^exec_command=" ${ROOT}/util/e-cron/def/${job}.def)
    if [ "$command_chk" ];then
      jobtype=1
    else
      jobtype=2
    fi
  fi

  if [ "$jobtype" = "1" ];then

    if [ "$existing_chk_result" = existing ];then
      clear
      echo "WARN job:${job} is existing, please update the job by dialog.and if you don't want to update it, please exit with ctrl + C"
    fi
    gen_schedule
    cat ${tmp_dir}/cron_entry | $SED "s/^/SCHEDULE:/g" > ${tmp_dir}/${job}.def
    echo -n "Exec command or batch script: "
    read exec_command

    
    while [ ! "$exec_command" -o ! -x "$solo_command" -o ! "$exec_chk" ]
    do
      solo_command=$(echo "$exec_command" | $AWK '{print $1}')
      basename_chk=$(echo "$exec_command" | $AWK '{print $1}' | xargs basename -a | grep $solo_command)

      if [ "$basename_chk" ];then

        if [ -f ${ROOT}/util/scripts/${solo_command} ];then
          solo_command="${ROOT}/util/scripts/${solo_command}"
          command_path=$(echo ${ROOT}/util/scripts/ | $SED "s/\//{%%%%%%%}/g")
          exec_command=$(echo "$exec_command" | $SED "s/^/${command_path}/g" | $SED "s/{%%%%%%%}/\//g")

        elif [ -f /usr/bin/${solo_command} ];then
          solo_command="/usr/bin/${solo_command}"
          command_path=$(echo /usr/bin/ | $SED "s/\//{%%%%%%%}/g")
          exec_command=$(echo "$exec_command" | $SED "s/^/${command_path}/g" | $SED "s/{%%%%%%%}/\//g")

        elif [ -f /bin/${solo_command} ];then
          solo_command="/bin/${solo_command}"
          command_path=$(echo /bin/ | $SED "s/\//{%%%%%%%}/g")
          exec_command=$(echo "$exec_command" | $SED "s/^/${command_path}/g" | $SED "s/{%%%%%%%}/\//g")

        else
          solo_command="$(pwd)/${solo_command}"
          exec_command="$(pwd)/${exec_command}"
        fi

        exec_chk=$(cd $tmp_dir && sudo -u small-shell file $solo_command | grep -i -e executable -e gnu)
      fi

      if [ ! "$exec_command" ];then
        echo -n "please input exec command or batch script: "
        read exec_command
      elif [  ! -x "$solo_command" ];then
        echo "seems $solo_command is not executable, please input full path for the command"
        echo -n "please input exec command or batch script: "
        read exec_command
      elif [ ! "$exec_chk" ];then
        echo "seems $solo_command is not executable by small-shell"
        echo -n "please input exec command or batch script: "
        read exec_command
      fi
    done

    echo "exec_command=\"$(echo "$exec_command" | $SED "s/'/{%%%%%%}/g"\
    | php -r "echo addslashes(file_get_contents('php://stdin'));"\
    | $SED "s/{%%%%%%}/'/g")\"" >> ${tmp_dir}/${job}.def

    echo "Exec_command: $(echo "$exec_command" |  $SED "s/'/{%%%%%%}/g" \
    | php -r "echo addslashes(file_get_contents('php://stdin'));"\
    | $SED "s/{%%%%%%}/'/g")" >> ${tmp_dir}/confirm

    echo "input_message=\"\"" >> ${tmp_dir}/${job}.def
    echo "output_message=\"\"" >> ${tmp_dir}/${job}.def
    echo "hub_api=\"\"" >> ${tmp_dir}/${job}.def
    echo "api_authkey=\"\"" >> ${tmp_dir}/${job}.def

    #clear
    echo "The job will be generated in the following order. Please check it."
    echo "-----------------------------------------------------------------"
    echo ""
    echo "Jobtype: 1.job automation"
    cat ${tmp_dir}/confirm
    echo ""
    echo "-----------------------------------------------------------------"
    echo -n "Is that OK? (yes | no): "
    read fin_answer
    while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Is it OK to generate the job? (yes | no): "
      read fin_answer
    done
   
    if [ "$fin_answer" = "yes" ];then

      if [ "$existing_chk_result" = "existing" ];then
        (cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/e-cron disable.${job})
      fi
      cat ${tmp_dir}/${job}.def > ${ROOT}/util/e-cron/def/${job}.def
      chown small-shell:small-shell ${ROOT}/util/e-cron/def/${job}.def
      chmod 755 ${ROOT}/util/e-cron/def/${job}.def


      if [ $? -eq 0 ];then
        echo "Job:${job} has been successfully generated"
        echo "Please enable job \"sudo -u small-shell ${ROOT}/bin/e-cron enable.${job}\""
        cat ${tmp_dir}/confirm | grep -v "Exec_command:" | grep -v "Job_name:" > ${ROOT}/util/e-cron/def/.${job}.dump
      else
        echo "error: something wrong"
      fi
    else
      echo "Plese try again from beginning, #gen -job"
      rm -rf $tmp_dir
      exit 1
    fi
  fi

  if [ "$jobtype" = "2" ];then

    if [ "$existing_chk_result" = existing ];then
      clear
      echo "WARN job:${job} is existing, please update the job by dialog.and if you don't want to update it, please exit with ctrl + C"
    fi
    gen_schedule
    cat ${tmp_dir}/cron_entry | $SED "s/^/SCHEDULE:/g" > ${tmp_dir}/${job}.def
    echo -n "Type of file exchange (push | get): "
    read exchange_type
    while [ ! "$exchange_type" = "push" -a ! "$exchange_type" = "get" ]
    do
      echo "please input push or get"
      echo -n "Type (push | get): "
      read exchange_type
    done
    echo "Exchange Type: $exchange_type" >> ${tmp_dir}/confirm

    if [ "$exchange_type" = "get" ];then
      echo -n "Local directory: "
      read local_dir
      if [ -d $local_dir ];then
        (cd $tmp_dir && sudo -u small-shell echo "test" > ${local_dir}/.gentest)
	if [ $? -eq 0 ];then
	  gen_test=success
        else
          gen_test=""
	fi
      fi
      while [ ! "$gen_test" = "success" ]
      do
        echo "Oops something wrong, small-shell could not write down test file to the directory. please review the path or permission, then try again"
        echo -n "Local directory: "
        read local_dir
        if [ -d $local_dir ];then
          (cd $tmp_dir && sudo -u small-shell echo "test" > ${local_dir}/.gentest)
          if [ $? -eq 0 ];then
            gen_test=success
          else
            gen_test=""
          fi
        fi
      done
      echo "local_dir=\"${local_dir}\"" >> ${tmp_dir}/${job}.def
    fi

    if [ "$exchange_type" = "push" ];then
      echo -n "Local directory: "
      read local_dir
      if [ -d $local_dir ];then
        echo "test" > ${local_dir}/.gentest
        (cd $tmp_dir && sudo -u small-shell ls ${local_dir}/.gentest > /dev/null 2>&1)
        if [ $? -eq 0 ];then
          gen_test=success
        else
          gen_test=""
        fi
      fi
      while [ ! "$gen_test" = "success" ]
      do
        echo "Oops something wrong, small-shell could not access to the directory. please review the path or permission, then try again"
        echo -n "Local directory: "
        read local_dir
        if [ -d $local_dir ];then
          echo "test" > ${local_dir}/.gentest
          (cd $tmp_dir && sudo -u small-shell ls  ${local_dir}/.gentest > /dev/null 2>&1)
          if [ $? -eq 0 ];then
            gen_test=success
          else
            gen_test=""
          fi
        fi
      done
      echo "local_dir=\"${local_dir}\"" >> ${tmp_dir}/${job}.def
    fi

    echo -n "File Name: "
    read file_name
    file_name_excld_astrsk=$(echo "$file_name" | tr -d \*)
    ascii_chk_result=$(ascii_check $file_name_excld_astrsk)
    meta_chk_result=$(echo "$file_name_exld_astrsk" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
    -e ":" -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")

    while [ "$ascii_chk_result" = "ERROR" -o "$meta_chk_result" -o ! "$file_name" ]
    do
      echo "error: file name must be ascii text and you can't use meta charactor including space, please try again"
      echo -n "File Name: "
      read file_name
      file_name_excld_astrsk=$(echo "$file_name" | tr -d \*)
      ascii_chk_result=$(ascii_check $file_name_excld_astrsk)
      meta_chk_result=$(echo "$file_name_excld_astrsk" | grep -e " " -e "," -e "\!" -e "\*" -e "=" -e "(" -e ")" -e "\\\\" -e "/" \
      -e ";" -e "&" -e "\"" -e "\\$" -e "%" -e "'" -e "\`" -e "#" -e "~" -e \| -e ">" -e "<")
    done
    echo "${exchange_type}_file=\"${file_name}\"" >> ${tmp_dir}/${job}.def
    echo "File: $file_name" >> ${tmp_dir}/confirm
    
    echo -n "HUB API URL: "
    read hub_api
    hub_api=$(echo $hub_api | sed "s/\"//g")
    while [ ! "$hub_api" ]
    do
      echo "seems input is null, please try again"
      echo -n "HUB API URL: "
      read hub_api
    done

    echo -n "API authkey: "
    read authkey
    authkey=$(echo $authkey | sed "s/\"//g")
    while [ ! "$authkey" ]
    do
      echo "seems input is null, please try again"
      echo -n "API authkey: "
      read authkey
    done
   
    echo "HUB API test will be started (push & get)..."
    sleep 0.2
    clear
    echo "HUB API test will be started (push & get).."
    sleep 0.2
    clear
    echo "HUB API test will be started (push & get)"
    clear

    # push test
    file_que=${ROOT}/util/e-cron/que/file
    echo "test" > ${file_que}/e-cron_test
    chown small-shell:small-shell ${file_que}/e-cron_test
    push_file=e-cron_test
    push_result=$($CURL -X POST "${hub_api}?req=push&filename=${push_file}" \
    -H "Content-Type:application/octet-stream" -H "X-small-shell-authkey:${authkey}" \
    --data-binary @${file_que}/${push_file})

    if [ "$(echo $push_result | grep "file pushed successfully")" ];then
      echo "File push test has been successfully done" 
    else
      echo "Something wrong for file push test"
      echo "please set correct URL and authkey, and try again"
      echo "URL and authkey can be checked on dataExchange HUB server (e.g. cat /usr/local/small-shell/web/base)"
      rm -rf $tmp_dir
      exit 1
    fi 

    # get test
    if [ ! -d ${file_que}/.e-cron_test ];then
      mkdir ${file_que}/.e-cron_test
      chown small-shell:small-shell ${file_que}/.e-cron_test
    fi
    (cd ${file_que}/.e-cron_test && $CURL -OLJ "${hub_api}?req=get&filename=e-cron_test" -H "X-small-shell-authkey:$authkey")

    if [ "$(cat ${file_que}/.e-cron_test/e-cron_test 2>/dev/null | grep test)" ];then
      echo "File get test has been successfully done" 
      rm -rf ${file_que}/.e-cron_test
    else
      echo "Something wrong for file get test"
      echo "please set correct URL and authkey, and try again"
      echo "URL and authkey can be checked on dataExchange HUB server (e.g. cat /usr/local/small-shell/web/base)"
      rm -rf ${file_que}/.e-cron_test
      rm -rf $tmp_dir
      exit 1
    fi   
    echo "hub_api=\"${hub_api}\"" >> ${tmp_dir}/${job}.def
    echo "api_authkey=\"${authkey}\"" >> ${tmp_dir}/${job}.def
    echo "HUB API URL: $hub_api" >> ${tmp_dir}/confirm
    echo "API authkey: $authkey" >> ${tmp_dir}/confirm

    sleep 1
    clear
    echo "The job will be generated in the following order. Please check it."
    echo "-----------------------------------------------------------------"
    echo ""
    echo "Job_type: 2.file exchange"
    cat ${tmp_dir}/confirm
    echo ""
    echo "-----------------------------------------------------------------"
    echo -n "Is that OK? (yes | no): "
    read fin_answer
    while [ ! "$fin_answer" = "yes" -a ! "$fin_answer" = "no" ]
    do
      echo "please input yes or no"
      echo -n "Is it OK to generate the job? (yes | no): "
      read fin_answer
    done

    if [ "$fin_answer" = "yes" ];then

      if [ "$existing_chk_result" = "existing" ];then
        (cd $tmp_dir && sudo -u small-shell ${ROOT}/bin/e-cron disable.${job})
      fi

      cat ${tmp_dir}/${job}.def > ${ROOT}/util/e-cron/def/${job}.def
      chown small-shell:small-shell ${ROOT}/util/e-cron/def/${job}.def
      chmod 755 ${ROOT}/util/e-cron/def/${job}.def

      if [ $? -eq 0 ];then
        echo "Job:${job} has been successfully generated"
        echo "Please enable job \"sudo -u small-shell ${ROOT}/bin/e-cron enable.${job}\""

        cat ${tmp_dir}/confirm | grep -v "HUB API URL:" | grep -v "API authkey:" \
        | grep -v "File:" | grep -v "Job_name:" | grep -v "Exchange Type: " > ${ROOT}/util/e-cron/def/.${job}.dump

      else
        echo "error: something is wrong"
      fi
    else
      echo "Plese try again from beginning, #gen -job"
      rm -rf $tmp_dir
      exit 1
    fi
    
  fi
fi

rm -rf $tmp_dir
