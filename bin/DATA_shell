#!/bin/bash
#----------------------------------------------------------
# COMMON PARAM
#----------------------------------------------------------
# session (session:$session)
# pin (pin:$pin)
# authkey (authkey:$authkey)
# databox (databox:$databox)
# type (type:data) or (type:log) 
# format (format:html_tag) (format:csv) (format:json) (format:none)

#----------------------------------------------------------
# PARAM FOR COMMAND HANDLER
#----------------------------------------------------------
# command for resrouce array or logdump (command:$exec_command) e.g.(command:grep_-v_test_"|"_wc_-l)
# just filtering (command:wordA,wordB)
# show data array (command:show_all) (command:show_all[filter=wordA,wordB])
# show data array with specific line or keys (command:show_all[line=1-X][keys=$keyA,$keyB])
# show data array by sorting (command:show_all[sort=option,$key])
# show data array by filtering specific word (command:show_all[filter=wordA,wordB])
# show data array by filtering specific key (command:show_all[filter=$key{word}])
# show 100% match data with specific key (command:show_all[match=$key{word}])

#----------------------------------------------------------
# PARAM FOR DATA HANDLER
#----------------------------------------------------------
# action (action:set) (action:set.force) (action:get) (action:del)
# advanced action (action:merge.set) (action:merge.get)
# id (id:$hash_id)(id:new)
# data-key (key:$key) | keys (keys:key_name1,key_name2,key_name3)(keys:all)
# input_dir (input_dir:/tmp/yyyymmdd) ##you can use any directory for input
# value (value:$value)

## global conf load
SCRIPT_DIR=$(dirname $0)
 . ${SCRIPT_DIR}/../global.conf

# define allowed commands
ALLOWED_COMMANDS="wc,grep,sort,uniq,tail,head,nl,awk,cut"


# parse input params
for param in $(echo $@)
do

  if [[ $param == authkey:* ]];then
    authkey=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == session:* ]];then
    session=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == pin:* ]];then
    pin=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == databox:*  ]];then
    databox=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == db:* ]];then
    databox=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == type:* ]];then
    type=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == format:* ]];then
    format=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == command:* ]];then
    command=$(echo "$param" | $AWK -F":" '{print $2}')

    if [[ $command == *.dump*csv* ]];then
      command=$(echo "$command" | $SED "s/{%%%}/:/g" | $SED -r "s/>>_(.*).dump:csv_\|//g" | $SED -r "s/>>(.*).dump:csv_\|//g" \
      | $SED -r "s/>>(.*).dump:csv\|//g" | $SED -r "s/(.*).dump:csv_\|//g" |sed -r "s/(.*).dump:csv\|//g" \
      | $SED "s/_filter://g")
    fi

  fi 

  if [[ $param == action:* ]];then
    action=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == id:* ]];then
    id=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == key:* ]];then
    key=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == keys:* ]];then
    keys=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == input_dir:* ]];then
    input_dir=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == value:* ]];then
    value=$(echo "$param" | $SED "s/value://g")
  fi 

  if [[ $param == app:* ]];then
    app=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

  if [[ $param == bat:* ]];then
    bat=$(echo "$param" | $AWK -F":" '{print $2}')
  fi 

done

# exec user check
WHOAMI=$(whoami)
if [ ! "$WHOAMI" = "small-shell" ];then
  echo "error: user must be small-shell, please execute with \"sudo -u small-shell\""
  exit 1
fi

# param check
if [ ! "$databox" ];then
  echo "error: please input databox"
  exit 1
fi

if [ ! -d ${ROOT}/databox/${databox} ];then
  echo "error: there is no databox:$databox"
  exit 1
fi

if [ ! "$command" -a ! "$action" ];then
  echo "error: please input command or action"
  exit 1
fi

if [ ! "$format" ];then
   format=html_tag
fi

if [ ! "$type" ];then
  type=data
fi

if [ ! "$authkey" -a ! "$session" ];then
  echo "error: you need authentication"
  exit 1
fi

# authentication
if [ "$authkey" ];then
  auth_req=$(${ROOT}/bin/auth key_auth:${authkey} remote_addr:localhost user_agent:DATA_shell_CLI)
  session=$(echo "$auth_req" | $AWK -F "," '{print $2}' | $AWK -F ":" '{print $2}')
  pin=$(echo "$auth_req" | $AWK -F "," '{print $3}' | $AWK -F ":" '{print $2}')

  if [ ! "$session" ];then
    echo "error: authentication failed"
    exit 1
  fi
fi

# authorized session check
if [ -f ${ROOT}/tmp/session/${session} ];then
  user=$(cat ${ROOT}/tmp/session/${session} | $AWK -F ":" '{print $1}')

  if [ ! "$app" ];then
    # check token
    tokencheck=$(echo "${user}:${pin}" | $SHASUM | $AWK '{print $1}')
    app=base
  else
    # check app token
    tokencheck=$(echo "${app}:${user}:${pin}" | $SHASUM | $AWK '{print $1}')
  fi

  if [ ! "$session" = "$tokencheck" ];then
    echo "error: pin is wrong, you need authentication"
    exit 1
  fi 

else

  echo "error: you need authentication"
  exit 1

fi

# prevent crash of exe file
exec_session=$session.$RANDOM.$RANDOM.$RANDOM

# load user attribut
user_id=$(echo ${user} |  $SHASUM | $AWK '{print $1}')


## COMMAND HANDLER ###
#  exec command
if [ "$command" ];then
  org_command=$command

  if [ "$type" = "log" ];then
    target_file=${ROOT}/databox/${databox}/log.dump
  fi

  if [ "$type" = "data" ];then
    target_file=${ROOT}/databox/${databox}/index
  fi

  # handle "show_all" command
  if [[ $command == show_all* ]];then

    if [ "$type" = "log" ];then
      echo "error: you can't show all log at once"
      exit 1
    fi
   
    if [[ $command == *key=* ]];then
      command=$(echo "$command" | $SED "s/key=/keys=/g")
    fi

    filter_words=$(echo "$command" | grep filter= | $AWK -F "filter=" '{print $2}' |  $SED "s/\]//g" \
    | $SED -r "s/\[line=(.*)//g" | $SED -r "s/\[keys=(.*)//g" | $SED -r "s/\[sort=(.*)//g" | $SED -r "s/\[match=(.*)//g")

    match_word=$(echo "$command" | grep match= | $AWK -F "match=" '{print $2}' |  $SED "s/\]//g" \
    | $SED -r "s/\[line=(.*)//g" | $SED -r "s/\[keys=(.*)//g" | $SED -r "s/\[sort=(.*)//g" | $SED -r "s/\[filter=(.*)//g")

    line_start=$(echo "$command" | grep line= | $AWK -F "line=" '{print $2}' | $AWK -F "-" '{print $1}')

    line_end=$(echo "$command" | grep line= | $AWK -F "line=" '{print $2}' | $AWK -F "-" '{print $2}' \
    | $SED "s/]//g" | $SED -r "s/\[filter=(.*)//g" | $SED -r "s/\[keys=(.*)//g" | $SED -r "s/\[sort=(.*)//g" | $SED -r "s/\[match=(.*)//g")

    key_list=$(echo "$command" | grep keys= | $AWK -F "keys=" '{print $2}' |  $SED "s/\]//g" | $SED -r "s/\[keys=(.*)//g" \
    | $SED -r "s/\[filter=(.*)//g" | $SED -r "s/\[line=(.*)//g" | $SED -r "s/\[sort=(.*)//g" | $SED -r "s/\[match=(.*)//g")

    if [ "$key_list" = "all" ];then
      key_list=""
    fi

    sort_key=$(echo "$command" | grep sort= | $AWK -F "sort=" '{print $2}' | $AWK -F "," '{print $2}' | $SED "s/\]//g" \
    | $SED -r "s/\[filter=(.*)//g" | $SED -r "s/\[line=(.*)//g" | $SED -r "s/\[keys=(.*)//g")

    sort_option=$(echo "$command" | grep sort= | $AWK -F "sort=" '{print $2}' | $AWK -F "," '{print $1}' | $SED "s/\]//g" \
    | $SED -r "s/\[filter=(.*)//g" | $SED -r "s/\[line=(.*)//g" | $SED -r "s/\[keys=(.*)//g")


    # Handle show_all options
    ## Handle sort option
    sort_tmp=${ROOT}/tmp/exec/${exec_session}.result.tmp.sort

    if [ "${sort_key}" -o "${sort_option}" ];then

       if [ ! "${sort_key}" ];then
         echo "error: please set sort key" 
         exit 1
       fi

       if [ ! "${sort_option}" ];then
         echo "error: please set sort option" 
         exit 1
       fi

       sort_col=$(grep -l "^name=\"${sort_key}\"" ${ROOT}/databox/${databox}/def/col* | xargs basename -a  2>/dev/null | $SED "s/col//g")
       if [ "$sort_col" ];then
         (( sort_col += 1 ))
       else
         echo "error: sort key must be wrong" 
         exit 1
       fi

       if [ "$sort_col" ];then
         cat $target_file | $SED "s/^:::::://g" | $SED "s/::::::/,/g" > ${sort_tmp}.1
         cat ${sort_tmp}.1 | sort -t, ${sort_option} -k ${sort_col},${sort_col} > ${sort_tmp}.2 2>/dev/null 
         cat ${sort_tmp}.2  | $SED "s/,/::::::/1" | $SED "s/^/::::::/g" > ${sort_tmp}.3
       fi
       target_file=${sort_tmp}.3
    fi

    ## Handle show_all.filter_words
    filter_tmp=${ROOT}/tmp/exec/${exec_session}.result.tmp.filter

    if [ "$filter_words" ];then

      if [[ $filter_words == *{*} ]];then
        filter_key=$(echo "$filter_words" | $AWK -F"{" '{print $1}')
        filter_col=$(grep -l "^name=\"${filter_key}\"" ${ROOT}/databox/${databox}/def/col* | xargs basename -a  2>/dev/null | $SED "s/col//g")
        filter_words=$(echo "$filter_words" | cut -f 2- -d "{" | $SED "s/}$//g")
      fi

      exec_command=$(echo "$filter_words" | $SED "s/,/ | grep -i /g" | $SED "s/^/grep -i /g")
      echo "cat $target_file | $exec_command" > ${ROOT}/tmp/exec/${exec_session}.filtering.exe
      chmod 700 ${ROOT}/tmp/exec/${exec_session}.filtering.exe

      # exec filtering
      ${ROOT}/tmp/exec/${exec_session}.filtering.exe > ${filter_tmp}

      result_count=$(cat ${filter_tmp} | wc -l | tr -d " ")
      target_file=${filter_tmp}
      count=1
      for filter_word in $(echo "$filter_words" | $SED "s/,/ /g")
      do
        # remove line which contain filter words inside id hash
        echo "cat $target_file | $AWK -F "::::::"  '\
              {\
                 IGNORECASE = 1;\
                 if(match(\$3, /${filter_word}/))\
                 print \$0;\
              }\
        '" > ${ROOT}/tmp/exec/${exec_session}.${count}.remove_id.exe
        chmod 700 ${ROOT}/tmp/exec/${exec_session}.${count}.remove_id.exe
        target_file="${target_file}.${count}"
        ${ROOT}/tmp/exec/${exec_session}.${count}.remove_id.exe > $target_file

        if [ "$filter_key" ];then
          if [ "$filter_col" ];then
            # remove out of target column
            echo "cat $target_file | $AWK -F ","  '\
                  {\
                     IGNORECASE = 1;\
                     if(match(\$${filter_col}, /${filter_word}/))\
                     print \$0;\
                  }\
            '" > ${ROOT}/tmp/exec/${exec_session}.c.${count}.remove_col.exe
            chmod 700 ${ROOT}/tmp/exec/${exec_session}.c.${count}.remove_col.exe
            target_file="${target_file}.c.${count}"
            ${ROOT}/tmp/exec/${exec_session}.c.${count}.remove_col.exe > $target_file
          else
            target_file="${target_file}.c.${count}"
            touch $target_file
          fi
        fi

        ((count += 1))
      done
    fi

    ## Handle show_all.match_word
    match_tmp=${ROOT}/tmp/exec/${exec_session}.result.tmp.match

    if [ "$match_word" ];then

      if [[ $match_word == *{*} ]];then
        filter_key=$(echo "$match_word" | $AWK -F"{" '{print $1}')
        filter_col=$(grep -l "^name=\"${filter_key}\"" ${ROOT}/databox/${databox}/def/col* | xargs basename -a  2>/dev/null | $SED "s/col//g")
        match_word=$(echo "$match_word" | cut -f 2- -d "{" | $SED "s/}$//g")
      else
        echo "error: please input specific key name"
        exit 1
      fi

      exec_command=$(echo "$match_word" | $SED "s/^/grep  /g")
      echo "cat $target_file | $exec_command" > ${ROOT}/tmp/exec/${exec_session}.match.exe
      chmod 700 ${ROOT}/tmp/exec/${exec_session}.match.exe

      # exec matching
      ${ROOT}/tmp/exec/${exec_session}.match.exe > $match_tmp

      target_file=$match_tmp
      count=1

      if [ "$filter_key" ];then
        if [ "$filter_col" ];then
          # remove result which have columns that is not target column
          echo "cat $target_file | $AWK -F ","  '\
           {\
               if(match(\$${filter_col}, /::::::${match_word}$/))\
               print \$0;\

               if(match(\$${filter_col}, /^${match_word}$/))\
               print \$0;\
           }\
          '" > ${ROOT}/tmp/exec/${exec_session}.c.${count}.match.exe
          chmod 700 ${ROOT}/tmp/exec/${exec_session}.c.${count}.match.exe
          target_file="${target_file}.c.${count}"
          ${ROOT}/tmp/exec/${exec_session}.c.${count}.match.exe > $target_file
        else
          target_file="${target_file}.c.${count}"
          touch $target_file
        fi
      fi
    fi

    ## Handle line start-end option
    line_tmp=${ROOT}/tmp/exec/${exec_session}.result.tmp.extract_line

    if [ "${line_start}" -a "${line_end}"  ];then
      if [ "${line_start}" -lt "${line_end}" ];then
        cat $target_file | $SED -n ${line_start},${line_end}p > $line_tmp
        target_file=$line_tmp
      else
        echo "error: please set line adequately"

        ls ${ROOT}/tmp/exec/${exec_session}* >/dev/null 2>&1
        if [ $? -eq 0 ];then
          rm ${ROOT}/tmp/exec/${exec_session}*
        fi
        exit 1
      fi
    fi

    ## Extract data with key_list
    keys_tmp=${ROOT}/tmp/exec/${exec_session}.result.tmp.extract_keys
    if [ "$key_list" ];then

      for key in $(echo "$key_list" | $SED "s/,/ /g")
      do
        col=$(grep -l "^name=\"${key}\"" ${ROOT}/databox/${databox}/def/col* | xargs basename -a  2>/dev/null | $SED "s/col//g")
        if [ "$col" ];then
          if [ ! "$col_list" ];then
            col_list=$col
          else
            col_list="$col_list,$col"
          fi
        fi
      done

      # remove ID field with nl
      split_tmp=${ROOT}/tmp/exec/${exec_session}.result.tmp.split
      cat $target_file  | $AWK -F "::::::" '{print $2}' | $SED "s/^/::::::/g" | $SED "s/$/::::::/g" | nl > ${split_tmp}.id

      if [ "$col_list" ];then
        exec_command="cut -d \",\" -f $col_list"
        echo "cat $target_file | $exec_command" > ${ROOT}/tmp/exec/${exec_session}.extract_key.exe
        chmod 700 ${ROOT}/tmp/exec/${exec_session}.extract_key.exe
        ${ROOT}/tmp/exec/${exec_session}.extract_key.exe | nl > ${split_tmp}.data
        join ${split_tmp}.id ${split_tmp}.data \
        | $SED "s/ ::::::/######/g" | $SED "s/:::::: /::::::/g" | $SED -r "s/^(.*)######/::::::/g" > $keys_tmp
        target_file=$keys_tmp
        result_count=$(cat $target_file | wc -l | tr -d " ")
      fi

    fi

    # Generate result file of show_all with options
    if [ "$target_file" ];then
      cat $target_file > ${ROOT}/tmp/exec/${exec_session}.result
    fi

  fi

  # exec Unix commands to piplined data or just filtering the data
  if [[ ! $command == show_all* ]];then
    exec_command=$(echo "$command" | $SED "s/_/ /g")
    command=$(echo "$exec_command" | $AWK -F " " '{print $1}')

    GRP_ALLOWED_COMMANDS=$(echo "$ALLOWED_COMMANDS" | $SED "s/,/ -e /g" | $SED "s/^/grep -e /g")
    COMMAND_CHK="echo \"$command\" | $GRP_ALLOWED_COMMANDS"
    command_chk=$(eval $COMMAND_CHK)

    if [ "$command_chk" ];then
    # if command_chk is true, it will be executed as Unix command

      exec_command=$(echo "$exec_command" | $SED "s/{%%%%%%%%%%%%}/|/g")
      if [[ ${org_command} == *\>* ]];then
         cmd_check_error="you can't use redirect"
         exec_command=""
      fi

      if [[ ${org_command} == *\|* ]];then
        for devided_command in $(echo "$org_command" | $SED "s/|/ /g")
        do
          command=$(echo "$devided_command" | $SED "s/_/ /g" | $AWK -F " " '{print $1}')

          if [[ ! $ALLOWED_COMMANDS == *${command}* ]];then
             cmd_check_error="command $command is not allowed"
             exec_command=""
          fi

          ((command_count += 1))
        done
      fi 
    else
      # else mean there is no allowed unix command to be pipelined to the data and it will be used as just filering words of grep
      filter_command=$(echo "$exec_command" | $SED "s/ / | grep -i /g" | $SED "s/^/grep -i /g")
      filter_flag="yes"
      filter_words=$(echo "$org_command" | $SED "s/_/,/g")
    fi

    if [ "$filter_flag" = "yes" ];then
    # Yes means handle command just as filter words

      if [ "$type" = "log" ];then
        # execute filtering command for log
        log_tmp=${ROOT}/tmp/exec/${exec_session}.result.tmp.log
        echo "cat $target_file | $filter_command" > ${ROOT}/tmp/exec/${exec_session}
        chmod 700 ${ROOT}/tmp/exec/${exec_session}
        ${ROOT}/tmp/exec/${exec_session} > $log_tmp
        target_file=$log_tmp
        count=1

        for filter_word in $(echo "$filter_words" | $SED "s/,/ /g")
        do
          cat $target_file | $SED "s/${filter_word}/<b>$filter_word<\/b>/g" > ${target_file}.${count}
          target_file="${target_file}.${count}"
          ((count += 1))
        done

        exec_command="filter:$filter_words"

        # Generate result file for log filtering
        cat $target_file  > ${ROOT}/tmp/exec/${exec_session}.result

      fi

      if [ "$type" = "data" ];then
        echo "cat $target_file | $filter_command" > ${ROOT}/tmp/exec/${exec_session}
        chmod 700 ${ROOT}/tmp/exec/${exec_session}

        # execute filtering command for data
        filter_tmp=${ROOT}/tmp/exec/${exec_session}.result.tmp.filter
        ${ROOT}/tmp/exec/${exec_session} > $filter_tmp
        data_type_chk=$(cat ${ROOT}/databox/${databox}/def/col* | grep -e "type=\"file\"" -e "type=\"url\"")
        exec_command="filter:$filter_words"
        target_file=$filter_tmp
        count=1
      
        for filter_word in $(echo "$filter_words" | $SED "s/,/ /g")
        do
          # remove line which contain filter words inside id hash
          echo "cat $target_file | $AWK -F "::::::"  '\
                {\
                   IGNORECASE = 1;\
                   if(match(\$3, /${filter_word}/))\
                   print \$0;\
                }\
          '" > ${ROOT}/tmp/exec/${exec_session}.${count}.exe
          chmod 700 ${ROOT}/tmp/exec/${exec_session}.${count}.exe
          target_file="${target_file}.${count}"
          ${ROOT}/tmp/exec/${exec_session}.${count}.exe > $target_file
  
          if [ "$format" = "html_tag" ];then

            # remove ID field with nl
            cat $target_file  | $AWK -F "::::::" '{print $2}' | $SED "s/^/::::::/g" | $SED "s/$/::::::/g" | nl > ${target_file}.id

            # highlight filter words if it's not contain file or url type of data
            if [ ! "$data_type_chk" ];then
              cat $target_file  | $AWK -F "::::::" '{print $3}' | $SED "s/${filter_word}/<b>$filter_word<\/b>/g" | nl > ${target_file}.data
            else
              cat $target_file  | $AWK -F "::::::" '{print $3}' | nl > ${target_file}.data
            fi

            join  ${target_file}.id ${target_file}.data \
            | $SED "s/ ::::::/######/g" | $SED "s/:::::: /::::::/g" | $SED -r "s/^(.*)######/::::::/g" > ${target_file}.${count}
            target_file="${target_file}.${count}"

          fi 
          ((count += 1))
        done
        # Generate result file for data filtering
        cat $target_file  > ${ROOT}/tmp/exec/${exec_session}.result
      fi

    elif [ "$exec_command" -a ! "$cmd_check_error" ];then
    # it means no filter_flag and command will be pipelined to the data and work as Unix command not filtering.

      if [ "$type" = "log" ];then
        log_tmp=${ROOT}/tmp/exec/${exec_session}.result.tmp.log
        unix_command=$(echo "$exec_command" | $SED "s/{%%%%%%}/,/g" \
        | $SED "s/{%%%%%%%%%%%%%%}/$/g" | $SED "s/{%%%%%%%%%%%%%%%%%}/'/g")

        echo "cat $target_file |  $SED "s/{%%%%%%}/,/g" | $unix_command" > ${ROOT}/tmp/exec/${exec_session}.command.exe
        chmod 700 ${ROOT}/tmp/exec/${exec_session}.command.exe
        # execute unix command for log
        ${ROOT}/tmp/exec/${exec_session}.command.exe > $log_tmp
      fi

      if [ "$type" = "data" ];then
        unix_command=$(echo "$exec_command" | $SED "s/{%%%%%%}/,/g" \
        | $SED "s/{%%%%%%%%%%%%%%}/$/g" | $SED "s/{%%%%%%%%%%%%%%%%%}/'/g")

        # detouch hash id  to be accurate input for Unix command. because hash id has so many random characters, it must be detouched.
        echo "cat $target_file | $AWK -F "::::::" '{print \$3}' | $SED "s/{%%%%%%}/,/g" | $unix_command" > ${ROOT}/tmp/exec/${exec_session}.command.exe
        chmod 700 ${ROOT}/tmp/exec/${exec_session}.command.exe

        # execute unix command for data
        data_tmp=${ROOT}/tmp/exec/${exec_session}.result.tmp.data
        ${ROOT}/tmp/exec/${exec_session}.command.exe > $data_tmp
        target_file=$data_tmp
        num_of_line=$(cat $target_file | wc -l | tr -d " ")


        # Generate result file

        if [ "$num_of_line" -lt 100 ];then
        # will try to recover detouched hash id again. but it will consume CPU resource, so only 100 line will be recovered.

          while IFS= read line
          do
            primary_key_name=$(cat ${ROOT}/databox/${databox}/def/col1 | grep "^name=\"" | $AWK -F "name=" '{print $2}' | $SED "s/\"//g")
            if [ ! "$primary_key_name" = "hashid" ];then
              hashid=$(echo "$line" | $AWK -F "," '{print $1}' \
              | $SED "s/{%%%%%%%%%%%%%%%%%}/'/g"\
              | $SED "s/{%%%%%%%%%%%%%%%%}/%/g"\
              | $SED "s/{%%%%%%%%%%%%%%%}/*/g"\
              | $SED "s/{%%%%%%%%%%%%%%}/$/g"\
              | $SED "s/{%%%%%%%%%%%%%}/#/g"\
              | $SED "s/{%%%%%%%%%%%%}/|/g"\
              | $SED "s/{%%%%%%%%%%%}/\]/g"\
              | $SED "s/{%%%%%%%%%%}/\[/g"\
              | $SED "s/{%%%%%%%%%}/)/g"\
              | $SED "s/{%%%%%%%%}/(/g"\
              | $SED "s/{%%%%%%%}/_/g"\
              | $SED "s/{%%%%%%}/,/g"\
              | $SED "s/{%%%%%}/\//g"\
              | $SED "s/{%%%%}/\&/g"\
              | $SED "s/{%%%}/:/g"\
              | $SHASUM | $AWK '{print $1}')
            else
              hashid=$(echo "$line" | $AWK -F "," '{print $1}')
            fi

            id_chk=$(grep "::::::$hashid::::::" ${ROOT}/databox/${databox}/index | $AWK -F "::::::" '{print $2}')

            if [ "$id_chk" ];then
              echo "::::::$hashid::::::$line" >> ${ROOT}/tmp/exec/${exec_session}.result
            else
              echo "$line" >> ${ROOT}/tmp/exec/${exec_session}.result
            fi
          done < $target_file
        else
          echo "<b>Info: <a>link</a> can be generated within 100 line of command result</b>" > ${ROOT}/tmp/exec/${exec_session}.result
          echo "Result is $num_of_line line" >> ${ROOT}/tmp/exec/${exec_session}.result
          echo "------------------------------------------------------------------" >> ${ROOT}/tmp/exec/${exec_session}.result
          cat $target_file >> ${ROOT}/tmp/exec/${exec_session}.result
        fi
      fi
    fi
  fi

  if [ ! -f ${ROOT}/tmp/exec/${exec_session}.result ];then
    touch ${ROOT}/tmp/exec/${exec_session}.result
  fi

  # render by html format
  if [ "$format" = "html_tag" -a -f ${ROOT}/tmp/exec/${exec_session}.result ];then

    if [ "$col_list" ];then
      header_info=$(grep "^label=" ${ROOT}/databox/${databox}/def/col*  | $SED "s/,//g" \
      | $SED "s/</\&lt;/g" | $SED "s/>/\&gt;/g" | sort -V | $AWK -F"label=" '{print $2}' | $SED "s/\"//g" \
      | $SED "s/ /\&nbsp;/g" | $SED -z "s/\n/,/g" | $SED "s/,$//g" | $SED "s/,/, /g" | cut -d "," -f ${col_list})
    else
      header_info=$(grep "^label=" ${ROOT}/databox/${databox}/def/col*  | $SED "s/,//g" | sort -V \
      | $SED "s/</\&lt;/g" | $SED "s/>/\&gt;/g" |  $AWK -F"label=" '{print $2}' | $SED "s/\"//g" \
      | $SED "s/ /\&nbsp;/g" | $SED -z "s/\n/,/g" | $SED "s/,$//g")
    fi

    # ---------------------------------------------------------------------------
    # render HTML with flexbox table format
    # ---------------------------------------------------------------------------
    if [[ $org_command == show_all* ]];then
      echo "<div class=\"table\">"
      echo "<ul>"
      echo "<li class=\"table-header\">"
      header_items="#,$header_info"
      for header_item in $(echo "$header_info" | $SED "s/,/ /g")
      do
        echo "<p>$header_item</p>"
      done
      echo "</li>"
      cat ${ROOT}/tmp/exec/${exec_session}.result  | $SED -r "s/^::::::/<li><p><a href=\".\/${app}?%%params\&req=get\&id=/g"  \
      | $SED -r "s/::::::/\">/g" \
      | $SED -r "s/,/<\/a><\/p><p>/1" \
      | $SED "s/,/<\/p><p>/g" \
      | $SED "s/$/<\/p><\/li>/g" 
 
      if [ "$result" = "no" ];then
        echo "No result"
      fi
      echo "</ul>"
      echo "</div>"
    fi

    # ---------------------------------------------------------------------------
    # render HTML with formal table format
    # ! please uncomment these lines if you want to use formal html table tags. 
    # ! then remove above lines for easy table format
    # ---------------------------------------------------------------------------
    #if [[ $org_command == show_all* ]];then
    #  echo "<table>"
    #  echo "<thead>"
    #  echo "<tr>"
    #  header_items="#,$header_info"
    #  for header_item in $(echo "$header_info" | $SED "s/,/ /g")
    #  do
    #    echo "<th>$header_item</th>"
    #  done
    #  echo "</tr>"
    #  echo "</thead>"
    #  echo "<tbody>"
    #  cat ${ROOT}/tmp/exec/${exec_session}.result  | $SED -r "s/^::::::/<tr><td><a href=\".\/${app}?%%params\&req=get\&id=/g"  \
    #  | $SED -r "s/::::::/\">/g" \
    #  | $SED -r "s/,/<\/a><\/td><td>/1" \
    #  | $SED "s/,/<\/td><td>/g" \
    #  | $SED "s/$/<\/td><\/tr>/g"
    #  echo "</tbody>"
    #  echo "</table>"
    #
    #  if [ "$result" = "no" ];then
    #    echo "No result"
    #  fi
    #fi
    #
    # ---------------------------------------------------------------------------

    # redner HTML with <pre></pre>
    if [[ ! $org_command == show_all* ]];then
      echo "<pre>"

      if [ "$type" = "log" ];then
        display_command=">> $databox.log | $exec_command"
      fi

      if [ "$type" = "data" ];then
        display_command=">> $databox.dump:csv | $exec_command"
      fi

      if [ -s ${ROOT}/tmp/exec/${exec_session}.result ];then
        echo "$display_command"

        if [[ $exec_command == filter:* ]]; then
          if [ "$type" = "data" ];then
            echo ""
            line_num=$(cat ${ROOT}/tmp/exec/${exec_session}.result | wc -l | tr -d " " )
            echo "Result: $line_num"
            #echo "Label:  $header_info"
          fi

          if [ "$type" = "log" ];then
            echo ""
            line_num=$(cat ${ROOT}/tmp/exec/${exec_session}.result | wc -l | tr -d " " )
            echo "Result: $line_num"
          fi

        else
          echo ""
          #echo "###################"
          #echo "# <b>COMMAND RESULT</b>"
          #echo "###################"
        fi

        # dump result
        cat ${ROOT}/tmp/exec/${exec_session}.result \
        | $SED -r "s/^::::::/<a href=\".\/${app}?%%params\&req=get\&id=/g" | $SED -r "s/::::::/\">link <-  <\/a>/g"

      elif [ "$cmd_check_error" ];then
        echo "<b># Oops! there is a problem</b>"
        echo "$cmd_check_error"
      
      else 
        echo "$display_command"
        echo ""
        echo "<b>NO RESULT</b>"
      fi
      
      echo ""
      echo "..done"
      echo "</pre>"
    fi
  fi

  if [ ! "$format" = "html_tag" ];then

    if [ "$col_list" ];then
      header_info=$(grep "^name=" ${ROOT}/databox/${databox}/def/col* | sort -V \
      | $AWK -F"=" '{print $2}' | $SED "s/\"//g" | tr -d ' ' | $SED -z "s/\n/,/g" | $SED "s/,$//g"  | cut -d "," -f ${col_list})
    else
      header_info=$(grep "^name=" ${ROOT}/databox/${databox}/def/col* | sort -V \
      |  $AWK -F"=" '{print $2}' | $SED "s/\"//g" | tr -d ' ' | $SED -z "s/\n/,/g" | $SED "s/,$//g")
    fi
    header_info="id,$header_info"

    # remove hash id, separator and others
    if [ ! "$data_type_chk" ];then
      cat ${ROOT}/tmp/exec/${exec_session}.result | $SED "s/^:::::://g" | $SED "s/::::::/,/g" | $SED "1s/^/${header_info}\n/" \
      | $SED "s/,-,/,,/g" | $SED "s/,-$/,/g" | $SED  "s/<a href=\"//g" \
      | $SED "s/\" (.*)//g" > ${ROOT}/tmp/exec/${exec_session}.result_for_other_format
    else
      # data type is including URL or file
      cat ${ROOT}/tmp/exec/${exec_session}.result | $SED -r "s/^:::::://g" | $SED -r "s/::::::/,/g" | $SED "1s/^/${header_info}\n/" \
      | $SED "s/,-,/,,/g" | $SED "s/,-$/,/g" > ${ROOT}/tmp/exec/${exec_session}.result_for_other_format
    fi

  fi

  # render by none format
  if [ "$format" = "none" -a -f ${ROOT}/tmp/exec/${exec_session}.result -a ! "$cmd_check_error" ];then
    cat ${ROOT}/tmp/exec/${exec_session}.result_for_other_format | $SED -e '1d'
  elif [ "$format" = "none"  -a "$cmd_check_error" ];then
    echo "error: $cmd_check_error"
  fi

  # render by csv format
  if [ "$format" = "csv" -a -f ${ROOT}/tmp/exec/${exec_session}.result -a ! "$cmd_check_eror" ];then

    if [ "$type" = "log" ];then
      echo "error: csv can be provided only for data"

      ls ${ROOT}/tmp/exec/${exec_session}* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        rm ${ROOT}/tmp/exec/${exec_session}*
      fi
      exit 1

    fi

    # filtered_key check
    id_chk=$(echo "$key_list" | grep ^id,)

    if [ "$id_chk" ];then
      # render csv with keeping id
      cat ${ROOT}/tmp/exec/${exec_session}.result_for_other_format
    else
      # render csv with removing id 
      cat ${ROOT}/tmp/exec/${exec_session}.result_for_other_format | cut -d "," -f 2-
    fi

  elif [  "$format" = "csv" -a "$cmd_check_error" ];then
    echo "error: $cmd_check_error"
  fi

  # render by json format
  if [ "$format" = "json" -a -f ${ROOT}/tmp/exec/${exec_session}.result -a ! "$cmd_check_error" ];then

    if [ "$type" = "log" ];then
      echo "error: json can be provided only for data"

      ls ${ROOT}/tmp/exec/${exec_session}* >/dev/null 2>&1
      if [ $? -eq 0 ];then
        rm -rf ${ROOT}/tmp/exec/${exec_session}*
      fi

      exit 1
    fi

    if [[ $databox == *.events ]];then
      # handle events json for Scratch APP
      # load base URL
      . ${ROOT}/web/base

      header_info="id,title,start,end,color,description,detail"
      cat ${ROOT}/tmp/exec/${exec_session}.result_for_other_format \
      | $SED "s#^#${base_url}$app?%%params\&req=get\&databox=$databox\&&id=#g" \
      | $AWK -F "," '{print $0","$1}' | cut -f 2- -d "," \
      | $SED "1s/hashid/id/g" > ${ROOT}/tmp/exec/${exec_session}.add_calendar
      cat ${ROOT}/tmp/exec/${exec_session}.add_calendar > ${ROOT}/tmp/exec/${exec_session}.result_for_other_format

      # change csv -> json
      json_tmp="${ROOT}/tmp/exec/${exec_session}.json.tmp.1"
      cat ${ROOT}/tmp/exec/${exec_session}.result_for_other_format | $SED "s/\"/\\\\\"/g" \
      | $SED -e '1d' | $SED "s/^/{ %%key/g" | $SED "s/$/\" }%%comma/g" >> $json_tmp

    else
      # normal json format
      # change csv -> json
      json_tmp="${ROOT}/tmp/exec/${exec_session}.json.tmp.1"
      echo "[" > $json_tmp
      cat ${ROOT}/tmp/exec/${exec_session}.result_for_other_format | $SED "s/\"/\\\\\"/g" \
      | $SED -e '1d' | $SED "s/^/{ %%key/g" | $SED "s/$/\" }%%comma/g" >> $json_tmp
      echo "]" >> $json_tmp
    fi


    keys=$(echo "$header_info" | $SED "s/,/ /g")
    for key in $keys
    do
      cat $json_tmp | $SED "s/%%key/\"${key}\": \"/g" | $SED "s/,/\"%%comma %%key/1"  > $json_tmp.1
      json_tmp="$json_tmp.1"
    done

    # render json
    cat $json_tmp | $SED -z "s/\n//g" | $SED "s/%%comma/,/g" | $SED "s/},]/}]/g" | $SED "s/$/\n/g"


  elif [ "$format" = "json" -a "$cmd_check_error" ];then
    echo "error: $cmd_check_error"
  fi

  ls ${ROOT}/tmp/exec/${exec_session}* >/dev/null 2>&1
  if [ $? -eq 0 ];then
     rm -rf ${ROOT}/tmp/exec/${exec_session}*
  fi
  exit 0

fi

## DATA HANDLER ##
function get_data(){
  local id=$1
  local key=$2
  local format=$3
  local primary_key=$4
  local addkvl=""

  # load column profile
  col=$(grep -l name=\"${key}\" ${ROOT}/databox/${databox}/def/col* | xargs basename -a  2>/dev/null)
  if [ ! "$col" ];then
    echo "error: there is no key:$key"
    return 1
  fi

  cp ${ROOT}/databox/${databox}/def/${col} ${ROOT}/tmp/exec/${exec_session}.$col
  chmod 700 ${ROOT}/tmp/exec/${exec_session}.$col
  . ${ROOT}/tmp/exec/${exec_session}.$col
  label=$(echo "$label" | $SED "s/</\&lt;/g" | $SED "s/>/\&gt;/g")

  if [ "$format" = "html_tag" ];then

    if [ "$id" = "new" ];then
       value=""
     else
       if [ -d "${ROOT}/databox/${databox}/data/${id}" ];then
         value=$(cat ${ROOT}/databox/${databox}/data/${id}/${key} 2>/dev/null | $SED "s/\"/\&quot;/g" | $SED "s/'/\&apos;/g")
       else
         if [ -d  ${ROOT}/databox/${databox}/log/${id} ];then
            echo "error: there is no id:${id}, data has been already deleted, please check data history"
            echo "------------------------------------------------------------------------------------------------"
            cat  ${ROOT}/databox/${databox}/log/${id}/history 2>/dev/null 
            exit 1
         else
            echo "error: there is no id:$id"
            return 1
         fi
      fi
    fi

    # If id is new, value will be null. If id is existing, value will be inserted.

    # render HTML tags
    if [ "$type" = "text" -o "$type" = "email" -o "$type" = "number" -o "$type" = "date"  -o "$type" = "datetime-local" -o "$type" = "tel" ];then
      if [ "$key" = "$primary_key" ];then 
         if [ ! "$primary_key" = "hashid" ];then
           if [ "$id" = "new" ];then
             echo "<li>"
             echo "<label>$label</label>"
             echo "<input type=\"$type\" name=\"$name\" value=\"$value\" $option>"
             echo "</li>"
           else
             echo "<li>"
             echo "<label>$label (Fixed)</label>"
             echo "<p>$value</p>"
             echo "</li>"
           fi
         fi
      else
        echo "<li>"
        echo "<label>$label</label>"
        echo "<input type=\"$type\" name=\"$name\" value=\"$value\" $option>"
        echo "</li>"
      fi
    fi

    if [ "$type" = "url" ];then
      if [ "$id" = "new" ];then
         echo "<li>"
         echo "<label>$label</label>"
         echo "<input type=\"$type\" name=\"$name\" value=\"$value\" $option>"
         echo "</li>"
      else
         if [ "$value" ];then
           echo "<li>"
           value_chk=$(echo "$value" | grep "$app?%%params")
           if [ "$value_chk" ];then
             echo "<label><a href=\"${value}\">$label</a></label>"
           else
             echo "<label><a href=\"${value}\" target=\"_blank\" rel=\"noopener noreferrer\">$label</a></label>"
           fi
           echo "<input type=\"$type\" name=\"$name\" value=\"$value\" $option>"
           echo "</li>"
         else
           echo "<li>"
           echo "<label>$label</label>"
           echo "<input type=\"$type\" name=\"$name\" value=\"$value\" $option>"
           echo "</li>"
        fi
      fi
    fi

    if [ "$type" = "select" ];then
      echo "<li>"
      echo "<label>$label</label>"
      echo "<select name=\"$name\" $option>"

      if [ "$value" ];then
         echo "<option value=\"${value}\">$value</option>"
      else
         echo "<option value=\"\" disabled selected>-</option>"
      fi

      for param in $(echo "$params" | $SED "s/ /%%space/g" | $SED "s/,/ /g")
      do
        param=$(echo "$param" | $SED "s/%%space/ /g")
        echo "<option value=\"${param}\">$param</option>"
      done
      echo "</select>"
      echo "</li>"
    fi

    if [ "$type" = "radio" ];then
      echo "<li>"
      echo "<label>$label</label>"

      for param in $(echo "$params" | $SED "s/ /%%space/g" | $SED "s/,/ /g")
      do
        param=$(echo "$param" | $SED "s/%%space/ /g")

        if [ "$value" = "$param" ];then
          echo "<input type=\"radio\" name=\"$name\" value=\"$param\" checked=\"checked\" $option>"
        else
          echo "<input type=\"radio\" name=\"$name\" value=\"$param\" $option>"
        fi
        echo "<label class=\"radio-label\">$param</label>"
      done
      echo "</li>"
    fi

    if [ "$type" = "checkbox" ];then
      echo "<li>"
      echo "<input type=\"hidden\" name=\"$name\" value=\"null\">"
      if [ "$value" = "yes" ];then
        echo "<input type=\"checkbox\" name=\"${name}\" value=\"yes\" checked=\"checked\">"
      else
        echo "<input type=\"checkbox\" name=\"${name}\" value=\"yes\">"
      fi
        echo "<label class=\"checkbox-label\">${label}</label>"
      echo "</li>"
    fi

    if [ "$type" = "textarea" ];then
      echo "<li>"
      echo "<label>$label</label>"
      if [ "$value" ];then
        echo "<textarea name=\"${name}\" rows=\"4\" id=\"txtara\" $option>$value</textarea>"
      else 
        echo "<textarea name=\"${name}\" rows=\"4\" id=\"txtara\" $option></textarea>"
      fi
      echo "</li>"
    fi

    if [ "$type" = "file" ];then
      echo "<li>"
      echo "<label id=\"gray_label\">#FILE</label>"
      echo "<div class=\"file_form\">"

      if [ "$value" ];then
        echo "<input class=\"file\" type=\"file\" name=\"$name\" id=\"file_input\">"
        file_name=$(echo "$value" | $SED -r "s/ #size(.*)//g")
        echo "<label id=\"file_input_label\" for=\"file_input\">+</label>"
        echo "<label id=\"file_name\"><a href=\"./${app}?%%params&req=file&id=${id}\" download=\"${file_name}\">$value</a></label>"
        echo "</div>"
        echo "</li>"
      else
        echo "<input class=\"file\" type=\"file\" name=\"$name\" id=\"file_input\">"
        echo "<label id=\"file_input_label\" for=\"file_input\">+</label>"
        echo "<label id=\"file_name\">$label</label>"
        echo "</div>"
        echo "</li>"
      fi
    fi

    if [ "$type" = "pdls" ];then

      echo "<li>"
      if [ ! "$addkvl" ];then

        # no addkvl means only extract primary data values
        primary_key_values=$(cat ${ROOT}/databox/${pdlsbox}/index | $AWK -F "::::::" '{print $3}' | $AWK -F "," '{print $1}')
        if [ "$value" ];then
          pdid=$(grep "::::::${value}," ${ROOT}/databox/${pdlsbox}/index | $AWK -F "::::::" '{print $2}')
          if [ "$app" = "base" ];then
            if [ "$pdid" ];then
              echo "<label><a href=\"./${app}?%%pdls&databox=${pdlsbox}&id=${pdid}\">${label}</a></label>"
            else
              echo "<label>${label} # data is not found</label>"
            fi
          else
            echo "<label>${label}</label>"
          fi
        else
          echo "<label>$label</label>"
        fi

      else

        # else means add other key value to pdls data
        kvl_col=$(grep -l "name=\"${addkvl}\"" ${ROOT}/databox/${pdlsbox}/def/col* | xargs basename -a 2>/dev/null | $SED "s/col//g")

        # generate tmp exe file to extract specific column by awk
        echo "cat ${ROOT}/databox/${pdlsbox}/index | $AWK -F \"::::::\" '{print \$3}' \
        | $AWK -F \",\" '{print \$1\" #\"\$$kvl_col}'"  > ${ROOT}/tmp/exec/${exec_session}.pdls.$key

        chmod 755 ${ROOT}/tmp/exec/${exec_session}.pdls.$key
        primary_key_values=$(${ROOT}/tmp/exec/${exec_session}.pdls.$key)

        if [ "$value" ];then
          primary_value=$(echo ${value} | $AWK -F " #" '{print $1}')
          pdid=$(grep "::::::${primary_value}," ${ROOT}/databox/${pdlsbox}/index | $AWK -F "::::::" '{print $2}')

          if [ "$pdid" ];then
            echo "<label><a href=\"./${app}?%%pdls&databox=${pdlsbox}&id=${pdid}\">${label}</a></label>"
          else
            echo "<label>${label} # data is not found</label>"
          fi
        else
          echo "<label>$label</label>"
        fi

      fi

      echo "<input type=\"text\" name=\"$name\" value=\"$value\" autocomplete=\"off\" list=\"pdls.$key\" $option>"
      echo "<datalist id=\"pdls.$key\">"
      echo "$primary_key_values" | $SED "s/^/<option value=\"/g" | $SED "s/$/\">/g" \
      | $SED "s/{%%%%%%%%%%%%%%%%%}/'/g"\
      | $SED "s/{%%%%%%%%%%%%%%%%}/%/g"\
      | $SED "s/{%%%%%%%%%%%%%%%}/*/g"\
      | $SED "s/{%%%%%%%%%%%%%%}/$/g"\
      | $SED "s/{%%%%%%%%%%%%%}/#/g"\
      | $SED "s/{%%%%%%%%%%%%}/|/g"\
      | $SED "s/{%%%%%%%%%%%}/\]/g"\
      | $SED "s/{%%%%%%%%%%}/\[/g"\
      | $SED "s/{%%%%%%%%%}/)/g"\
      | $SED "s/{%%%%%%%%}/(/g"\
      | $SED "s/{%%%%%%%}/_/g"\
      | $SED "s/{%%%%%%}/,/g"\
      | $SED "s/{%%%%%}/\//g"\
      | $SED "s/{%%%%}/\&/g"\
      | $SED "s/{%%%}/:/g"
      echo "</datalist>"
      echo "</li>"
    fi

    if [ "$type" = "mls" ];then

      if [ "$app" = "base" ];then
        users=$(${ROOT}/bin/meta get.users) 
      else
        users=$(${ROOT}/bin/meta get.users:$app) 
      fi

      echo "<li>"
      echo "<label>$label</label>"
      echo "<input type=\"text\" name=\"$name\" value=\"$value\" autocomplete=\"off\" list=\"mls.$key\" $option>"
      echo "<datalist id=\"mls.$key\">"
      echo "$users" | $SED "s/^/<option value=\"/g" | $SED "s/$/\">/g" 
      echo "</datalist>"
      echo "</li>"

    fi

  fi

  if [ "$format" = "json" ];then

    if [ "$id" = "new" ];then
      echo "error: you can't get any data if you set id as new with non format"
      return 1
    fi

    if [ ! -d "${ROOT}/databox/${databox}/data/${id}" ];then
      echo "error: there is no data #$id"
      return 1 
    fi

    if [ "$type" = "checkbox" ];then
      value=$(cat ${ROOT}/databox/${databox}/data/${id}/${key} 2>/dev/null | $SED -z "s/^\n//g" | $SED -z "s/\n/ /g" | $SED "s/ $//g" \
      | $PHP -r "echo addslashes(file_get_contents('php://stdin'));")
      echo "  \"${key}\": \"${value}\"" >> ${ROOT}/tmp/json/${session}.data
    else
      value=$(cat ${ROOT}/databox/${databox}/data/${id}/${key} 2>/dev/null | $SED -z "s/\n$//g" | $SED -z "s/\n/_%%enter_/g"\
      | $PHP -r "echo addslashes(file_get_contents('php://stdin'));")
      echo "  \"${key}\": \"${value}\"" >> ${ROOT}/tmp/json/${session}.data
    fi

  fi

  if [ "$format" = "none" ];then

    if [ "$id" = "new" ];then
      echo "error: you can't get any data if you set id as new with non format"
      return 1
    fi

    if [ ! -d "${ROOT}/databox/${databox}/data/${id}" ];then
      echo "error: there is no id:$id"
      return 1 
    fi

    value=$(cat ${ROOT}/databox/${databox}/data/${id}/${key} 2>/dev/null | $SED -z "s/\n/_%%enter_/g" | $SED "s/^ //g" | $SED "s/ $//g" \
    | $SED "s/_%%enter_$//g")
    echo "${key}:${value}"

  fi
  return 0
}

function get_mergeable_data(){
  local id=$1
  local key=$2
  local format=$3
  local primary_key=$4

  if [ ! "$format" = "html_tag" ];then
    echo "error: merge option could be used only for html tag"
    return 1
  fi

  col=$(grep -l name=\"${key}\" ${ROOT}/databox/${databox}/def/col* | xargs basename -a  2>/dev/null)
  if [ ! "$col" ];then
    echo "error: there is no key:$key"
    return 1
  fi

  # load column profile
  cp ${ROOT}/databox/${databox}/def/${col} ${ROOT}/tmp/exec/${exec_session}.$col
  chmod 700 ${ROOT}/tmp/exec/${exec_session}.$col
  . ${ROOT}/tmp/exec/${exec_session}.$col

  if [ ! "$type" = "textarea" ];then
    echo "error: merge option could be used only for textarea"
    return 1
  fi

  if [ "$id" = "new" ];then
    echo "error: id:new is not allowed for mergeble data"
    return 1
    
  else
    if [ -d "${ROOT}/databox/${databox}/data/${id}" ];then
      value=$(cat ${ROOT}/databox/${databox}/data/${id}/${key} | $SED "s/\"/\&quot;/g" | $SED "s/'/\&apos;/g")
    else
      if [ -d ${ROOT}/databox/${databox}/log/${id} ];then
        echo "error: there is no id:${id},data has been already deleted, please check data history"
        echo "------------------------------------------------------------------------------------------------"
        cat  ${ROOT}/databox/${databox}/log/${id}/history
        return 1
      else
        echo "error: there is no id:$id"
        return 1
      fi
    fi
  fi


  # render HTML tags
  echo "<li>"
  echo "<label>$label</label>"
  echo "<pre>$value</pre>"
  echo "<label>+</label>"
  echo "<textarea name=\"${name}\" rows=\"3\" id=\"txtara\" $option></textarea>"
  echo "</li>"
  return 0
}

function gen_id(){
  local primary_key=$primary_key

  if [ "$primary_key" = "hashid" ];then
    id=$(echo "primary key will be generated $gen $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM" | $SHASUM | $AWK '{print $1}')
  elif [ -f ${input_dir}/${primary_key} ];then
    id=$(cat ${input_dir}/${primary_key} | $SHASUM | $AWK '{print $1}')
  elif [ "$input_dir" = "null"  ];then
    id=$(echo "$value" | $SHASUM | $AWK '{print $1}')
  else
    echo "error: failed to generate hashid something wrong"
    return 1
  fi


  if [ ! -d ${ROOT}/databox/${databox}/data/${id} ];then
    mkdir ${ROOT}/databox/${databox}/data/${id}

    if [ ! -d ${ROOT}/databox/${databox}/log/${id} ];then
      mkdir ${ROOT}/databox/${databox}/log/${id}
    fi

    chmod 700 ${ROOT}/databox/${databox}/data/${id}
    chmod 700 ${ROOT}/databox/${databox}/log/${id}
    echo "$(date +%Y-%m-%d) $(date +%T),created by $user" >> ${ROOT}/databox/${databox}/log/${id}/history
    echo "$id" > ${ROOT}/databox/${databox}/data/${id}/hashid
  fi

  echo "successfuly generated id:$id"
  return 0
}

function set_data(){
  local id=$1
  local key=$2
  local value=$3
  local input_dir=$4
  local flag=$5
  local set_option=$6

  if [ ! -d ${ROOT}/databox/${databox}/data/${id} ];then
    if [ -d  ${ROOT}/databox/${databox}/log/${id} ];then
      echo "error: data has been already deleted, please check data history"
      echo "--------------------------------------------------------------"
      cat  ${ROOT}/databox/${databox}/log/${id}/history
      return 1
    else
      echo "error: there is no data id:$id"
      return 1
    fi
  fi

  # load type
  type=$(grep -6 "name=\"${key}\"" ${ROOT}/databox/${databox}/def/col* | grep type | $AWK -F "type=" '{print $2}' | $SED "s/\"//g" | $SED '/^$/d')

  # key check
  key_check=$(grep "^name=\"${key}\"" ${ROOT}/databox/${databox}/def/col*)

  if [ ! "${key_check}" ];then
    echo "error: there is no key $key"
    return 1
  fi
   
  primary_key_check=$(grep "^name=\"${key}\"" ${ROOT}/databox/${databox}/def/col1)
  if [ "${primary_key_check}" -a ! "$flag" = "new" ];then
    echo "error: you can not change primary key:$key"
    return 1
  fi

  # load value
  if [ "$input_dir" = "null" ];then
    value=$(echo "$value" | $SED "s/{%%%}/:/g" | $SED "s/%%null//g")
  else
    if [ ! "$type" = "checkbox" ];then
      value=$(cat ${input_dir}/${key})
    else
      value=$(cat ${input_dir}/${key} | grep -v "^null")
      if [ "$value" = "" ];then
        value="-"
      fi
    fi
  fi

  if [ ! "$set_option" = "force" ];then
    if [ ! "$flg" = "new" ];then
      org_value=$(cat ${ROOT}/databox/${databox}/data/${id}/${key} 2>/dev/null | $SHASUM | $AWK '{print $1}')
    fi

    new_value=$(echo "$value" | $SHASUM | $AWK '{print $1}')
    if [ "$org_value" = "$new_value" -a ! "$type" = "file" ];then
      echo "info: $key value{$(echo "$value" | $SED -z "s/\n//g")} is same as original value"
      return 1
    fi
  fi

  # value check for checkbox
  if [ "$type" = "checkbox" ];then
    if [ "$value" != "yes" -a "$value" != "-" ];then
      echo "error: $key value{$value} is not allowed"
      return 1
    fi
  fi

  # value check for select box or radio 
  if [ "$type" = "select" -o "$type" = "radio" ];then
    params=$(grep -6 "name=\"${key}\"" ${ROOT}/databox/${databox}/def/col* | grep params | $AWK -F "params=" '{print $2}' | $SED "s/\"//g" | $SED '/^$/d')

    if [ "$params" ];then
      for param in $(echo "$params" | $SED "s/ /%%space/g" | $SED "s/,/ /g")
      do
        param=$(echo "$param" | $SED "s/%%space/ /g")

        value_check=$(echo "$value" | grep "$param")
        if [ "$value_check" ];then
          break
        fi
      done
      if [ ! "$value_check" ];then
        if [ "$value" ];then
          echo "error: $key value{$value} is not allowed"
          return 1
        fi
      fi
    fi
  fi

  if [ "$type" = "date" ];then
    date_value_chk=$(echo "$value" | $SED "s/[0-9][0-9][0-9][0-9]-[0-1][0-9]-[0-3][0-9]//g")
    value_chk=$(echo "$value" | $SED -z "s/\n//g")
    if [ "$date_value_chk" ];then
      if [ "$value_chk" ];then
        echo "error: $key value{$value_chk} must be yyyy-mm-dd"
        return 1
      fi
    fi
  fi

  if [ "$type" = "datetime-local" ];then
    time_value_chk=$(echo "$value" | $SED "s/[0-9][0-9]//g" | $SED "s/://g" | $SED "s/T//g" | $SED "s/-//g")
    value_chk=$(echo "$value" | $SED -z "s/\n//g")
    if [ "$time_value_chk" ];then
      if [ "$value_chk" ];then
        echo "error: $key value{$value_chk} must be yyyy-mm-ddTmm:ss"
        return 1
      fi
    fi
  fi

  if [ "$type" = "number" ];then
    num_value_chk=$(echo "$value" | $SED "s/[0-9]//g" | $SED "s/-//g")
    value_chk=$(echo "$value" | $SED -z "s/\n//g")
    if [ "$num_value_chk" ];then
      if [ "$value_chk" ];then
        echo "error: $key value{$value_chk} must be numetric character"
        return 1
      fi
    fi
  fi

  if [ "$type" = "email" ];then
    email_value_chk=$(echo "$value" | grep @)
    if [ ! "$email_value_chk" ];then
      if [ "$value" ];then
        echo "error: $key value{$value} must contain @"
        return 1
      fi
    fi
  fi

  if [ "$type" = "url" ];then
    url_value_chk=$(echo "$value" | grep -e ^http:// -e ^https://)
    if [ ! "$url_value_chk" -a ! "$set_option" = "force" ];then
      if [ "$value" ];then
        echo "error: $key value{$value} must contain https or http"
        return 1
      fi
    fi
  fi

  if [ "$type" = "file" ];then
    if [ ! "$value" ];then
      echo "info: $key value is null"
      return 1
    fi
  fi

  if [ "$type" = "pdls" ];then
    pdlsbox=$(grep -6 "name=\"${key}\"" ${ROOT}/databox/${databox}/def/col* | grep pdlsbox | $AWK -F "pdlsbox=" '{print $2}' | $SED "s/\"//g" | $SED '/^$/d')
    primary_key_values=$(cat ${ROOT}/databox/${pdlsbox}/index | $AWK -F "::::::" '{print $3}' | $AWK -F "," '{print $1}')
    value_chk=$(echo "$primary_key_values" | grep "^${value}$")
    if [ ! "$value" -a ! "$value_chk" -a "$set_option" = "force" ];then
      echo "error: $key value{$value} is not alllowed"
      return 1
    fi
  fi

  # SET DATA#
  if [ "$input_dir" = "null" ];then
    if [ "$type" = "file" ];then  
      echo "error: primary_key{$(cat $ROOT/databox/$databox/data/$id/$primary_key \
      | $SED -z "s/\n//g")} file must be set using input_dir:"
      return 1
    fi
    echo "$value" > ${ROOT}/databox/${databox}/data/${id}/${key}
  else
    if [ "$type" = "file" ];then
      file_name=$(cat ${input_dir}/${key})
      size=$(ls -lh ${input_dir}/binary_file/binary.data | $AWK '{print $5}')
      echo "$file_name #size:$size" > ${ROOT}/databox/${databox}/data/${id}/${key}
      \cp -f ${input_dir}/binary_file/binary.data ${ROOT}/databox/${databox}/file/${id}
    else
      if [ ! "$type" = "checkbox" ];then
        cat ${input_dir}/${key} > ${ROOT}/databox/${databox}/data/${id}/${key}
      else
        echo "$value" > ${ROOT}/databox/${databox}/data/${id}/${key}
      fi
    fi
  fi

  if [ $? -eq 0 ];then
    echo "successfully set $key to id:$id"
    return 0
  else
    echo "failed to update data id:$id"
    return 1
  fi

}

function merge_data(){
 local id=$1
 local key=$2
 local value=$3
 local input_dir=$4
 local primary_key=$5


  if [ ! "$id" = "new" -a ! -d ${ROOT}/databox/${databox}/data/${id} ];then
     if [ -d  ${ROOT}/databox/${databox}/log/${id} ];then
       echo "error: data has been already deleted, please check data history"
       echo "--------------------------------------------------------------"
       cat  ${ROOT}/databox/${databox}/log/${id}/history
       return 1
     else
       echo "error: there is no data id:$id"
       return 1
     fi
  fi

  if [ "$id" = "new" ];then
    echo "error: please set primary key value first"
    return 1
  fi

  # load type
  type=$(grep -6 "name=\"${key}\"" ${ROOT}/databox/${databox}/def/col* | grep type | $AWK -F "type=" '{print $2}' | $SED "s/\"//g" | $SED '/^$/d')

  # key check
  key_check=$(grep "^name=\"${key}\"" ${ROOT}/databox/${databox}/def/col*)

  if [ ! "${key_check}" ];then
    echo "error: there is no key $key"
    return 1
  fi

  primary_key_check=$(grep "^name=\"${key}\"" ${ROOT}/databox/${databox}/def/col1)
  if [ "${primary_key_check}" -a ! "$flag" = "new" ];then
    echo "error: you can not change primary key:$key"
    return 1
  fi

  # load value
  if [ "$input_dir" = "null" ];then
    value=$(echo "$value" | $SED "s/{%%%}/:/g" | $SED "s/%%null//g")
  else
    value=$(cat ${input_dir}/${key})
  fi

  if [ ! "$type" = "textarea" ];then
    echo "error: merge could be used only for textarea"
    return 1
  fi

  # MERGE DATA#
  echo "+MERGE $(date +%Y-%m-%d) $(date +%T) updated by $user" >> ${ROOT}/databox/${databox}/data/${id}/${key}
  echo "$value" >> ${ROOT}/databox/${databox}/data/${id}/${key}

  if [ $? -eq 0 ];then
    echo "successfully set $key to id:$id"
    return 0
  else
    echo "something is wrong, please contact to system admin"
    return 1
  fi

}

function del_data(){
  local id=$1

  if [ ! "$id" ];then
     echo "error: please set id"
     return 1
  fi

  if [ -d ${ROOT}/databox/${databox}/data/${id} ];then
      primary_key=$(grep "^name=" ${ROOT}/databox/${databox}/def/col1 | $AWK -F"=" '{print $2}' | $SED "s/\"//g" | $SED "s/ //g")
      primary_key_value=$(cat ${ROOT}/databox/${databox}/data/${id}/${primary_key})
      mv ${ROOT}/databox/${databox}/data/${id} ${ROOT}/databox/${databox}/data/${id}.detouched
      rm -rf ${ROOT}/databox/${databox}/data/${id}.detouched/*
      del_result=$?
      echo "$primary_key_value" > ${ROOT}/databox/${databox}/data/${id}.detouched/${primary_key}

      if [ -f ${ROOT}/databox/${databox}/file/${id} ];then 
        rm -rf ${ROOT}/databox/${databox}/file/${id}
      fi

      if [ $del_result -eq 0 ];then
        echo "sucessfully deleted $id"
        return 0
      else
        echo "error: failed to delete $id"
        return 1
      fi

  else
    if [ -d  ${ROOT}/databox/${databox}/log/${id} ];then
      echo "error: data is already deleted, please check data history"
      echo "--------------------------------------------------------------"
      cat  ${ROOT}/databox/${databox}/log/${id}/history
      return 1
    else
      echo "error: there is no data id:$id"
      return 1
    fi
  fi

}

function get_log(){
  id=$1
  format=$2
  
  if [ ! "$format" = "html_tag" -a ! "$format" = "none" -a ! "$format" = "json" ];then
    echo "error: log format is provided only html_tag or json or none"
    return 1
  fi

  if [ "$format" = "html_tag" ];then 
    if [ -f ${ROOT}/databox/${databox}/log/${id}/history ];then
      echo "<pre>"
      cat ${ROOT}/databox/${databox}/log/${id}/history | $SED "s/,/ /1"
      echo "</pre>"
    else
      echo "error: there is no log"
      return 1
    fi
  fi

  if [ "$format" = "none" ];then 
    if [ -f ${ROOT}/databox/${databox}/log/${id}/history ];then
      cat ${ROOT}/databox/${databox}/log/${id}/history | $SED "s/,/ /1"
    else
      echo "error: there is no log"
      return 1
    fi
  fi

  if [ "$format" = "json" ];then 
    if [ -f ${ROOT}/databox/${databox}/log/${id}/history ];then
      cat ${ROOT}/databox/${databox}/log/${id}/history | $JQ -R 'split(",") | {"Time Stamp": .[0], "Message": .[1]}' | $JQ -s
    else
      echo "error: there is no log"
      return 1
    fi
  fi
}


if [ "$action" ];then

  if [ ! "$id" ];then
    echo "error: please input id"
    exit 1
  fi

  if [ "$action" = "get" ];then

    primary_key=$(grep "^name=" ${ROOT}/databox/${databox}/def/col1 | $AWK -F"=" '{print $2}' | $SED "s/\"//g" | $SED "s/ //g")

    if [ "$type" = "log" ];then
       get_log $id $format
       if [ $? -eq 1 ];then
         ls ${ROOT}/tmp/exec/${exec_session}* >/dev/null 2>&1
         if [ $? -eq 0 ];then
           rm ${ROOT}/tmp/exec/${exec_session}*
         fi
         exit 1
       fi
       exit 0
    fi

    if [ "$keys" ];then

      if [ "$keys" = "all" ];then
        keys=$(grep "^name=" ${ROOT}/databox/${databox}/def/col* | sort -V |  $AWK -F"=" '{print $2}' | $SED "s/\"//g" \
        | $SED "s/ //g" | $SED -z "s/\n/ /g")
      else
        keys=$(echo "$keys" | $SED "s/,/ /g")
      fi
     
      for key in $keys
      do
        get_data $id $key $format $primary_key 
        if [ $? -eq 1 ];then
          ls ${ROOT}/tmp/exec/${exec_session}* >/dev/null 2>&1
          if [ $? -eq 0 ];then 
            rm ${ROOT}/tmp/exec/${exec_session}*
          fi
          exit 1
        fi
      done
    elif [ "$key" ];then
        get_data $id $key $format $primary_key 
        if [ $? -eq 1 ];then
          ls ${ROOT}/tmp/exec/${exec_session}* >/dev/null 2>&1
          if [ $? -eq 0 ];then
            rm ${ROOT}/tmp/exec/${exec_session}*
          fi
          exit 1
        fi
    else
      echo "error: please set key of data"
      exit 1
    fi

    # const & render json data
    if [ "$format" = "json" ];then
      ls ${ROOT}/tmp/json/${session}.data >/dev/null 2>&1
        if [ $? -eq 0 ];then
          cat ${ROOT}/tmp/json/${session}.data | $SED "s/\"/\\\\\"/g" > ${ROOT}/tmp/json/${session}.data.fin
          $SED -i "1s/^/  \"id\": \"${id}\"\n/" ${ROOT}/tmp/json/${session}.data.fin
          echo "{"
          cat ${ROOT}/tmp/json/${session}.data \
          | $SED "s/$/,/g" | $SED -e "$ s/,$//g" | $SED "s/_%%enter_/\\\n/g"
          echo "}"
          rm -rf ${ROOT}/tmp/json/${session}.data*
        fi
     fi
  fi

  if [[ $action == set* ]]; then

    if [ "$app" = "base" ];then
      permission=$(${ROOT}/bin/meta get.attr:$user{permission})
    else
      permission=$(${ROOT}/bin/meta get.attr:${app}/${user}{permission})
    fi

    if [ "$permission" = "ro" ];then
      echo "error: you are read only permission"
      exit 1
    fi

    if [ "$action" = "set.force" ];then
      set_option="force"
    fi

    primary_key=$(grep "^name=" ${ROOT}/databox/${databox}/def/col1 | $AWK -F"=" '{print $2}' | $SED "s/\"//g" | $SED "s/ //g")

    if [ "$type" = "log" ];then
       echo "error: you can not set any value to log"
       exit 1
    fi

    if [ ! "$input_dir" -a ! "$value" ];then
      echo "error: please define input_dir or value"
      exit 1
    fi

    if [ "$value" -a "$input_dir" ];then
      echo "error: you can not use both input_dir and value at same time, please select one option only"
      exit 1
    fi

    if [ ! "$value" ];then
      value=dummy
    fi

    if [ ! "$input_dir" ];then
      input_dir=null 
    fi

    if [ "$keys" ];then
      if [ "$input_dir" = "null" ];then
        echo "error: value can be insert to only 1 key"
        exit 1
      fi

      if [ "$keys" = "all" ];then
        keys=$(grep "^name=" ${ROOT}/databox/${databox}/def/col* | grep -v "name=\"hashid\"" | sort -V |  $AWK -F"=" '{print $2}' | $SED "s/\"//g" \
        | $SED "s/ //g" | $SED -z "s/\n/ /g")
      else
        if [ ! "$id" = "new" ];then
          keys=$(echo "$keys" | $SED "s/,/ /g")
        else
          # adjust key order
          keys=$(echo "$keys" | $SED "s/,/ /g" | $SED "s/^${primary_key} //g" | $SED "s/ ${primary_key} / /g" | $SED "s/ ${primary_key}$//g")
          if [ ! "$primary_key" = "hashid" ];then
            if [ ! "$primary_key" = "$keys" ];then
              keys="$primary_key $keys"
            fi
          fi
        fi
      fi

      updated_keys=""
      count=1
      for key in $keys
      do
        if [ -f ${input_dir}/${key} ];then
          if [ "$count" -eq 1 -a "$id" = "new" ];then
            id=$(gen_id $primary_key | $AWK -F "id:" '{print $2}')
            flag="new"
          else
            flag="update"
          fi

          result=$(set_data "$id" "$key" "$value" "$input_dir" "$flag" "$set_option")
          if [ $? -eq 0 ];then
            updated_keys="$key,$updated_keys"
          fi
          echo "$result"

        else
          echo "warn: there is no $key on $input_dir"
        fi
       ((couht += 1))
      done
   
      if [ "$updated_keys" ];then
        cp ${ROOT}/tmp/session/${session} ${ROOT}/tmp/que/${session}

        if [ ! "$bat" = "yes" ];then
          ${ROOT}/sbin/que $databox $id $updated_keys $session $pin set $app &
        else
          ${ROOT}/sbin/que $databox $id $updated_keys $session $pin set $app
        fi
      fi

    elif [ "$key" ];then
      if [ ! "$input_dir" = "null" ];then
        if [ ! -f ${input_dir}/${key} ];then
          echo "error: there is no value for $key"
          exit 1
        fi
      fi

      if [ "$id" = "new" ];then
        if [ "$primary_key" = "hashid" ];then
          id=$(gen_id $primary_key | $AWK -F "id:" '{print $2}')
          flag="new"
        elif [ "$primary_key" = "$key" -a ! "$primary_key" = "hashid" ];then
          id=$(gen_id $primary_key | $AWK -F "id:" '{print $2}')
          flag="new"
        else
          echo "error: plese set primary key fist"
          exit 1
        fi
      else
        flag="update"
      fi
      result=$(set_data "$id" "$key" "$value" "$input_dir" "$flag" "$set_option")
      if [ $? -eq 0 ];then
        cp ${ROOT}/tmp/session/${session} ${ROOT}/tmp/que/${session}
        if [ ! "$bat" = "yes" ];then
          ${ROOT}/sbin/que $databox $id $key $session $pin set $app &
        else
          ${ROOT}/sbin/que $databox $id $key $session $pin set $app
        fi
      fi

      echo "$result"

    else
       echo "error: please set key of data"
       exit 1
    fi
  fi

  if [ "$action" = "del" ];then

    if [ "$type" = "log" ];then
       echo "error: you can not delete any log"
       exit 1
    fi

    result=$(del_data $id )
    if [ $? -eq 0 ];then
      keys=$(grep "^name=" ${ROOT}/databox/${databox}/def/col*  | sort -V |  $AWK -F"=" '{print $2}' | $SED "s/\"//g" \
      | $SED "s/ //g" | $SED -z "s/\n/ /g")
      updated_keys=""
      for key in $keys
      do
        updated_keys="$key,$updated_keys"           
      done
      cp ${ROOT}/tmp/session/${session} ${ROOT}/tmp/que/${session}
      if [ ! "$bat" = "yes" ];then
        ${ROOT}/sbin/que $databox $id $updated_keys $session $pin del $app &
      else
        ${ROOT}/sbin/que $databox $id $updated_keys $session $pin del $app
      fi
    fi
    echo "$result"

  fi


  if [ "$action" = "merge.get" ];then

    primary_key=$(grep "^name=" ${ROOT}/databox/${databox}/def/col1 | $AWK -F"=" '{print $2}' | $SED "s/\"//g" | $SED "s/ //g")

    if [ "$type" = "log" ];then
       echo "error: mege.get could not get log"
       exit 1
    fi

    if [ "$keys" ];then
       echo "error: mege.get could not get log"
       exit 1
    fi

    if [ ! "$key" ];then
       echo "error: please set key"
       exit 1
    fi

    if [ ! "$format" = "html_tag" ];then
       echo "error: mege.get could not be used with json or csv format"
       exit 1
    fi

    get_mergeable_data $id $key $format $primary_key

  fi

  if [ "$action" = "merge.set" ];then
    primary_key=$(grep "^name=" ${ROOT}/databox/${databox}/def/col1 | $AWK -F"=" '{print $2}' | $SED "s/\"//g" | $SED "s/ //g")

    if [ "$type" = "log" ];then
       echo "error: you can not set any value to log"
       exit 1
    fi

    if [ ! "$format" = "html_tag" ];then
       echo "error: you can use merge option only for HTML format"
       exit 1
    fi

    if [ ! -d "$input_dir" -a ! "$value" ];then
      echo "error: please define input_dir or value"
      exit 1
    fi

    if [ "$value" -a "$input_dir" ];then
      echo "error: you can not use both input_dir and value at same time, please select one option only"
      exit 1
    fi

    if [ ! "$value" ];then
      value=dummy
    fi

    if [ ! "$input_dir" ];then
      input_dir=null
    fi

    if [ "$keys" ];then
      echo "error: merge value can be insert to only 1 key"
      exit 1
    fi

    if [ "$key" ];then
      if [ ! "$input_dir" = "null" ];then
        if [ ! -f ${input_dir}/${key} ];then
          echo "error: there is no value for $key"
          exit 1
        fi
      fi

      if [ "$id" = "new" ];then
        if [ "$primary_key" = "hashid" ];then
          id=$(gen_id $primary_key | $AWK -F "id:" '{print $2}')
          flag="new"
        elif [ "$primary_key" = "$key" -a ! "$primary_key" = "hashid" ];then
          id=$(gen_id $primary_key | $AWK -F "id:" '{print $2}')
          flag="new"
        else
          echo "error: plese set primary key fist"
          exit 1
        fi
      else
        flag="update"
      fi

      result=$(merge_data $id $key $value $input_dir $flag $set_option)
      if [ $? -eq 0 ];then
        cp ${ROOT}/tmp/session/${session} ${ROOT}/tmp/que/${session}
        if [ ! "$bat" = "yes" ];then
          ${ROOT}/sbin/que $databox $id $key $session $pin set $app &
        else
          ${ROOT}/sbin/que $databox $id $key $session $pin set $app
        fi
      fi
      echo "$result"

    else
       echo "error: please set key of data"
       exit 1
    fi
  fi
  
  ls ${ROOT}/tmp/exec/${exec_session}* >/dev/null 2>&1
  if [ $? -eq 0 ];then
    rm ${ROOT}/tmp/exec/${exec_session}*
  fi  

  exit 0
fi
